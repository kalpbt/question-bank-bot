{
  "chapter_name": "3: Transport Layer",
  "pages": [
    {
      "page_number": "1",
      "content": "Darshan\n\ninsthcuey of Engineering a Teehsology 3 — Transport Layer\n\nTransport-Layer services\n\nA transport-layer protocol provides logical communication between application\nprocesses running on different hosts.\n\nBy logical communication, application processes communicate with each other by\nusing the logical communication provided by the transport layer to send messages to\neach other, free from the worry of the details of the physical infrastructure used to\ncarry these messages.\n\nTransport-layer protocols are implemented in the end systems but not in network\nrouters.\n\nOn the sending side, the transport layer converts the application-layer messages it\nreceives from a sending application process into transport-layer packets, known as\ntransport-layer segments.\n\nOn the receiving side, the transport layer reassembles segments into messages,\npasses to application layer.\n\nA network-layer protocol provides logical communication between hosts.\n\nRelationship between Transport and Network Layers\n\nThe transport layer lies just above the network layer in the protocol stack.\n\nWhereas a transport-layer protocol provides logical communication between\nprocesses running on different hosts, a network-layer protocol provides logical\ncommunication between hosts.\n\nLet's examine this distinction with the aid of a household analogy.\n\nConsider two houses, one on the East Coast and the other on the West Coast, with\neach house being home to a dozen kids.\n\nThe kids in the East Coast household are cousins of the kids in the West Coast\nhousehold.\n\nThe kids in the two households love to write to each other-each kid writes each\ncousin every week, with each letter delivered by the traditional postal service in a\nseparate envelope.\n\nThus, each household sends 144 letters to the other household every week.\n\nIn each of the households there is one kid Ann in the West Coast house and Bill in\nthe East Coast house responsible for mail collection and mail distribution.\n\nEach week Ann visits all her brothers and sisters, collects the mail, and gives the mail\nto a postal-service mail person who makes daily visits to the house.\n\nWhen letters arrive at the West Coast house, Ann also has the job of distributing the\nmail to her brothers and sisters. Bill has a similar job on the East Coast.\n\nIn this example, the postal service provides logical communication between the two\nhouses-the postal service moves mail from house to house, not from person to\nperson.\n\nOn the other hand, Ann and Bill provide logical communication among the cousins-\nAnn and Bill pick up mail from and deliver mail to their brothers and sisters.\n\nNote that from the cousins' perspective, Ann and Bill are the mail service, even\nthough Ann and Bill are only a part (the end system part) of the end-to-end delivery\nprocess.\n\nProf. Maulik Trivedi, CE Department | 2140709 — Computer Networks (CN) 1\n"
    },
    {
      "page_number": "2",
      "content": "Darshan\n\nInstitute of Engineering & Technology 3 -— Transport Layer\n\ne This household example serves as a nice analogy for explaining how the transport\nlayer relates to the network layer:\nhosts (also called end systems) = houses\nprocesses = cousins\napplication messages = letters in envelopes\nnetwork-layer protocol = postal service (including mail persons)\ntransport-layer protocol = Ann and Bill\n\ne Continuing with this analogy, observe that Ann and Bill do all their work within their\nrespective homes; they are not involved, for example, in sorting mail in any\nintermediate mail centre or in moving mail from one mail centre to another.\n\ne Similarly, transport-layer protocols live in the end systems. Within an end system, a\ntransport protocol moves messages from application processes to the network edge\n(that is, the network layer) and vice versa; but it doesn't have any say about how the\nmessages are moved within the network core.\n\ne In fact, intermediate routers neither act on, nor recognize, any information that the\ntransport layer may have appended to the application messages.\n\nMultiplexing and Demultiplexing\n\nmultiplexing at sender:\nhandle data trom multiple\nsockets, add transport header\n(later used for demultiplexing)\n\ndemultiplexing at receiver:\nuse header info to deliver\nreceived segments to correct\nsocket\n\napplication\n\napplication application\n\n[EB] socket\nC_ process\n\n=\ntransport\n\nFig. 1 Transport-layer multiplexing and demultiplexing\n\ne The job of gathering data chunks at the source host from different sockets,\nencapsulating each data chunk with header information (that will later be used in\ndemultiplexing) to create segments, and passing the segments to the network layer\nis called multiplexing.\n\ne At the receiving end, the transport layer examines these fields to identify the\nreceiving socket and then directs the segment to that socket. This job of delivering\nthe data in a transport-layer segment to the correct socket is called demultiplexing.\n\nProf. Maulik Trivedi, CE Department | 2140709 — Computer Networks (CN) 2\n"
    },
    {
      "page_number": "3",
      "content": "Darshan\n\nIaieieaed of Engineering a Tachactogy 3 — Transport Layer\n\ne Transport layer in the middle host in Figure 1 must demultiplex segments arriving\nfrom the network layer below to either process P1 or P2 above; this is done by\ndirecting the arriving segment’s data to the corresponding process’s socket.\n\ne The transport layer in the middle host must also gather outgoing data from these\nsockets, form transport-layer segments, and pass these segments down to the\nnetwork layer.\n\nEndpoint Identification\n\ne Sockets must have unique identifiers.\n\ne Each segment must include header fields identifying the socket, these header fields\nare the source port number field and the destination port number field.\n\ne Each port number is a 16-bit number: 0 to 65535.\n\n32 bits\nl\n\nSource port # Dest. port #\n\nOther header fields\n\nApplication\ndata\n(message)\n\nFig. 2 Source and destination port-number fields in a transport-layer segment\n\nConnectionless Multiplexing and Demultiplexing\ne Suppose a process on Host A, with port number 19157, wants to send data to a\nprocess with UDP port 46428 on Host B.\n\n_- Client process\n\n> __|- Socket\nHost A — Server B\n\nsource port: dest. port: -\n19157 46428 E\n\nsource port: dest. port:\n46428 19157\n\nFig. 3 The inversion of source and destination port numbers\ne Transport layer in Host A creates a segment containing source port, destination port,\nand data and then passes it to the network layer in Host A.\ne Transport layer in Host B examines destination port number and delivers segment to\nsocket identified by port 46428.\ne Note: a UDP socket is fully identified by a two-tuple consisting of\n1. adestination IP address\n\nProf. Maulik Trivedi, CE Department | 2140709 — Computer Networks (CN) 3\n"
    },
    {
      "page_number": "4",
      "content": "@\nC Darshan 3 — Transport Layer\n\nInstitute of Engineering & Technology\n\n2. adestination port number\ne Source port number from Host A is used at Host B as \"return address\".\n\nConnection-Oriented Multiplexing and Demultiplexing\n\ne Each TCP connection has exactly two end-points.\n\ne This means that two arriving TCP segments with different source IP addresses or\nsource port numbers will be directed to two different sockets, even if they have the\nsame destination port number.\n\ne SoaTCP socket is identified by four-tuple.\n\nProf. Maulik Trivedi, CE Department | 2140709 — Computer Networks (CN) 4\n"
    },
    {
      "page_number": "5",
      "content": "P Darshan\n\n[aca of Engurnertng a Thales) 3 — Transport Layer\n\nsource IP address 2. destination IP address\n1. source port # 3. destination port #\ne Whereas UDP is identified by only two-tuples\n1. destination IP address 2. destination port #\nWeb client Web Per-connection\n\nHTTP\n\nhost C server B\n7 processes\n\nTransport-\nlayer\ndemultiplexing\n\nWeb client\nhost A\n\nFig. 4 Two clients, using the same destination port number (80) to communicate with the same\nWeb server application\n\nProf. Maulik Trivedi, CE Department | 2140709 — Computer Networks (CN) 5\n"
    },
    {
      "page_number": "6",
      "content": "Darshan\n\nInstitute of Engineering & Technology 3 -— Transport Layer\n\nUDP Segment Structure\n32 bits\n\nSource port # Dest. port #\n\nLength Checksum\n\nApplication\ndata\n(message)\n\nFig. 5 UDP segment structure\n\ne The port numbers allow the destination host to pass the application data to the\ncorrect process running on the destination end system (that is used to perform the\ndemultiplexing function).\n\ne The length field specifies the number of bytes in the UDP segment (header plus\ndata).\n\ne The checksum is used by the receiving host to check whether errors have been\nintroduced into the segment.\n\nHow to calculate (find) checksum:\n\ne The UDP checksum is calculated on the sending side by summing all the 16-bit words\nin the segment, with any overflow being wrapped around and then the 1's\ncomplement is performed and the result is added to the checksum field inside the\nsegment.\n\ne At the receiver side, all words inside the packet are added and the checksum is\nadded upon them if the result is 1111 1111 1111 1111 then the segment is valid else\nthe segment has an error.\n\n0110011001100110\n0101010101010101 } re is wns\n0000111100001111\n\nThe sum of first of two 16-bit words is:\n\n0110011001100110\n0101010101010101\n\nLOL101110111011 > Sum of 1* two 16 bit words.\n\nAdding the third word to the above sum ges:\n\n1011101110111011 > Sum of 1*two 16 bit words\n0000111100001111 + Third 16 bits word\n\n1100101011001010 — Sum ofall three 16 bit words.\n\nTaking 1’s complement for the final sum:\n\n1100101011001010 > Sum ofall three 16 bit words.\n0011010100110101 > 1’s complement for the final sum.\n\nThe 1’s complement value is called as Checksum.\n\nProf. Maulik Trivedi, CE Department | 2140709 — Computer Networks (CN) 6\n"
    },
    {
      "page_number": "7",
      "content": "c Darshan 3 — Transport Layer\n\nInstitute of Engineering & Technology\n\nPrinciples of Reliable Data Transfer\n\nrdt_send() : called from above, deliver _data() : called by\n(e.g., by app.). Passed data to rdt to deliver data to upper\n\ndeliver to receiver upper layer\n\nrdt_send()\n\ndeliver data()\n\nreliable data receive\ntransfer protocol F\nreceiving side side\n\nudt_send(){ packet rdt rev()\n/ L qunerabe channel \\d\n\nudt_send() : called by rdt, rdt_rev() : called when packet\nto transfer packet over arrives on rcv-side of channel\nunreliable channel to receiver\n\nFig. 7 Reliable data transfer commands\n\ne The sending side of the data transfer protocol will be invoked from above by a call to\nrdt_send().\n\ne On the receiving side, rdt_rcv() will be called when a packet arrives from the\nreceiving side of the channel.\n\ne When the rdt protocol wants to deliver data to the upper layer, it will do so by calling\ndeliver_data().\n\ne Both the send and receive sides of rdt send packets to the other side by a call to\nudt_send().\n\nBuilding a Reliable Data Transfer Protocol\n\nReliable Data Transfer over a Perfectly Reliable Channel: rdt1.0\n\ne We first consider the simplest case in which the underlying channel is completely\nreliable.\n\ne The protocol itself, which we will call rdt1.0, is trivial.\n\nrdt_rcv(packet)\n\nextract (packet,data)\ndeliver_data(data)\n\nNait for\ncall from\nabove\n\nrdt_send(data)\ncall from\nbelow\n\npacket = make_pkt(data)\nudt_send(packet)\n\nsender receiver\n\ne The sender and receiver FSMs (Finite State Machines) have only one state.\n\nProf. Maulik Trivedi, CE Department | 2140709 — Computer Networks (CN) 7\n"
    },
    {
      "page_number": "8",
      "content": "Darshan\n\ninsthcuey of Engineering a Teehsology 3 — Transport Layer\n\nThe arrows in the FSM description indicate the transition of the protocol from one\nstate to another. (Since each FSM has just one state, a transition is necessarily from\nthe one state back to itself).\n\nThe event causing the transition is shown above the horizontal line labelling the\ntransition, and the action(s) taken when the event occurs are shown below the\nhorizontal line.\n\nThe sending side of rdt simply accepts data from the upper-layer via the\nrdt_send(data) event, puts the data into a packet (via the action\nmake_pkt(packet,data)) and sends the packet into the channel.\n\nOn the receiving side, rdt receives a packet from the underlying channel via the\nrdt_rcv(packet) event, removes the data from the packet using the action\nextract(packet,data) and passes the data up to the upper-layer.\n\nAlso, all packet flow is from the sender to receiver - with a perfectly reliable channel\nthere is no need for the receiver side to provide any feedback to the sender since\nnothing can go wrong.\n\nReliable Data Transfer over a Channel with Bit Errors: rdt2.0\n\nA more realistic model of the underlying channel is one in which bits in a packet may\nbe corrupted.\n\nSuch bit errors typically occur in the physical components of a network as a packet is\ntransmitted, propagates, or is buffered.\n\nWe'll continue to assume for the moment that all transmitted packets are received\n(although their bits may be corrupted) in the order in which they were sent.\n\nBefore developing a protocol for reliably communicating over such a channel, first\nconsider how people might deal with such a situation.\n\nConsider how you yourself might dictate a long message over the phone. In a typical\nscenario, the message taker might say “‘OK\" after each sentence has been heard,\nunderstood, and recorded. If the message taker hears a garbled sentence, you're\nasked to repeat the garbled sentence. This message dictation protocol uses both\npositive acknowledgements (\"OK\") and negative acknowledgements (“Please repeat\nthat''). These control messages allow the receiver to let the sender know what has\nbeen received correctly, and what has been received in error and thus requires\nrepeating. In a computer network setting, reliable data transfer protocols based on\nsuch retransmission are known ARQ (Automatic Repeat reQuest) protocols.\nFundamentally, two additional protocol capabilities are required in ARQ protocols to\nhandle the presence of bit errors:\n\nError detection: First, a mechanism is needed to allow the receiver to detect when\nbit errors have occurred. UDP transport protocol uses the Internet checksum field for\nexactly this purpose. Error detection and correction techniques allow the receiver to\ndetect, and possibly correct packet bit errors.\n\nReceiver feedback: Since the sender and receiver are typically executing on different\nend systems, possibly separated by thousands of miles, the only way for the sender\nto learn of the receiver's view of the world (in this case, whether or not a packet was\nreceived correctly) is for the receiver to provide explicit feedback to the sender. The\npositive (ACK) and negative acknowledgement (NAK) replies in the message dictation\n\nProf. Maulik Trivedi, CE Department | 2140709 — Computer Networks (CN) 8\n"
    },
    {
      "page_number": "9",
      "content": "@\nC Darshan 3 — Transport Layer\n\nInstitute of Engineering & Technology\n\nscenario are an example of such feedback. Our rdt2.0 protocol will similarly send\nACK and NAK packets back from the receiver to the sender.\n\nrdt_send(data)\n\nsndpkt = make_pkt(data, checksum) receiver\n\nudt_send(sndpkt)\nrdt_rev(revpkt) &&\nisNAK(rcvpkt)\nrdt_rcv(rcvpkt) &&\ncall from udt_send(sndpkt) corrupt(rcvpkt)\n\nabove ——\nudt_send(NAK)\n\nio)\n\nrdt_rcev(rcvpkt) && isACK(rcvpkt) * Avait\n—————— ait for\n\nA call from\nbelow\n\nsender\n\nrdt_rcev(revpkt) &&\nnotcorrupt(rcvpkt)\nextract(rcvpkt,data)\ndeliver_data(data)\nudt_send(ACk)\n\ne The send side of rdt2.0 has two states.\n\ne Inone state, the send-side protocol is waiting for data to be passed down from the\nupper layer.\n\ne Inthe other state, the sender protocol is waiting for an ACK or a NAK packet from\nthe receiver.\n\ne If an ACK packet is received (the notation rdt_rcv(rcvpkt) && isACK(rcvpkt), the\nsender knows the most recently transmitted packet has been received correctly and\nthus the protocol returns to the state of waiting for data from the upper layer.\n\ne If a NAK is received, the protocol retransmits the last packet and waits for an ACK or\nNAK to be returned by the receiver in response to the retransmitted data packet.\n\ne It is important to note that when the receiver is in the wait-for-ACK-or-NAK state, it\ncannot get more data from the upper layer; that will only happen after the sender\nreceives an ACK and leaves this state.\n\ne Thus, the sender will not send a new piece of data until it is sure that the receiver\nhas correctly received the current packet.\n\ne Because of this behaviour, protocols such as rdt2.0 are known as stop-and-wait\nprotocols.\n\ne The receiver-side FSM for rdt2.0 still has a single state.\n\ne On packet arrival, the receiver replies with either an ACK or a NAK, depending on\nwhether or not the received packet is corrupted.\n\ne In above figure the notation rdt_rcv(rcvpkt) && corrupt(rcvpkt) corresponds to the\nevent where a packet is received and is found to be in error.\n\nrdt2.1: sender, handles garbled ACK/NAKs\n\ne Protocol rdt2.0 may look as if it works but unfortunately has a fatal flaw.\n\nProf. Maulik Trivedi, CE Department | 2140709 — Computer Networks (CN) 9\n"
    },
    {
      "page_number": "10",
      "content": "Darshan\n\ninsthcuey of Engineering a Teehsology 3 — Transport Layer\n\ne In particular, we haven't accounted for the possibility that the ACK or NAK packet\ncould be corrupted.\n\ne Minimally, we will need to add checksum bits to ACK/NAK packets in order to detect\nsuch errors.\n\ne The more difficult question is how the protocol should recover from errors in ACK or\nNAK packets.\n\ne The difficulty here is that if an ACK or NAK is corrupted, the sender has no way of\nknowing whether or not the receiver has correctly received the last piece of\ntransmitted data.\n\ne An approach is for the sender to simply resend the current data packet when it\nreceives a garbled ACK or NAK packet.\n\ne This, however, introduces duplicate packets into the sender-to-receiver channel.\n\ne The fundamental difficulty with duplicate packets is that the receiver doesn't know\nwhether the ACK or NAK it last sent was received correctly at the sender.\n\ne Thus, it cannot know a priori whether an arriving packet contains new data or is a\nduplicate.\n\ne Asimple solution to this new problem is to add a new field to the data packet and\nhave the sender number its data packets by putting a sequence number into this\nfield.\n\ne The receiver then need only check this sequence number to determine whether or\nnot the received packet is a retransmission.\n\ne For this simple case of a stop-and-wait protocol, a 1-bit sequence number will\nsuffice, since it will allow the receiver to know whether the sender is resending the\npreviously transmitted packet (the sequence number of the received packet has the\nsame sequence number as the most recently received packet) or a new packet (the\nsequence number changes).\n\ne Since we are currently assuming a channel that does not lose packets, ACK and NAK\npackets do not themselves need to indicate the sequence number of the packet they\nare ACKing or NAKing, since the sender knows that a received ACK or NAK packet\n(whether garbled or not) was generated in response to its most recently transmitted\ndata packet.\n\nProf. Maulik Trivedi, CE Department | 2140709 — Computer Networks (CN) 10\n"
    },
    {
      "page_number": "11",
      "content": "Darshan\n\nInstitute of Engineering & Technology 3-Tra nsport Layer\n\nrdt_send(data)\n\nsndpkt = make_pkt(0, data, checksum)\nudt_send(sndpkt)\n\nrdt_rcv(revpkt) &&\n( corrupt(rcvpkt) ||\nisNAK(rcvpkt) )\n\nudt_send(sndpkt)\n\nrdt_rcv(rcvpkt)\n\n&& notcorrupt(rcevpkt) rdt_rev(revpkt)\n&& isACK(revpkt) && notcorrupt(revpkt)\nTTT && isACK(rcvpkt)\n\nA ———+!—\n\nA\n\nrdt_rev(rcvpkt) &&\n( corrupt(rcvpkt) ||\nisNAK(rcvpkt) ) rdt_send(data)\nudt_send(sndpkt) sndpkt = make_pkt(1, data, checksum)\n\nudt_send(sndpkt)\nFig 10 rdt 2.1 Sender\n\nrdt_rev(revpkt) && notcorrupt(rcvpkt)\n&& has_seqQO(rcvpkt)\n\nextract(revpkt,data)\n\ndeliver_data(data)\n\nsndpkt = make_pkt(ACK, chksum)\nudt_send(sndpkt)\n\n\\\n\\\n\nrdt_rev(revpkt) && (corrupt(revpkt) \\\nsndpkt = make_pkt(NAK, chksum) ‘\\\n\nudt_send(sndpkt) or\n\nrdt_rev(revpkt) && rdt_rev(revpkt) &&\nnot corrupt(revpkt) && ( below,\n\nnot corrupt(revpkt) &&\nhas_seq1(rcvpkt) has_seq0(rcvpkt)\nsndpkt = make_pkt(ACK, chksum)\n\nsndpkt = make_pkt(ACK, chksum)\nudt_send(sndpkt) udt_send(sndpkt)\n\nrdt_rev(revpkt) && (corrupt(revpkt)\n\nsndpkt = make_pkt(NAK, chksum)\nudt_send(sndpkt)\n\nrdt_rev(revpkt) && notcorrupt(revpkt)\n&& has_seq1(rcvpkt)\n\nextract(rcvpkt,data)\ndeliver_data(data)\n\nsndpkt = make_pkt(ACK, chksum)\nudt_send(sndpkt)\n\nFig 11 rdt 2.1 Receiver\n\ne The rdt2.1 sender and receiver FSM's each now have twice as many states as rdt2.0.\n\ne This is because the protocol state must now reflect whether the packet currently\nbeing sent (by the sender) or expected (at the receiver) should have a sequence\nnumber of 0 or 1.\n\ne Note that the actions in those states where a O-numbered packet is being sent or\nexpected are mirror images of those where a 1-numbered packet is being sent or\n\nProf. Maulik Trivedi, CE Department | 2140709 — Computer Networks (CN) 11\n"
    },
    {
      "page_number": "12",
      "content": "Darshan\n\ninsthcuey of Engineering a Teehsology 3 — Transport Layer\n\nexpected; the only differences have to do with the handling of the sequence\nnumber.\n\nProtocol rdt2.1 uses both positive and negative acknowledgements from the\nreceiver to the sender.\n\nA negative acknowledgement is sent whenever a corrupted packet, or an out of\norder packet, is received.\n\nWe can accomplish the same effect as a NAK if instead of sending a NAK, we instead\nsend an ACK for the last correctly received packet.\n\nA sender that receives two ACKs for the same packet (i.e., receives duplicate ACKs)\nknows that the receiver did not correctly receive the packet following the packet\nthat is being ACKed twice. Our NAK-free reliable data transfer protocol for a channel\nwith bit errors is rdt2.2.\n\nReliable Data Transfer over a Lossy Channel with Bit Errors: rdt3.0\n\nSuppose now that in addition to corrupting bits, the underlying channel can lose\npackets as well.\n\nTwo additional concerns must now be addressed by the protocol: how to detect\npacket loss and what to do when this occurs.\n\nThe use of checksumming, sequence numbers, ACK packets, and retransmissions -\nthe techniques already developed in rdt 2.2 - will allow us to answer the latter\nconcern. Handling the first concern will require adding a new protocol mechanism.\nThere are many possible approaches towards dealing with packet loss.\n\nSuppose that the sender transmits a data packet and either that packet, or the\nreceiver's ACK of that packet, gets lost.\n\nIn either case, no reply is forthcoming at the sender from the receiver.\n\nIf the sender is willing to wait long enough so that it is certain that a packet has been\nlost, it can simply retransmit the data packet.\n\nBut how long must the sender wait to be certain that something has been lost? It\nmust clearly wait at least as long as a round trip delay between the sender and\nreceiver (which may include buffering at intermediate routers or gateways) plus\nwhatever amount of time is needed to process a packet at the receiver.\n\nIf an ACK is not received within this time, the packet is retransmitted.\n\nNote that if a packet experiences a particularly large delay, the sender may\nretransmit the packet even though neither the data packet nor its ACK have been\nlost.\n\nThis introduces the possibility of duplicate data packets in the sender-to-receiver\nchannel.\n\nHappily, protocol rdt2.2 already has enough functionality (i.e., sequence numbers) to\nhandle the case of duplicate packets.\n\nFrom the sender's viewpoint, retransmission is a solution. The sender does not know\nwhether a data packet was lost, an ACK was lost, or if the packet or ACK was simply\noverly delayed.\n\nIn all cases, the action is the same: retransmit. In order to implement a time-based\nretransmission mechanism, a countdown timer will be needed that can interrupt the\nsender after a given amount of timer has expired.\n\nProf. Maulik Trivedi, CE Department | 2140709 — Computer Networks (CN) 12\n"
    },
    {
      "page_number": "13",
      "content": "Darshan\n\nInstitute of Engineering & Technology 3-Tra nsport Layer\n\ne The sender will thus need to be able to (i) start the timer each time a packet (either a\nfirst time packet, or a retransmission) is sent, (ii) respond to a timer interrupt (taking\nappropriate actions), and (iii) stop the timer.\n\ne The existence of sender-generated duplicate packets and packet (data, ACK) loss also\ncomplicates the sender's processing of any ACK packet it receives.\n\ne If an ACK is received, how is the sender to know if it was sent by the receiver in\nresponse to its (sender's) own most recently transmitted packet, or is a delayed ACK\nsent in response to an earlier transmission of a different data packet? The solution to\nthis dilemma is to augment the ACK packet with an acknowledgement field. When\nthe receiver generates an ACK, it will copy the sequence number of the data packet\nbeing ACK'ed into this acknowledgement field. By examining the contents of the\nacknowledgment field, the sender can determine the sequence number of the\npacket being positively acknowledged.\n\nrdt_send(data) rdt_rev(revpkt) &&\n\\. sndpkt = make_pkt(0, data, checksum) ( corrupt(revpkt) ||\n\n\\ udt_send(sndpkt) isACK(revpkt, 1) )\n\nrdt_rew(revpkt) \\_ start_timer A\nabove udt_send(sndpkt)\n\nstart_timer\n\nrdt_rev(revpkt)\n&& notcorrupt(revpkt)\n&& isACK(revpkt, 1)\n\nstop_timer\n\ntimeout\nudt_send(sne send(sndpkt) AE)\nstart_timer\n\nrdt_rev(revpkt)\n&& notcorrupt(revpkt)\n&& isACK(revpkt,0)\n\nstop_timer\n\nWait for\ncall 1 from\nabove\n\nrdt_rev(revpkt)\n\nA\nrdt_rev(revpkt) iS rdt_send(data)\n( corrupt(revpkt) || sndpkt = make_pkt(1, data, checksum)\nisACK(revpkt,0) ) udt_send(sndpkt)\nTTT start_timer\n\nA\nFig 12 rdt 3.0 Sender\n\nProf. Maulik Trivedi, CE Department | 2140709 — Computer Networks (CN) 13\n"
    },
    {
      "page_number": "14",
      "content": "Darshan\n\nInstitute of Engineering & Technology\n\n3 — Transport Layer\n\nSender Receiver\n\nsend pkt0 Pkto\n\n[\n\nrev pkto\npose send ACKO\n\n‘\n\nrev ACKO\nsend pktl u\nees rev pktl\nport send ACKl\nrev ACKl ae\nsend pkt0 ae\nrev pkt0\n\nPw send ACKO\n\na. Operation with no loss\n\nSender Receiver\n\nPk:\n\nsend pkt0 to\noe te rev pkt0O\n\naw send ACKO\nrev ACKO Pkey\nsend pktl tg rev pktl\n\nx\npce send ACKL\n(loss) X —\n\ntimeout\nresend pkt1 pkey\nPea rev pktl\npot (detect\nwail duplicate)\nrev ACK1 send ACK1\nsend pkt0 Pkto\nae rev pkt0\nsend ACKO\n\n\\.\n\nc. Lost ACK\n\nSender\n\nsend pkt0 Pkto\n\n[\n\npad\nrev ACKO Pky\nsend pktl —. (loss)\ntimeout\n\nresend pktl\n\nrev ACKL\nsend pkt0\n\n\\\n\nb. Lost packet\n\nSender\n\nsend pkt0 ko\n\n;\n\n9\n\nrev ACKO\nsend pktl [ ty\n\n[\\\n\ntimeout t? 4\nresend pktl S\nrev ACK1\nsend pkt0 : Pkto\n\nNy\n\nrev ACKL\ndo nothing\n\n°\n\nyy.\n\\\n\nd. Premature timeout\n\nFig. 13 Operation of rdt3.0, the alternating-bit protocol\n\nProtocol pipelining\n\nReceiver\n\nrev pkto\nsend ACKO\n\nrev pktl\nsend ACKl\n\nrev pktd\nsend ACKO\n\nReceiver\n\nrev pkt0\nsend ACKO\n\nrev pktl\nsend ACKl\n\nrev pkt 1\n(detect duplicate)\nsend ACK1\n\nrev pkt0\nsend ACKO\n\ne Protocol pipelining is a technique in which multiple requests are written out to a\nsingle socket without waiting for the corresponding responses (acknowledged).\ne Pipelining can be used in various application layer network protocols, like HTTP/1.1,\n\nSMTP and FTP.\n\ne Range of sequence numbers must be increased.\ne Data or Packet should be buffered at sender and/or receiver.\n\nTrivedi, CE Department | 2140709 — Computer Networks (CN)\n\n14\n"
    },
    {
      "page_number": "15",
      "content": "Darshan\n\nIaieieaed of Engineering a Tachactogy 3 — Transport Layer\n\nno pipelining pipelining\nclient server client server\nopen—-_ open—e-\n1 £\n= a closeq*\ni |\nnein ’ ’ '\n\nTwo generic forms of pipelined protocols are\n1. Go-Back-N\n2. Selective repeat\n\nGo-Back-N\n\nGo-Back-N ARQ is a specific instance of the automatic repeat request (ARQ) protocol,\nin which the sending process continues to send a number of frames specified by a\nwindow size even without receiving an acknowledgement (ACK) packet from the\nreceiver.\n\nThe receiver process keeps track of the sequence number of the next frame it\nexpects to receive, and sends that number with every ACK it sends.\n\nThe receiver will discard any frame that does not have the exact sequence number it\nexpects (either a duplicate frame it already acknowledged or an out-of-order frame\nit expects to receive later) and will resend an ACK for the last correct in-order frame.\nOnce the sender has sent all of the frames in its window, it will detect that all of the\nframes since the first lost frame are outstanding, and will go back to the sequence\nnumber of the last ACK it received from the receiver process and fill its window\nstarting with that frame and continue the process over again.\n\nGo-Back-N ARQ is a more efficient use of a connection than Stop-and-wait ARQ,\nsince unlike waiting for an acknowledgement for each packet; the connection is still\nbeing utilized as packets are being sent.\n\nHowever, this method also results in sending frames multiple times — if any frame\nwas lost or damaged or the ACK acknowledging them was lost or damaged then that\nframe and all following frames in the window (even if they were received without\nerror) will be re-sent. To avoid this, Selective Repeat ARQ can be used.\n\nHow does Go-Back-N ARQ protocol works:\n\nConsider a scenario given in fig 14 there are four frames 0,1,2,3 respectively. Now as\nsending window size is 3 it will send frame 0, 1 and 2 at atime.\n\nProf. Maulik Trivedi, CE Department | 2140709 — Computer Networks (CN) 15\n"
    },
    {
      "page_number": "16",
      "content": "Darshan\n\nInstitute of Engineering & Technology 3 -— Transport Layer\n\nData (0)\n\nData (1)\n\nData (2) ACK (0)\nACK (1)\nNAK (2)\n\nData (3)\n\nData (0)\n\nData (2)\n\nData (3)\nACK (2)\n\nTime\n\nFig. 14 Go-Back-N Protocol\nAt receiver side frame 0 arrives it sends ACK for that.\nNow at sender side window shift at frame 3 and it sends frame no 3.\nAt receiver side frame 1 arrives it sends ACK for that.\nNow at sender side window shift at frame 4 and it sends frame no 4.\nNow receiver detects frame 2 is missing or lost. It will send NAK for that.\nSender receives NAK at this point sending window is pointing towards frame 2, 3 and\n4 so send will resend frame 2, 3 and 4.\n\nSelective repeat\n\nSelective Repeat attempts to retransmit only those packets that are actually lost due\nto errors.\n\nReceiver must be able to accept packets out of order\n\nSince receiver must release packets to higher layer in order, the receiver must be\nable to buffer some packets\n\nThe receiver acknowledges every good packet, packets that are not ACKed before a\ntime-out are assumed lost or in error.\n\nNotice that this approach must be used to be sure that every packet is eventually\nreceived.\n\nAn explicit NAK (selective reject) can request retransmission of just one packet.\n\nThis approach can speed up the retransmission but is not strictly needed.\n\nProf. Maulik Trivedi, CE Department | 2140709 — Computer Networks (CN) 16\n"
    },
    {
      "page_number": "17",
      "content": "PD Darshan\n\n[aR of Engineurtega Techealogy 3 — Transport Layer\n\nSender Receiver\n\npktO sent\n0123456789\n\npktO revd, delivered, ACKO sent\n0123456789\n\npktl sent\n0123456789\n\npktl revd, delivered, ACK1 sent\n01123456789\n\nr— pkt2 sent\n0123456789\n\npkt3 sent, window full\n0123456789\n\npkt3 rcevd, buffered, ACK3 sent\nACKO revd, pkt4 sent 0123456789\n\n0123456789\n\npkt4 rcvd, buffered, ACK4 sent\n0123456789\n\nACK1 revd, pkt5 sent\n0123456789\n\npkt5 revd; buffered, ACK5S sent\n0123456789\n\n\\— pkt2 TIMEOUT, pkt2\nresent\n\n0123456789\npkt2 revd, pkt2,pkt3,pkt4,pkt5\ndelivered, ACK2 sent\n0123456789\n\nACK3 revd, nothing sent\n0123456789\n\nv v\n\nFig. 15 Selective Repeat\nTCP segment structure\n\n22 bits\n\nSource port # Dest port #\nSequence number\nAcknowledgment number\n\nInternet checksum Urgent data pointer\n\nFig. 16 TCP segment structure\ne The unit of transmission in TCP is called segments.\n\ne The header includes source and destination port numbers, which are used for\nmultiplexing/demultiplexing data from/to upper-layer applications.\n\nProf. Maulik Trivedi, CE Department | 2140709 — Computer Networks (CN) 17\n"
    },
    {
      "page_number": "18",
      "content": "Darshan\n\nIaieieaed of Engineering a Tachactogy 3 — Transport Layer\n\nThe 32-bit sequence number field and the 32-bit acknowledgment number field are\nused by the TCP sender and receiver in implementing a reliable data transfer service.\nThe sequence number for a segment is the byte-stream number of the first byte in\nthe segment.\n\nThe acknowledgment number is the sequence number of the next byte a Host is\nexpecting from another Host.\n\nThe 4-bit header length field specifies the length of the TCP header in 32-bit words.\nThe TCP header can be of variable length due to the TCP options field.\n\nThe 16-bit receive window field is used for flow control. It is used to indicate the\nnumber of bytes that a receiver is willing to accept.\n\nThe 16-bit checksum field is used for error checking of the header and data.\n\nUnused 6 bits are reserved for future use and should be sent to zero.\n\nUrgent Pointer is used in combining with the URG control bit for priority data\ntransfer. This field contains the sequence number of the last byte of urgent data.\nData: The bytes of data being sent in the segment.\n\nURG (1 bit): indicates that the Urgent pointer field is significant.\n\nACK (1 bit): indicates that the Acknowledgment field is significant.\n\nPSH (1 bit): Push function. Asks to push the buffered data to the receiving\napplication.\n\nRST (1 bit): Reset the connection.\n\nSYN (1 bit): Synchronize sequence numbers. Only the first packet sent from each end\nshould have this flag set. Some other flags and fields change meaning based on this\nflag, and some are only valid for when it is set, and others when it is clear.\n\nFIN (1 bit): No more data from sender.\n\nFlow Control\n\nIn data communications, flow control is the process of managing the rate of data\ntransmission between two nodes to prevent a fast sender from overwhelming a slow\nreceiver.\nIt prevent receiver from becoming overloaded.\nReceiver advertises a window rwnd with each acknowledgement\nWindow\n> closed (by sender) when data is sent and ack’d\n> opened (by receiver) when data is read\nThe size of this window can be the performance limit (e.g. on a LAN).\n\nCongestion Control\n\nWhen a connection is established, a suitable window size has to be chosen.\n\nThe receiver can specify a window based on its buffer size.\n\nIf the sender sticks to this window size, problems will not occur due to buffer\noverflow at the receiving end, but they may still occur due to internal congestion\nwithin the network.\n\nIn Figure 17 (a), we see a thick pipe leading to a small-capacity receiver.\n\nAs long as the sender does not send more water than the bucket can contain, no\nwater will be lost.\n\nProf. Maulik Trivedi, CE Department | 2140709 — Computer Networks (CN) 18\n"
    },
    {
      "page_number": "19",
      "content": "Darshan\n\nInstitute of Engineering & Technology 3 -— Transport Layer\n\ne In Figure 17 (b), the limiting factor is not the bucket capacity, but the internal\ncarrying capacity of the network.\n\nbe\n\nTransmission\nrate adjustment\n\nTransmission\n\nnetwork Internal\n\ncongestion\n\nSmall-capacity Large-capacity\nreceiver ~~ receiver\n\n(a) (b)\nFig. 17 TCP segment structure\n\ne Figure 17: (a) a fast network feeding a low capacity receiver. Figure 17: (b) A slow\nnetwork feeding a high-capacity receiver.\n\ne If too much water comes in too fast, it will back up and some will be lost (in this case\nby overflowing the funnel).\n\ne Each sender maintains two windows: the window the receiver has granted and a\nsecond window, the congestion window.\n\ne ach reflects the number of bytes the sender may transmit.\n\ne The number of bytes that may be sent is the minimum of the two windows.\n\ne Thus, the effective window is the minimum of what the sender thinks is all right and\nwhat the receiver thinks is all right.\n\ne When a connection is established, the sender initializes the congestion window to\nthe size of the maximum segment in use on the connection.\n\ne It then sends one maximum segment.\n\ne If this segment is acknowledged before the timer goes off, it adds one segment's\nworth of bytes to the congestion window to make it two maximum size segments\nand sends two segments.\n\ne As each of these segments is acknowledged, the congestion window is increased by\none maximum segment size.\n\ne When the congestion window is n segments, if all n are acknowledged on time, the\ncongestion window is increased by the byte count corresponding to n segments.\n\nTCP Slow Start\n\ne Slow-start is part of the congestion control strategy used by TCP, the data\n\ntransmission protocol used by many Internet applications.\n\nProf. Maulik Trivedi, CE Department | 2140709 — Computer Networks (CN) 19\n"
    },
    {
      "page_number": "20",
      "content": "@\nC Darshan 3 — Transport Layer\n\nInstitute of Engineering & Technology\n\ne Slow-start is used in conjunction with other algorithms to avoid sending more data\nthan the network is capable of transmitting to avoid causing network congestion.\n\nf segments\n\nFig. 18 TCP Slow start\n\ne Slow-start begins initially with a congestion window Size (cwnd) of 1, 2 or 10.\n\ne The value of the Congestion Window will be increased with each acknowledgement\n(ACK) received, effectively doubling the window size each round trip time (\"although\nit is not exactly exponential because the receiver may delay its ACKs, typically\nsending one ACK for every two segments that it receives).\n\ne The transmission rate will be increased with slow-start algorithm until either a loss is\ndetected, or the receiver's advertised window (rwnd) is the limiting factor, or the\nslow start threshold (ssthresh) is reached.\n\ne If a loss event occurs, TCP assumes that it is due to network congestion and takes\nsteps to reduce the offered load on the network.\n\ne Once ssthresh is reached, TCP changes from slow-start algorithm to the linear\ngrowth (congestion avoidance) algorithm. At this point, the window is increased by 1\nsegment for each RTT.\n\nProf. Maulik Trivedi, CE Department | 2140709 — Computer Networks (CN) 20\n"
    }
  ]
}