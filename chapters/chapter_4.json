{
  "chapter_name": "4: - Network Layer",
  "pages": [
    {
      "page_number": "1",
      "content": "D D ar shan 4 —- Network Layer\n\nInstitute of Engineering & Technology\n\nRouting and Forwarding\n\nFigure 1 shows a simple network with two hosts, H1 and H2, and several routers on the path\nbetween H1 and H2.\n\nSuppose that H1 is sending information to H2, and consider the role of the network layer in\nthese hosts and in the intervening routers.\n\nThe network layer in H1 takes segments from the transport layer in H1, encapsulates each\nsegment into a datagram (that is, a network-layer packet), and then sends the datagrams to its\nnearby router, R1.\n\nAt the receiving host, H2, the network layer receives the datagrams from its nearby router R2,\nextracts the transport-layer segments, and delivers the segments up to the transport layer at\nH2.\n\nThe primary role of the routers is to forward datagrams from input links to output links.\n\nNational or\nie . Global ISP\n\nEnd system H1\n\nApplication ]\nTransport\n\nData link\nPhysical\n\nPhysical\n\nRouter R2\n\nData link\n\nPhysical\n\nEnd system H2\n\nApplication\n\n| Went |\n\nEnterprise Network\n\nPhysical\n\nFig. 1 Network Layer\n\nProf. Maulik Trivedi, CE Department | 2140709 — Computer Networks (CN) 1\n"
    },
    {
      "page_number": "2",
      "content": "Darshan\n\nInstitute of Engineering & Technology 4- Network Layer\n\ne The role of the network layer is thus deceptively simple—to move packets from a sending host\nto a receiving host. To do so, two important network-layer functions can be identified:\n\n>\n\n>\n\nForwarding: When a packet arrives at a router’s input link, the router must move the\npacket to the appropriate output link.\n\nFor example, a packet arriving from Host H1 to Router R1 must be forwarded to the next\nrouter ona path to H2.\n\nRouting: Routing is the process of selecting best paths in a network.\n\nThe network layer must determine the route or path taken by packets as they flow from\na sender to a receiver.\n\nThe algorithms that calculate these paths are referred to as routing algorithms. A\nrouting algorithm would determine, for example, the path along which packets flow\nfrom H1 to H2.\n\ne Every router has a forwarding table. A router forwards a packet by examining the value of a\nfield in the arriving packet’s header, and then using this header value to index into the router’s\nforwarding table.\n\ne The value stored in the forwarding table entry for that header indicates the router’s outgoing\nlink interface to which that packet is to be forwarded.\n\ne Depending on the network-layer protocol, the header value could be the destination address of\nthe packet or an indication of the connection to which the packet belongs.\n\nNetwork service model\ne Services provided by network layer for individual datagrams\n\n1.\n\nGuaranteed delivery: This service guarantees that the packet will eventually arrive at its\ndestination.\n\nGuaranteed delivery with bounded delay: This service not only guarantees delivery of\nthe packet, but delivery within a specified host-to-host delay bound (for example, within\n100 msec).\n\ne Services provided by network layer for a flow of datagrams\n\n3.\n\n4.\n\nIn-order packet delivery: This service guarantees that packets arrive at the destination\nin the order that they were sent.\n\nGuaranteed minimal bandwidth: This network-layer service emulates the behaviour of\na transmission link of a specified bit rate (for example, 1 Mbps) between sending and\nreceiving hosts. As long as the sending host transmits bits at a rate below the specified\nbit rate, then no packet is lost.\n\nGuaranteed maximum jitter: This service guarantees that the amount of time between\nthe transmission of two successive packets at the sender is equal to the amount of time\nbetween their receipt at the.\n\nSecurity services: Using a secret session key known only by a source and destination\nhost, the network layer in the source host could encrypt the payloads of all datagrams\nbeing sent to the destination host. The network layer in the destination host would then\nbe responsible for decrypting the payloads. With such a service, confidentiality would be\nprovided to all transport-layer segments (TCP and UDP) between the source and\ndestination hosts.\n\nProf. Maulik Trivedi, CE Department | 2140709 — Computer Networks (CN) 2\n"
    },
    {
      "page_number": "3",
      "content": "D Darshan\n\nInstitute of Engineering & Technology 4- Network Layer\n\nVirtual and Datagram networks\n\nVirtual Circuit Switching (Connection Oriented Service)\n\ne AVC consists of\n1. a path (that is, a series of links and routers) between the source and destination hosts\n2. VC numbers, one number for each link along the path\n3. Entries in the forwarding table in each router along the path.\n\ne A packet belonging to a virtual circuit will carry a VC number in its header. Because a virtual circuit\nmay have a different VC number on each link, each intervening router must replace the VC number\nof each traversing packet with a new VC number.\n\ne The new VC number is obtained from the forwarding table.\n\n4\n\nVC number\n\ng . interface\nforwarding table in number\n\nnorthwest router:\n\nIncoming interface | Incoming VC # | Outgoing interface | Outgoing VC #\n\n1 12 3 22\n2 63 1 18\n3 7 2 17\n1 97 3 87\n\nFig. 2 A simple virtual circuit network\n\ne The numbers next to the links of R1 in above figure are the link interface numbers.\n\ne Suppose now that Host A requests that the network establishes a VC between itself and Host B.\n\ne Suppose also that the network chooses the path A-R1-R2-B and assigns VC numbers 12, 22 and 32 to\nthe three links in this path for this virtual circuit.\n\ne In this case, when a packet in this VC leaves Host A, the value in the VC number field in the packet\nheader is 12; when it leaves R1, the value is 22; and when it leaves R2, the value is 32.\n\ne How does the router determine the replacement VC number for a packet traversing the router? For\na VC network, each router’s forwarding table includes VC number translation; for example, the\nforwarding table in R1 might look something like above fig. 2\n\ne Whenever a new VC is established across a router, an entry is added to the forwarding table.\n\ne Similarly, whenever a VC terminates, the appropriate entries in each table along its path are\nremoved.\n\ne Apath from the source router to the destination router must be established before any data packets\ncan be sent.\n\ne This connection is called a VC (virtual circuit), and the subnet is called a virtual-circuit subnet.\n\nProf. Maulik Trivedi, CE Department | 2140709 — Computer Networks (CN) 3\n"
    },
    {
      "page_number": "4",
      "content": "Darshan\n\nInstitute of Engineering & Technology 4 — Network Layer\n\ne When aconnection is established, a route from the source machine to the destination machine is\nchosen as part of the connection setup and stored in tables inside the routers.\n\ne That route is used for all traffic flowing over the connection, exactly the same way that the\ntelephone system works.\n\n| Application Application\n/4. Call connected 3. Accept call\n\nTransport Transport\n\n5. Data flow 6. Receive —\n\nData link\n\nPhysical\n\n1. Initiate call\n\nData link\nPhysical\n\n2. Incoming call\n\nFig. 3 Virtual-Circuit Setup\ne There are three identifiable phases in a virtual circuit:\n1. VCsetup:\n= During the setup phase, the sending transport layer contacts the network layer,\nspecifies the receiver’s address, and waits for the network to set up the VC.\n= The network layer determines the path between sender and receiver, that is, the\nseries of links and routers through which all packets of the VC will travel.\n= The network layer also determines the VC number for each link along the path.\n= Finally, the network layer adds an entry in the forwarding table in each router along\nthe path. During VC setup, the network layer may also reserve resources (for\nexample, bandwidth) along the path of the VC.\n2. Data transfer:\n= As shown in Figure 3, once the VC has been established, packets can begin to flow\nalong the VC.\n3. VC teardown:\n= This is initiated when the sender (or receiver) informs the network layer of its\ndesire to terminate the VC.\n= The network layer will then typically inform the end system on the other side of the\nnetwork of the call termination and update the forwarding tables in each of the\npacket routers on the path to indicate that the VC no longer exists.\nDatagram Network (Connection-Less Service)\ne In connection less service, packets are injected into the subnet individually and routed\nindependently of each other.\ne No advance setup is needed. In this context, the packets are frequently called datagrams (in analogy\nwith telegrams) and the subnet is called a datagram subnet.\ne Suppose that the process P1 in Figure 4 has a long message for P2. It hands the message to the\ntransport layer with instructions to deliver it to process P2 on host H2.\n\nProf. Maulik Trivedi, CE Department | 2140709 — Computer Networks (CN) 4\n\n"
    },
    {
      "page_number": null,
      "content": "B\n\nDarshan\n\nInstitute of Engineering & Technology\n\n4 —- Network Layer\n\ne Let us assume that the message is four times longer than the maximum packet size, so the network\nlayer has to break it into four packets, 1, 2, 3, and 4 and sends each of them in turn to router A using\nsome point-to-point protocol, for example, PPP.\n\nApplication Application\nTransport Transport\n1. Send 2. Receive\n——— Data link data Data link _——\niz) Physical Physical a\nSs —_——_\n\nFig. 4 Datagram Network\n\ne Atthis point the carrier takes over. Every router has an internal table telling it where to send packets\nfor each possible destination. Each table entry is a pair consisting of a destination and the outgoing\nline to use for that destination.\n\ne Only directly-connected lines can be used.\n\nDatagram Network vs. Virtual Circuit Network\n\naddress\n\nIssue Datagram Virtual Circuit\nConnection Setup | None Required\nAddressing Packet contains full source and destination | Packet contains short virtual circuit\n\nnumber identifier.\n\nState Information\n\nNone other than\ndestination network\n\nrouter table containing\n\nEach virtual circuit number entered\nto table on setup, used for routing.\n\nRouting\n\nPackets routed independently\n\nRoute established at setup, all\n\npackets follow same route.\n\nEffect of Router\nFailure\n\nOnly on packets lost during crash\n\nAll virtual circuits passing through\nfailed router terminated.\n\nCongestion\nControl\n\nDifficult since all packets routed independently\nrouter resource requirements can vary.\n\nSimple by pre-allocating enough\nbuffers to each virtual circuit at\nsetup, since maximum number of\ncircuits fixed.\n\nRouter architecture\ne Routers have four components:\n1. Input ports\n2. Switching fabric\n3. Output ports\n4. Routing processor\n\nProf. Maulik Trivedi, CE Department\n\n| 2140709 — Computer Networks (CN)\n\n"
    },
    {
      "page_number": "6",
      "content": "Darshan\n\nInstitute of Engineering & Technology 4 — Network Layer\n\nRouting\n\n; processor\nRouting, management\n\ncontrol plane (software)\nForwarding\ndata plane (hardware)\n\nInput port Output port\nam me, a 2.\nSwitch\nInput port Output port\n\nFig. 5 Router architecture\n\nInput ports\n\ne An input port performs several key functions.\n\ne It performs the physical layer function of terminating an incoming physical link at a router; this is\nshown in the leftmost box of the input port and the rightmost box of the output port in Figure 5.\n\ne An input port also performs link-layer functions needed to interoperate with the link layer at the\nother side of the incoming link; this is represented by the middle boxes in the input and output\nports.\n\ne Perhaps most crucially, the lookup function is also performed at the input port; this will occur in the\nrightmost box of the input port. It is here that the forwarding table is consulted to determine the\nrouter output port to which an arriving packet will be forwarded via the switching fabric.\n\ne Control packets (for example, packets carrying routing protocol information) are forwarded from an\ninput port to the routing processor.\n\nSwitching fabric\n\ne The switching fabric connects the router’s input ports to its output ports.\n\ne This switching fabric is completely contained within the router - a network inside of a network\nrouter!\n\nOutput ports\n\ne An output port stores packets received from the switching fabric and transmits these packets on the\noutgoing link by performing the necessary link-layer and physical-layer functions.\n\ne When alink is bidirectional (that is, carries traffic in both directions), an output port will typically be\npaired with the input port for that link on the same line card.\n\nRouting processor\n\ne The routing processor executes the routing protocols, maintains routing tables and attached link\nstate information and computes the forwarding table for the router.\n\ne It also performs the network management functions.\n\nProf. Maulik Trivedi, CE Department | 2140709 — Computer Networks (CN) 6\n"
    },
    {
      "page_number": "7",
      "content": "Darshan\n\nInstitute of Engineering & Technology 4 — Network Layer\n\nTypes of switching fabrics\n\nThree types of switching fabrics\n1. Switching via memory\n2. Switching via a bus\n3. Switching via an interconnection network\n\nSwitching via memory\n\nThe simplest, earliest routers were traditional computers, with switching between input and output\nports being done under direct control of the CPU (routing processor).\n\nAn input port with an arriving packet first signalled the routing processor via an interrupt. The\npacket was then copied from the input port into processor memory.\n\nThe routing processor then extracted the destination address from the header, looked up the\nappropriate output port in the forwarding table, and copied the packet to the output port’s buffers.\nIn this scenario, if the memory bandwidth is such that B packets per second can be written into, or\nread from, memory, then the overall forwarding throughput must be less than B/2.\n\nNote also that two packets cannot be forwarded at the same time, even if they have different\ndestination ports, since only one memory read/write over the shared system bus can be done at a\ntime.\n\nMemory Crossbar\n\n>I\n\nKey:\nCO ft] input port f=) (10 output port\n\nFig. 6 Three switching techniques\n\nSwitching via a bus\n\nIn this approach, an input port transfers a packet directly to the output port over a shared bus,\nwithout intervention by the routing processor.\n\nProf. Maulik Trivedi, CE Department | 2140709 — Computer Networks (CN) 7\n"
    },
    {
      "page_number": "8",
      "content": "Darshan\n\nInstitute of Engineering & Technology 4- Network Layer\n\nThis is typically done by having the input port pre-pend a switch-internal label (header) to the packet\nindicating the local output port to which this packet is being transferred and transmitting the packet\nonto the bus.\n\nThe packet is received by all output ports, but only the port that matches the label will keep the\npacket.\n\nThe label is then removed at the output port, as this label is only used within the switch to cross the\nbus.\n\nIf multiple packets arrive to the router at the same time, each at a different input port, all but one\nmust wait since only one packet can cross the bus at a time. Because every packet must cross the\nsingle bus, the switching speed of the router is limited to the bus speed.\n\nSwitching via an interconnection network\n\nOne way to overcome the bandwidth limitation of a single, shared bus is to use a more sophisticated\ninterconnection network, such as those that have been used in the past to interconnect processors\nin a multiprocessor computer architecture.\n\nA crossbar switch is an interconnection network consisting of 2N buses that connect N input ports to\nN output ports, as shown in Figure 6.\n\nEach vertical bus intersects each horizontal bus at a crosspoint, which can be opened or closed at\nany time by the switch fabric controller (whose logic is part of the switching fabric itself).\n\nWhen a packet arrives from port A and needs to be forwarded to port Y, the switch controller closes\nthe crosspoint at the intersection of busses A and Y, and port A then sends the packet onto its bus,\nwhich is picked up (only) by bus Y.\n\nNote that a packet from port B can be forwarded to port X at the same time, since the A-to-Y and B-\nto-X packets use different input and output busses.\n\nThus, unlike the previous two switching approaches, crossbar networks are capable of forwarding\nmultiple packets in parallel.\n\nHowever, if two packets from two different input ports are destined to the same output port, then\none will have to wait at the input, since only one packet can be sent over any given bus at a time.\n\nIPv4 datagram format\n\nVersion number: These 4 bits specify the IP protocol version of the datagram. It determines how to\ninterpret the header. Currently the only permitted values are 4 (0100) or 6 (0110).\n\nHeader length: Specifies the length of the IP header, in 32-bit words.\n\nType of service: The type of service (TOS) bits were included in the IPv4 header to allow different\ntypes of IP datagrams (for example, datagrams particularly requiring low delay, high throughput, or\nreliability) to be distinguished from each other.\n\nDatagram length: This is the total length of the IP datagram (header plus data), measured in bytes.\nIdentifier: Uniquely identifies the datagram. It is incremented by 1 each time a datagram is sent. All\nfragments of a datagram contain the same identification value. This allows the destination host to\ndetermine which fragment belongs to which datagram.\n\nFlags: In order for the destination host to be absolutely sure it has received the last fragment of the\noriginal datagram, the last fragment has a flag bit set to 0, whereas all the other fragments have this\nflag bit set to 1.\n\nFragmentation offset: When fragmentation of a message occurs, this field specifies the offset, or\nposition, in the overall message where the data in this fragment goes. It is specified in units of 8\nbytes (64 bits).\n\nProf. Maulik Trivedi, CE Department | 2140709 — Computer Networks (CN) 8\n"
    },
    {
      "page_number": "9",
      "content": "Darshan\n\n[niahevtd of Engineering @ioehiclésy 4—- Network Layer\n\n32 bits\n|\nI\nHead\nVersion | anyth Type of service Datagram length (bytes)\n16-bit Identifier Flags 13-bit Fragmentation offset\nTime-to-live Uppelarss Header checksum\n\nprotocol\n\n32-bit Source IP address\n32-bit Destination IP address\nOptions (if any)\nData\n\nFig. 7 IPv4 datagram format\nTime-to-live: Specifies how long the datagram is allowed to “live” on the network. Each router\ndecrements the value of the TTL field (reduces it by one) prior to transmitting it. If the TTL field\ndrops to zero, the datagram is assumed to have taken too long a route and is discarded.\nProtocol: This field is used only when an IP datagram reaches its final destination. The value of this\nfield indicates the specific transport-layer protocol to which the data portion of this IP datagram\nshould be passed. For example, a value of 6 indicates that the data portion is passed to TCP, while a\nvalue of 17 indicates that the data is passed to UDP.\nHeader checksum: The header checksum aids a router in detecting bit errors in a received IP\ndatagram.\nSource and destination IP addresses: When a source creates a datagram, it inserts its IP address\ninto the source IP address field and inserts the address of the ultimate destination into the\ndestination IP address field.\nOptions: The options fields allow an IP header to be extended.\nData (payload): The data to be transmitted in the datagram, either an entire higher-layer message\nor a fragment of one.\n\nIP addressing: Introduction\n\nIP address: It is 32-bit identifier for host, router interface\nInterface: It is a connection between host/router and physical link.\n> Arouter’s typically have multiple interfaces\n> Ahost typically has one or two interfaces\nThere is an IP addresses associated with each interface.\nSubnets: To determine the subnets, detach each interface from its host or router, creating islands of\nisolated networks, with interfaces terminating the end points of the isolated networks. Each of\nthese isolated networks is called a subnet.\nSubnet part: high order bits defines subnet\nHost part: low order bits defines host.\n\nProf. Maulik Trivedi, CE Department | 2140709 — Computer Networks (CN) 9\n"
    },
    {
      "page_number": "10",
      "content": "©) Darshan\n\nInstitute of Engineering & Technology 4- Network Layer\n\n223.1.1.1\n22311A B28 223.1.2.1\nP~223.1.3.27\n223.1.1.2\n223.1.2.2\n2231.13\n\n223.1.3.1 223.1.3.2\n\nFig. 8 Interface addresses and subnets\n\nClassification of IP Addresses (Classful Addressing)\n\nClass: A\n7 Bit 24 Bit\nFix Network ID ~Y Host ID\nClass: B\nce Ne 14 Bit 16 Bit Dy)\nNetwork IDV Host IDV\nClass: C\nFix 21 Bit 8 Bit J\nNetwork ID Vv ~Y~ Host ID\nClass: D\nEE A\nFix & DD\nClass: E ~Y Multicast address\nFix ~~” Reserved address\n\nCIDR (Classless Inter-Domain Routing)\n\ne Originally, IP addresses were assigned in four major address classes, A through D.\n\nProf. Maulik Trivedi, CE Department | 2140709 — Computer Networks (CN) 10\n"
    },
    {
      "page_number": "11",
      "content": "Darshan\n\nInstitute of Engineering & Technology\n\nEach of these classes allocates one portion of the 32-bit IP address format to identify a network\ngateway - the first 8 bits for class A, the first 16 for class B, and the first 24 for class C. The remainder\nidentify hosts on that network.\n\ne More than 16 million in class A, 65,535 in class B and 254 in class C. (Class D addresses identify\nmulticast domains.)\n\ne To illustrate the problems with the class system, consider that one of the most commonly used\nclasses was Class B.\n\ne An organization that needed more than 254 host machines (500 hosts) would often get a Class B\nlicense, even though it would have far fewer than 65,534 hosts.\n\ne This resulted in most of the block of addresses allocated going unused.\n\ne CIDR reduced the problem of wasted address space by providing a new and more flexible way to\nspecify network addresses in routers.\n\ne Asingle IP address can be used to designate many unique IP addresses with CIDR.\n\ne A CIDR IP address looks like a normal IP address except that it ends with a slash followed by a\nnumber, called the IP network prefix. CIDR addresses reduce the size of routing tables and make\nmore IP addresses available within organizations.\n\nsubnet\npart part\n11001000 00010111 00010000 00000000\n\n200.23.16.0/23\n\n4 —- Network Layer\n\nhost\n\n_—_—_—_—_\n\nIP Addressing Summary:\n\nSize Default subnet\n\nSi:\nLeading of network ze Number Addresses _ Total addresses Start mask in dot- CIDR\nClass \" of rest . End address . \"\nbits number bit ,.. ,. of networks | per network in class address decimal notation\n- bit field 7\nfield notation\n16,777,216 2,147,483,648\nClass A ) 8 24 128 (27) (224) (231) 0.0.0.0 127.255.255.255 255.0.0.0 /8\n16,384 65,536 1,073,741,824\nClass B 10 16 16 (a8) (26) (230) 128.0.0.0 191.255.255.255 | 255.255.0.0  /16\nClass C 110 24 8 ee 256 (28) = 192.0.0.0 223.255.255.255 | 255.255.255.0 124\nClass D not not not not 268,435,456 7 not\n(multicast) 1110 defined defined defined defined (228) EDOOO | BOARS || mebeeiinss) defined\nClass E not not not not 268,435,456 ' not\n1111 oe, 240.0.0.0 255.255.255.255 st defined\nreserve lefine jefine lefine lefine not detine! jefine\nd) defined defined defined defined pe defined\n\nDHCP: Dynamic Host Configuration Protocol\n\ne Dynamic Host Configuration Protocol is a protocol for assigning dynamic IP addresses to devices ona\n\nnetwork.\n\nProf. Maulik Trivedi, CE Department\n\n| 2140709 — Computer Networks (CN)\n\n11\n"
    },
    {
      "page_number": "12",
      "content": "Darshan\n\nInstitute of Engineering & Technology\n\n223.1.1.0/24\n\n223.1.3.1\n\nDHCP\nserver\n\n‘|\n\n223.1.2.0/24\n\n1.3.2\n\n223.1.3.0/24\nFig. 9 DHCP client-server scenario\n\nDHCP server: 223.1.2.5 DHCP discover\n\nBroadcast: is there a\nDHCP server out there?\n\n4—- Network Layer\n\narriving DHCP\nclient needs\naddress in this\nnetwork\n\narriving\nclient\n\nDHCP offer\n\nserver! Here's an IP\naddress you can use\n\nDHCP request\n\nBroadcast: I’m a DHCP\n\nBroadcast: OK. I'll take |\n\nthat IP address!\n\nFig. 10 DHCP client-server interaction\n\nDHCP server discovery\n\nDHCP ACK\n\nBroadcast: OK. You've\n\ngot that IP address!\n\ne = The first task of a newly arriving host is to find a DHCP server with which to interact.\n\ne This is done using a DHCP discover message, which a client sends within a UDP packet to port 67.\n\nProf. Maulik Trivedi, CE Department\n\n| 2140709 — Computer Networks (CN)\n\nWith dynamic addressing, a device can have a different IP address every time it connects to the\n\nnetwork.\nIn some systems, the device's IP address can even change while it is still connected. It allows reuse\n\nof addresses (only hold address while connected “on”). It also support mobile users who want to\njoin network.\n\n12\n"
    },
    {
      "page_number": "13",
      "content": "Darshan\n\nInstitute of Engineering & Technology 4- Network Layer\n\nThe UDP packet is encapsulated in an IP datagram. But to whom should this datagram be sent? The\nhost doesn’t even know the IP address of the network to which it is attaching.\n\nGiven this, the DHCP client creates an IP datagram containing its DHCP discover message along with\nthe broadcast destination IP address of 255.255.255.255 and a “this host” source IP address of\n0.0.0.0.\n\nThe DHCP client passes the IP datagram to the link layer, which then broadcasts this frame to all\nnodes attached to the subnet.\n\nDHCP server offer(s)\n\nA DHCP server receiving a DHCP discover message responds to the client with a DHCP offer message\nthat is broadcast to all nodes on the subnet, again using the IP broadcast address of\n255.255.255.255.\n\nSince several DHCP servers can be present on the subnet, the client may find itself in the enviable\nposition of being able to choose from among several offers.\n\nEach server offer message contains the transaction ID of the received discover message, the\nproposed IP address for the client, the network mask, and an IP address lease time - the amount of\ntime for which the IP address will be valid.\n\nDHCP request\n\nThe newly arriving client will choose from among one or more server offers and respond to its\nselected offer with a DHCP request message, echoing back the configuration parameters.\n\nDHCP ACK\n\nThe server responds to the DHCP request message with a DHCP ACK message, confirming the\nrequested parameters.\n\nNetwork Address Translation (NAT)\n\nThe Internet has grown larger than anyone ever imagined it could be.\n\nAlthough the exact size is unknown, the current estimate is that there are about 100 million hosts\nand more than 350 million users actively on the Internet.\n\nIn fact, the rate of growth has been such that the Internet is effectively doubling in size each year.\nSo what does the size of the Internet have to do with NAT? For a computer to communicate with\nother computers and Web servers on the Internet, it must have an IP address.\n\nAn IP address is a unique 32-bit number that identifies the location of your computer on a network.\nWhen IP addressing first came out, everyone thought that there were sufficiently of addresses to\ncover any need. Theoretically, you could have 4,294,967,296 unique addresses (232). The actual\nnumber of available addresses is smaller (somewhere between 3.2 and 3.3 billion) because of the\nway that the addresses are separated into classes, and because some addresses are set aside for\nmulticasting, testing or other special uses.\n\nWith the explosion of the Internet and the increase in home networks and business networks, the\nnumber of available IP addresses is simply not enough.\n\nThe obvious solution is to redesign the address format to allow for more possible addresses. This is\nbeing developed (called IPv6), but will take several years to implement because it requires\nmodification of the entire infrastructure of the Internet.\n\nThis is where NAT (RFC 1631) comes to the rescue.\n\nNetwork Address Translation allows a single device, such as a router, to act as an agent between the\nInternet (or \"public network\") and a local (or \"private\") network.\n\nProf. Maulik Trivedi, CE Department | 2140709 — Computer Networks (CN) 13\n"
    },
    {
      "page_number": "14",
      "content": "Darshan\n\nInstitute of Engineering & Technology 4- Network Layer\n\ne This means that only a single, unique IP address is required to represent an entire group of\ncomputers.\n\nNAT translation table\n\nWAN side LAN side\n138.76.29.7, 5001 10.0.0.1, 3345\n\n5 = 10.0.0.1, 3345\n\nD = 128.119.40.186, 80 | 10.0.0.1\n——\na @ ee 5001 ]\n25 D=128.119.40.186, 80\na_i 10.0.0.4 | FI) 10002\n\n~~)\n\nS\ney ae —\n\n><\ns (4)\nS$ = 128.119.40.186, 80 3) $= 128.119.40.186, 80\nD = 138.76.29.7, 5001 ~ D = 10.0.0.1, 3345\nre 10.0.0.3\n\nFig. 11 Network address translation\n\nICMP: Internet Control Message Protocol\n\ne When something unexpected occurs, the event is reported by the ICMP (Internet Control Message\nProtocol), which is also used to test the Internet.\n\ne About a dozen types of ICMP messages are defined. The most important ones are listed below. Each\nICMP message type is encapsulated in an IP packet.\n\nMessage Type Description\n\nDestination unreachable Packet could not be delivered\n\nTime exceeded Time to live field hit 0\n\nParameter problem Invalid header field\n\nSource quench Choke packet\n\nRedirect Teach a router about geography\n\nEcho Ask a machine if it is alive\n\nEcho reply Yes, | am alive\n\nTimestamp request Same as Echo request, but with timestamp\n\nTimestamp reply Same as Echo reply, but with timestamp\n\ne The DESTINATION UNREACHABLE message is used when the subnet or a router cannot locate the\ndestination or when a packet with the DF bit cannot be delivered because a \"small-packet\" network\nstands in the way.\n\ne The TIME EXCEEDED message is sent when a packet is dropped because its counter has reached\nzero.\n\ne The PARAMETER PROBLEM message indicates that an illegal value has been detected in a header\nfield.\n\nProf. Maulik Trivedi, CE Department | 2140709 — Computer Networks (CN) 14\n"
    },
    {
      "page_number": "15",
      "content": "Darshan\n\nInstitute of Engineering & Technology 4- Network Layer\n\ne This problem indicates a bug in the sending host's IP software or possibly in the software of a router\ntransited.\n\ne The SOURCE QUENCH message was formerly used to throttle hosts that were sending too many\npackets. When a host received this message, it was expected to slow down.\n\ne The REDIRECT message is used when a router notices that a packet seems to be routed wrong. It is\nused by the router to tell the sending host about the probable error.\n\ne The ECHO and ECHO REPLY messages are used to see if a given destination is reachable and alive.\n\ne Upon receiving the ECHO message, the destination is expected to send an ECHO REPLY message\nback.\n\ne The TIMESTAMP REQUEST and TIMESTAMP REPLY messages are similar, except that the arrival time\nof the message and the departure time of the reply are recorded in the reply.\n\nIPv6 Datagram Format\n32 ine\n\nVersion Traffic class Flow label\n\nPayload length Next hdr Hop limit\n\nSource address\n(128 bits)\n\nDestination address\n(128 bits)\n\nData\n\nFig. 12 IPv6 datagram format\n\ne Version: The size of the Version field is 4 bits. The Version field shows the version of IP and is set to\n6.\n\ne Traffic Class: The size of Traffic Class field is 8 bits. Traffic Class field is similar to the IPv4 Type of\nService (ToS) field. The Traffic Class field indicates the IPv6 packet’s class or priority.\n\ne Flow Label: The size of Flow Label field is 20 bits. The Flow Label field provide additional support for\nreal-time datagram delivery and quality of service features. The purpose of Flow Label field is to\nindicate that this packet belongs to a specific sequence of packets between a source and destination\nand can be used to prioritized delivery of packets for services like voice.\n\ne Payload Length: The size of the Payload Length field is 16 bits. The Payload Length field shows the\nlength of the IPv6 payload, including the extension headers and the upper layer protocol data\n\ne Next Header: The size of the Next Header field is 8 bits. The Next Header field shows either the type\nof the first extension (if any extension header is available) or the protocol in the upper layer such as\nTCP, UDP, or ICMPv6.\n\ne Hop Limit: The size of the Hop Limit field is 8 bits The Hop Limit field shows the maximum number of\nrouters the IPv6 packet can travel. This Hop Limit field is similar to IPv4 Time to Live (TTL) field.\n\ne Source Address: The size of the Source Address field is 128 bits. The Source Address field shows the\nIPv6 address of the source of the packet.\n\nProf. Maulik Trivedi, CE Department | 2140709 — Computer Networks (CN) 15\n"
    },
    {
      "page_number": "16",
      "content": "Difference between IPv4 and IPv6\n\nDarshan\n\nInstitute of Engineering & Technology\n\nB\n\n4 —- Network Layer\n\nDestination Address: The size of the Destination Address field is 128 bits. The Destination Address\nfield shows the IPv6 address of the destination of the packet.\nData: The data to be transmitted in the datagram, either an entire higher-layer message or a\n\nfragment of one.\n\nIPv4\n\nIPv6é\n\nIPv4 addresses are 32 bit length.\n\nIPv6 addresses are 128 bit length.\n\nFragmentation is done by sender and\n\nforwarding routers.\n\nFragmentation is done only by sender.\n\nNo packet flow identification.\n\nPacket flow identification is available within\nthe IPv6 header using the Flow Label field.\n\nChecksum field is available in header\n\nNo checksum field in header.\n\nOptions fields are available in header.\n\nNo option fields, but Extension headers are\navailable.\n\nAddress Resolution Protocol (ARP)is available\nto map IPv4 addresses to MAC addresses.\n\nAddress Resolution Protocol (ARP) is replaced\nwith Neighbour Discovery Protocol.\n\nBroadcast messages are available.\n\nBroadcast messages are not available.\n\nManual configuration (Static) of IP addresses\n\nAuto-configuration of addresses is available.\n\nor DHCP (Dynamic configuration) is required to\nconfigure IP addresses.\n\nThe Link-State (LS) Routing Algorithm (Dijkstra’s algorithm)\n\ne —Dijkstra’s algorithm computes the least-cost path from one node (the source, which we will refer to\nas u) to all other nodes in the network.\n\ne Dijkstra’s algorithm is iterative and has the property that after the k\" iteration of the algorithm, the\nleast-cost paths are known to k destination nodes, and among the least-cost paths to all destination\nnodes, these k paths will have the k smallest costs.\n\ne Let us define the following notation:\n\n> D(v): cost of the least-cost path from the source node to destination v as of this iteration of the\nalgorithm.\n\n> p(v): previous node (neighbor of v) along the current least-cost path from the source to v.\n\n> N’: subset of nodes; v is in N’ if the least-cost path from the source to v is definitively known.\n\ne The global routing algorithm consists of an initialization step followed by a loop.\n\ne The number of times the loop is executed is equal to the number of nodes in the network.\n\ne Upon termination, the algorithm will have calculated the shortest paths from the source node u to\nevery other node in the network.\n\ne Asan example, let’s consider the network in Figure 13 and compute the least-cost paths from u to\n\nall possible destinations.\n\nProf. Maulik Trivedi, CE Department | 2140709 — Computer Networks (CN) 16\n"
    },
    {
      "page_number": "17",
      "content": "Darshan\n\nInstitute of Engineering & Technology 4 — Network Layer\n\nFig. 13 Abstract graph model of a computer network\n\n1 Initialization:\n\n2 N’ = {u}\n\n3 for all nodes v\n\n4 if v is a neighbor of u\n\n5 then D(v) = c(u,v)\n\n6 else D(v) = =\n\n7\n\n8 Loop\n\n9 find w not in N’ such that D(w) is a minimum\n\n10 add w to N’\n\n11 update D(v) for each neighbor v of w and not in N’:\n12 D(v) = min( D(v), D(w) + c(w,v) )\n\n13 /* new cost to v is either old cost to v or known\n14 least path cost to w plus cost from w to v */\n\n15 until N'= N\nLet’s consider the few first steps in detail.\nIn the initialization step, the currently known least-cost paths from u to its directly attached\nneighbours, v, x, and w, are initialized to 2, 1, and 5, respectively. Note in particular that the cost to\nw is set to 5 (even though we will soon see that a lesser-cost path does indeed exist) since this is the\ncost of the direct (one hop) link from u to w. The costs to y and z are set to infinity because they are\nnot directly connected to u.\nIn the first iteration, we look among those nodes not yet added to the set N’ and find that node with\nthe least cost as of the end of the previous iteration. That node is x, with a cost of 1, and thus x is\nadded to the set N’. Line 12 of the LS algorithm is then performed to update D(v) for all nodes v,\nyielding the results shown in the second line (Step 1) in below table. The cost of the path to v is\nunchanged. The cost of the path to w (which was 5 at the end of the initialization) through node x is\nfound to have a cost of 4. Hence this lower-cost path is selected and w’s predecessor along the\nshortest path from u is set to x. Similarly, the cost to y (through x) is computed to be 2, and the table\nis updated accordingly.\nIn the second iteration, nodes v and y are found to have the least-cost paths (2), and we break the\ntie arbitrarily and add y to the set N’ so that N’ now contains u, x, and y. The cost to the remaining\n\nProf. Maulik Trivedi, CE Department | 2140709 — Computer Networks (CN) 17\n"
    },
    {
      "page_number": "18",
      "content": "D Darshan 4 —- Network Layer\n\nInstitute of Engineering & Technology\n\nnodes not yet in N’, that is, nodes v, w, and z are updated via line 12 of the LS algorithm, yielding the\nresults shown in the third row in the below table.\n\nAndsoon....\n\nWhen the LS algorithm terminates, we have, for each node, its predecessor along the least-cost path\nfrom the source node.\n\nFor each predecessor, we also have its predecessor, and so in this manner we can construct the\nentire path from the source to all destinations.\n\nThe forwarding table in a node, say node u, can then be constructed from this information by\nstoring, for each destination, the next-hop node on the least-cost path from u to the destination.\nFigure 14. Shows the resulting least-cost paths for u for the network in Figure 13.\n\nstep N’ Div) plv) D(w),p(w) D(x), p(x) Diy), ply) D(z),p(z)\n0 u 2u 5u lu co eo\n] UX 2u 4x 2x eo\n2 uxy Qu 3y 4y\n3 uxy 3y 4y\n4 uxyww 4y\n5 UXywwz\n\nTable: Running the link-state algorithm on the network in Figure 13\np ww\n\nCE. a)\n\nFig. 14 Least cost path for nodule u\n\nThe Distance-Vector (DV) Routing Algorithm\n\nDistance-vector (DV) algorithm is iterative, asynchronous, and distributed.\nIt is distributed in that each node receives some information from one or more of its directly\nattached neighbours, performs a calculation, and then distributes the results of its calculation back\nto its neighbours.\nIt is iterative in that this process continues on until no more information is exchanged between\nneighbours.\nThe algorithm is asynchronous in that it does not require all of the nodes to operate in lockstep with\neach other.\nLet dx(y) be the cost of the least-cost path from node x to node y. Then the least costs are related by\nthe celebrated Bellman-Ford equation:\n\ndaly) = ming{c(x,v) + du{y)}\nwhere the miny in the equation is taken over all of x’s neighbours. Indeed, after traveling from x to v,\nif we then take the least-cost path from v to y, the path cost will be c(x,v) + dv(y).\n\nProf. Maulik Trivedi, CE Department | 2140709 — Computer Networks (CN) 18\n"
    },
    {
      "page_number": "19",
      "content": "Darshan\n\nInstitute of Engineering & Technology 4 — Network Layer\n\ne Since we must begin by traveling to some neighbour v, the least cost from x to y is the minimum of\nc(x,v) + dv(y) taken over all neighbours v.\n\n1 Initialization:\n\n2 for all destinations y in N:\n\n3 Diy) = ¢(x,y) /* if y is not a neighbor then c(x,y) = = */\n4 for each neighbor w\n\n5 D,(y) = ? for all destinations y in N\n\n6 for each neighbor w\n\n7 send distance vector D, = [D,(y): y in N] tow\n\n8\n\n9 loop\n\n10 wait (until I see a link cost change to some neighbor w or\n\n11 until I receive a distance vector from some neighbor w)\n12\n\n13 for each y in N:\n\n14 D.(y) = min,{c(x,v) + D,(y)}\n\n15\n\n16 if D.(y) changed for any destination y\n\n17 send distance vector D, = [D,(y): y in N] to all neighbors\n18\n\n19 forever\n\ne Figure 15 illustrates the operation of the DV algorithm for the simple three node network shown at\nthe top of the figure.\n\ne The operation of the algorithm is illustrated in a synchronous manner, where all nodes\nsimultaneously receive distance vectors from their neighbours, compute their new distance vectors,\nand inform their neighbours if their distance vectors have changed.\n\ne The leftmost column of the figure displays three initial routing tables for each of the three nodes.\n\ne For example, the table in the upper-left corner is node x’s initial routing table.\n\ne Within a specific routing table, each row is a distance vector - specifically, each node’s routing table\nincludes its own distance vector and that of each of its neighbours.\n\ne Thus, the first row in node y’s initial routing table is Dx = [D(x), Dx(y), Dx(z)] = [0, 2, 7].\n\ne The second and third rows in this table are the most recently received distance vectors from nodes y\nand z, respectively.\n\ne Because at initialization node x has not received anything from node y or z, the entries in the second\nand third rows are initialized to infinity.\n\ne After initialization, each node sends its distance vector to each of its two neighbours.\n\ne = This is illustrated in Figure 15 by the arrows from the first column of tables to the second column of\ntables.\n\ne For example, node x sends its distance vector D, = [0, 2, 7] to both nodes y and z. After receiving the\nupdates, each node recomputes its own distance vector.\n\ne For example, node x computes\n\nD,(x) = 0\nDx(y) = min{c(x,y) + Dy(y), ¢(x,z) + D-(y)} = min{2 + 0, 7+ 1}=2\nD,(z) = min{c(x,y) + Dy(z), c(x,z) + D,(z)} = min{2 + 1, 7+ O} =3\n\nProf. Maulik Trivedi, CE Department | 2140709 — Computer Networks (CN) 19\n"
    },
    {
      "page_number": "20",
      "content": "D Darshan\n\nInstitute of Engineering & Technology 4- Network Layer\n\nNode x table\n\nfrom\n\nNode y table\n\ncost to\n\nTime\n\nFig. 15 Distance-vector (DV) algorithm\n\ne The second column therefore displays, for each node, the node’s new distance vector along with\ndistance vectors just received from its neighbours.\n\ne Note, that node x’s estimate for the least cost to node z, Dx(z), has changed from 7 to 3.\n\ne Also note that for node x, neighbouring node y achieves the minimum in line 14 of the DV algorithm;\nthus at this stage of the algorithm, we have at node x that v*(y) =y and v*(z) =y.\n\ne After the nodes recomputes their distance vectors, they again send their updated distance vectors\nto their neighbours (if there has been a change).\n\ne = This is illustrated in Figure 15 by the arrows from the second column of tables to the third column of\ntables.\n\ne Note that only nodes x and z send updates: node y’s distance vector didn’t change so node y doesn’t\nsend an update.\n\nProf. Maulik Trivedi, CE Department | 2140709 — Computer Networks (CN) 20\n"
    },
    {
      "page_number": "21",
      "content": "Darshan\n\nIniaheved of Engineering a ibehiolisy 4 — Network Layer\n\ne After receiving the updates, the nodes then recomputes their distance vectors and update their\nrouting tables, which are shown in the third column.\n\ne The process of receiving updated distance vectors from neighbours, recomputing routing table\nentries, and informing neighbours of changed costs of the least-cost path to a destination continues\nuntil no update messages are sent.\n\ne At this point, since no update messages are sent, no further routing table calculations will occur and\nthe algorithm will enter a quiescent state; that is, all nodes will be performing the wait in Lines 10—\n11 of the DV algorithm.\n\ne The algorithm remains in the quiescent state until a link cost changes.\n\nComparison of (Difference between) LS and DV Routing\n\nAlgorithms\nDistance Vector Protocol Link state protocol\nEntire routing table is sent as an update Updates are incremental & entire routing table is\n\nnot sent as update\nDistance vector protocol send periodic update at | Updates are triggered not periodic\nevery 30 or 90 second\n\nUpdate are broadcasted Updates are multicasted\n\nUpdates are sent to directly connected neighbour | Update are sent to entire network & to just\nonly directly connected neighbour\n\nRouters don't have end to end visibility of entire | Routers have visibility of entire network of that\nnetwork. area only.\n\nIt is prone to routing loops No routing loops\n\nThe Count to Infinity problem\n\ne Distance vector routing works in theory but has a serious drawback in practice.\n\ne Consider a router whose best route to destination X is large.\n\ne If on the next exchange neighbour A suddenly reports a short delay to X, the router just switches\nover to using line to A to send traffic to X.\n\ne Suppose A is down initially and all the other routers know this. In other words, they have all\nrecorded the delay to A as infinity.\n\ne When Acomes up, the other routers learn about it via the vector exchanges.\n\ne Atthe time of the first exchange, B learns that its left neighbour has zero delay to A.\n\ne Bnow makes an entry in its routing table that A is one hop away to the left.\n\ne All the other routers still think that A is down. At this point, the routing table entries for A are as\nshown in the second row of Figure 16 (a).\n\ne On the next exchange, C learns that B has a path of length 1 to A, so it updates its routing table to\nindicate a path of length 2, but D and E do not hear the good news until later.\n\ne Clearly, the good news is spreading at the rate of one hop per exchange.\n\nProf. Maulik Trivedi, CE Department | 2140709 — Computer Networks (CN) 21\n"
    },
    {
      "page_number": "22",
      "content": "D Darshan 4 —- Network Layer\n\nInstitute of Engineering & Technology\n\nA B Cc D E A B Cc D E\no—__e__e__e\ne e ° e Initially 1 2 3 4 Initially\n1 e ° e After 1 exchange 3 2 3 4 After 1 exchange\n1 2 . e After 2 exchanges 3 4 3 4 After 2 exchanges\n1 2 3 e After 3 exchanges 5 4 5 4 After 3 exchanges\n1 2 3 4 After 4 exchanges 5 6 5 6 After 4 exchanges\n7 6 7 6 After 5 exchanges\n(a) 7 8 7 8 After 6 exchanges\ne e e e\n\n(b)\n\nFig. 16: The Count to infinity problem\nNow let us consider the situation of Figure 16 (b), in which all the lines and routers are initially up.\nRouters B, C, D, and E have distances to A of 1, 2, 3, and 4, respectively.\nSuddenly A goes down, or alternatively, the line between A and B is cut, which is effectively the\nsame thing from B's point of view.\nAt the first packet exchange, B does not hear anything from A.\nFortunately, C says: Do not worry; | have a path to A of length 2.\nLittle does B know that C's path runs through B itself. For all B knows, C might have ten lines all with\nseparate paths to A of length 2.\nAs a result, B thinks it can reach A via C, with a path length of 3. D and E do not update their entries\nfor A on the first exchange.\nOn the second exchange, C notices that each of its neighbours claims to have a path to A of length 3.\nIt picks one of them at random and makes its new distance to A 4, as shown in third row of Figure\n16(b).\nSubsequent exchanges produce the history shown in the rest of Figure 16(b).\nFrom this figure, it should be clear why bad news travels slowly: no router ever has a value more\nthan one higher than the minimum of all its neighbours.\nGradually, all routers work their way up to infinity, but the number of exchanges required depends\non the numerical value used for infinity.\nFor this reason, it is wise to set infinity to the longest path plus 1.\nNot entirely surprisingly, this problem is known as the count-to-infinity problem.\n\nHierarchical Routing\n\nAs networks grow in size, the router routing tables grow proportionally.\n\nNot only is router memory consumed by ever-increasing tables, but more CPU time is needed to\nscan them and more bandwidth is needed to send status reports about them.\n\nAt a certain point the network may grow to the point where it is no longer feasible for every router\nto have an entry for every other router, so the routing will have to be done hierarchically, as it is in\nthe telephone network.\n\nWhen hierarchical routing is used, the routers are divided into what called regions, with each router\nknowing all the details about how to route packets to destinations within its own region, but\nknowing nothing about the internal structure of other regions.\n\nProf. Maulik Trivedi, CE Department | 2140709 — Computer Networks (CN) 22\n"
    },
    {
      "page_number": "23",
      "content": "Darshan\n\n[niahevtd of Engineering @ioehiclésy 4—- Network Layer\n\nFull table for 1A Hierarchical table for 1A\nDest. Line Hops Dest. Line Hops\nRegion 1 Region 2 iA| - - 4A| - - |\nie “On 2B. 1B] 1B | 4 iB] 1B | 1 |\n: 1c{ ic | 4 ic[ ic [ 1 |\n2a| 1B 2 2| 1B 2 |\n2B/ 1B 3 3| 1C 2 |\n2c} 1B 3 4| 1c 3 |\n2D| 1B 4 5| 1C¢ 4 |\n3A| 1 3\n3B} 1C 2\n4A|_ 1C 3\nRegion3 Region4 Region 5 ae Te =\n4c| 1c 4\n5A} 1C 4\n5B|_1C 5\n6C| 1B 5\n5D| 1C 6\n5E|_1C 5\n\n(a) (b) (©)\nFig. 2: Hierarchical Routing\n\nFigure 17 gives a quantitative example of routing in a two-level hierarchy with five regions. The full\nrouting table for router 1A has 17 entries, as shown in Figure 17 (b).\n\nWhen routing is done hierarchically, as in Figure 17 (c), there are entries for all the local routers as\nbefore, but all other regions have been condensed into a single router, so all traffic for region 2 goes\nvia the 1B -2A line, but the rest of the remote traffic goes via the 1C -3B line. Hierarchical routing has\nreduced the table from 17 to 7 entries.\n\nAs the ratio of the number of regions to the number of routers per region grows, the savings in table\nspace increase.\n\nUnfortunately, these gains in space are not free. There is a penalty to be paid, and this penalty is in\nthe form of increased path length.\n\nFor example, the best route from 1A to 5C is via region 2, but with hierarchical routing all traffic to\nregion 5 goes via region 3, because that is better for most destinations in region 5.\n\nWhen a single network becomes very large, an interesting question is: How many levels should the\nhierarchy have? For example, consider a subnet with 720 routers.\n\nIf there is no hierarchy, each router needs 720 routing table entries. If the subnet is partitioned into\n24 regions of 30 routers each, each router needs 30 local entries plus 23 remote entries for a total of\n53 entries.\n\nBroadcast Routing\n\nIn some applications, hosts need to send messages to many or all other hosts.\n\nFor example, a service distributing weather reports, stock market updates, or live radio programs\nmight work best by broadcasting to all machines and letting those that are interested read the data.\nSending a packet to all destinations simultaneously is called broadcasting.\n\nFirst broadcasting method that requires no special features from the subnet is for the source to\nsimply send a distinct packet to each destination.\n\nProf. Maulik Trivedi, CE Department | 2140709 — Computer Networks (CN) 23\n"
    },
    {
      "page_number": "24",
      "content": "Darshan\n\nInstitute of Engineering & Technology 4- Network Layer\n\nNot only is the method wasteful of bandwidth, but it also requires the source to have a complete list\nof all destinations. In practice this may be the only possibility, but it is the least desirable of the\nmethods.\n\nB c\n\nA =i\n\n¢ Trt,\n\n(a) (b) (c)\n\nFig. 3: (a) A subnet. (b) A sink tree. (c) The tree built by reverse path forwarding\nFlooding is another Second method. Although flooding is ill-suited for ordinary point-to-point\ncommunication, for broadcasting it might rate serious consideration, especially if none of the\nmethods described below are applicable.\n\nThe problem with flooding as a broadcast technique is the same problem it has as a point-to-point\nrouting algorithm: it generates too many packets and consumes too much bandwidth.\n\nA third algorithm is multi destination routing.\n\nIf this method is used, each packet contains either a list of destinations or a bit map indicating the\ndesired destinations.\n\nWhen a packet arrives at a router, the router checks all the destinations to determine the set of\noutput lines that will be needed.\n\nThe router generates a new copy of the packet for each output line to be used and includes in each\npacket only those destinations that are to use the line.\n\nA fourth broadcast algorithm makes explicit use of the sink tree for the router initiating the\nbroadcast-or any other convenient spanning tree for that matter.\n\nA spanning tree is a subset of the subnet that includes all the routers but contains no loops.\n\nIf each router knows which of its lines belong to the spanning tree, it can copy an incoming\nbroadcast packet onto all the spanning tree lines except the one it arrived on.\n\nFifth broadcast algorithm is reverse path forwarding, is remarkably simple once it has been pointed\nout.\n\nWhen a broadcast packet arrives at a router, the router checks to see if the packet arrived on the\nline that is normally used for sending packets to the source of the broadcast.\n\nIf so, there is an excellent chance that the broadcast packet itself followed the best route from the\nrouter and is therefore the first copy to arrive at the router.\n\nThis being the case, the router forwards copies of it onto all lines except the one it arrived on.\n\nMulticast Routing\n\nSending a message to a group is called multicasting, and its routing algorithm is called multicast\nrouting.\n\nMulticasting requires group management. Some way is needed to create and destroy groups, and to\nallow processes to join and leave groups.\n\nProf. Maulik Trivedi, CE Department | 2140709 — Computer Networks (CN) 24\n"
    },
    {
      "page_number": "25",
      "content": "D Darshan 4 —- Network Layer\n\nInstitute of Engineering & Technology\n\nTo do multicast routing, each router computes a spanning tree covering all other routers.\n\nFor example, in Figure (a) we have two groups, 1 and 2.\n\nSome routers are attached to hosts that belong to one or both of these groups, as indicated in the\nfigure.\n\nA spanning tree for the leftmost router is shown in Figure (b).\n\nWhen a process sends a multicast packet to a group, the first router examines its spanning tree and\nprunes it, removing all lines that do not lead to hosts that are members of the group.\n\nIn our example, Figure (c) shows the pruned spanning tree for group 1.\n\n1 2\n1 « s 2 See. 2\n——— @\n1 ———* e @\n1 e\n(c) (a)\n\nFig. 49: (a) Anetwork. (b) A spanning tree for the leftmost router\ne Similarly, Figure (d) shows the pruned spanning tree for group 2. Multicast packets are\nforwarded only along the appropriate spanning tree.\n\nIntra-AS Routing\n\nIt is also known as interior gateway protocols (IGP)\nMost common intra-AS routing protocols:\n\n1. RIP: Routing Information Protocol\n\n2. OSPF: Open Shortest Path First\n\n3. IGRP: Interior Gateway Routing Protocol\n\nRIP (Routing Information Protocol)\n\nThe Routing Information Protocol (RIP) defines a way for routers, which connect networks using the\nInternet Protocol (IP), to share information about how to route traffic among networks.\n\nEach RIP router maintains a routing table, which is a list of all the destinations (networks) it knows\nhow to reach, along with the distance to that destination.\n\nRIP uses a distance vector algorithm to decide which path to put a packet on to get to its\ndestination.\n\nIt stores in its routing table the distance for each network it knows how to reach, along with the\naddress of the \"next hop\" router - another router that is on one of the same networks - through\nwhich a packet has to travel to get to that destination.\n\nProf. Maulik Trivedi, CE Department | 2140709 — Computer Networks (CN) 25\n"
    },
    {
      "page_number": "26",
      "content": "Darshan\n\n[niahevtd of Engineering @ioehiclésy 4—- Network Layer\n\nIf it receives an update on a route and the new path is shorter, it will update its table entry with the\nlength and next-hop address of the shorter path; if the new path is longer, it will wait through a\n\"hold-down\" period to see if later updates reflect the higher value as well, and only update the table\nentry if the new, longer path is stable.\n\nUsing RIP, each router sends its entire routing table to its closest neighbours every 30 seconds. (The\nneighbours are the other routers to which this router is connected directly - that is, the other\nrouters on the same network segments this router is on.)\n\nThe neighbours in turn will pass the information on to their nearest neighbours, and so on, until all\nRIP hosts within the network have the same knowledge of routing paths, a state known as\nconvergence.\n\nOSPF (Open Shortest Path First)\n\nThe Internet is made up of a large number of Autonomous Systems (AS).\n\nA routing algorithm within an AS is called an interior gateway protocol; an algorithm for routing\nbetween AS is called an exterior gateway protocol.\n\nMany of the ASes in the Internet are themselves large and nontrivial to manage.\n\nOSPF allows them to be divided into numbered areas, where an area is a network or a set of\ncontiguous networks.\n\nAreas do not overlap but need not be exhaustive, that is, some routers may belong to no area. An\narea is a generalization of a subnet.\n\nEvery AS has a backbone area, called area 0.\n\nAll areas are connected to the backbone, possibly by tunnels, so it is possible to go from any area in\nthe AS to any other area in the AS via the backbone.\n\nEach router that is connected to two or more areas is part of the backbone. As with other areas, the\ntopology of the backbone is not visible outside the backbone.\n\nBackbone\n\no\nFy\n8\nQ\ns\ns\nE\n\nBGP protocol\n\n| ae connects the ASes\n\nAS3 AS4 Area\n_—+ border\n\nrouter\n\n‘\nInternal router\n\ni\n'\nt\nt\n'\ni\nt\n'\n'\n'\n'\n'\n'\n'\nt\nt\nt\nt\nt\nt\nt\n\nAS tou tidary router\nFig. 5: The relation between ASes, backbones, and areas in OSPF\n\nProf. Maulik Trivedi, CE Department | 2140709 — Computer Networks (CN) 26\n"
    },
    {
      "page_number": "27",
      "content": "Darshan\n\nInstitute of Engineering & Technology\n\nB\n\n4 —- Network Layer\n\ne Within an area, each router has the same link state database and runs the same shortest path\nalgorithm.\ne Its main job is to calculate the shortest path from itself to every other router in the area, including\nthe router that is connected to the backbone, of which there must be at least one.\ne A router that connects to two areas needs the databases for both areas and must run the shortest\npath algorithm for each one separately.\ne This algorithm forces a star configuration on OSPF with the backbone being the hub and the other\nareas being spokes. Packets are routed from source to destination \"as is.\"\ne They are not encapsulated or tunneled, unless going to an area whose only connection to the\nbackbone is a tunnel. Figure shows part of the Internet with ASes and areas.\nOSPF distinguishes four classes of routers:\n1. Internal routers are wholly within one area.\n2. Area border routers connect two or more areas.\n3. Backbone routers are on the backbone.\n4. AS boundary routers talk to routers in other ASes.\nArea border router (ABR)\ne An area border router (ABR) is a router that connects one or more areas to the main backbone\nnetwork.\ne It is considered a member of all areas it is connected to.\ne An ABR keeps multiple copies of the link-state database in memory, one for each area to which\nthat router is connected.\nAutonomous system boundary router (ASBR)\ne An autonomous system boundary router (ASBR) is a router that is connected to more than one\nRouting protocol and that exchanges routing information with routers in other protocols.\ne ASBRs typically also run an exterior routing protocol (e.g., BGP), or use static routes, or both.\ne An ASBR is used to distribute routes received from other, external ASs throughout its own\nautonomous system.\nInternal router (IR)\ne An internal router is a router that has OSPF neighbour relationships with interfaces in the same\narea. An internal router has all its interfaces in a single area.\nBackbone router (BR)\ne The backbone routers accept information from the area border routers in order to compute the\nbest route from each backbone router to every other router.\ne = This information is propagated back to the area border routers, which advertise it within their\nareas.\n\nComparison between RIP OSPF and BGP\n\nRIP OSPF BGP\n\nRIP is intra domain routing\nprotocol used with in the\nautonomous system\n\nOSPF is also intra domain routing\nprotocol used with in the\nautonomous system\n\nIt is inter domain routing\nprotocol used between the\nautonomous system\n\nRIP is used for Small networks\nwith maximum number of hops\n16\n\nOSPF is used in large\nautonomous system with no\nlimitation\n\nThe BGP protocol is used for very\nlarge-scale networks\n\nRIP uses Distance Vector\n\nOSPF uses Link State\n\nBGP uses Path Vector\n\nProf. Maulik Trivedi, CE Department\n\n| 2140709 — Computer Networks (CN)\n\n27\n\n"
    },
    {
      "page_number": "28",
      "content": "D Darshan 4 —- Network Layer\n\nInstitute of Engineering & Technology\n\nRIP send entire routing update to | OSPF send multicast Hello packet | BGP send Open packet to the\n\nall directly connected interface to the neighbours, to create neighbours to create session\nsession\n\nRIP use Bellman ford Algorithm OSPF use Dijikstra Algorithm BGP use Path-Vector Routing\n\nConsider a router that interconnects three subnets: Subnet 1,\nSubnet 2, and Subnet 3. Suppose all of the interfaces in each of\nthese three subnets are required to have the prefix 23.1.17/24.\nAlso suppose that Subnet 1 is required to support at least 60\ninterfaces, Subnet 2 is to support at least 90 interfaces, and\nSubnet 3 is to support at least 12 interfaces. Provide three\nnetwork addresses (of the form a.b.c.d/x) that satisfy these\n\nconstraints.\ne For Subnet1 we have to support at least 60 interfaces and 26 >= 60 so the prefix for subnet1 is\n32-6 = 26 for subnet1 = 23.1.17.x/26\ne For Subnet2 we have to support at least 90 interfaces and 27 >= 90 so the prefix for subnet2 is\n32-7 = 25, and so subnet2 = 23.1.17.y/25\ne For Subnet3 we have to support at least 12 interfaces and 2%4 >= 12 so the prefix for subnet3 is\n32-4 = 28 , and so subnet3 = 23.1.17.z/28\ne Now find the values for x,y and z.\n> subnet 1 23.1.17.0/26\n> subnet 2 23.1.17.128/25\n> subnet 3 23.1.17.64/28\n\nSuppose datagrams are limited to 1,500 bytes (including\nheader) between source Host A and destination Host B.\nAssuming a 20-byte IP header, how many datagrams would be\nrequired to send an MP3 consisting of 5 million bytes? Explain\nhow you computed your answer.\n\nGiven: IP Header size = 20 bytes\nDatagram Size = 1500 bytes\nWe know: TCP Header size = 20 bytes\n\nSo to find the data contain in each datagram we need to deduct IP and TCP Header that is\n1500 - 20 - 20 = 1460 bytes\n\nEach datagram can carry maximum 1460 bytes.\n\nSo we number of datagrams required to send 5 million bytes =5000000 / 1460 = 3424.66\nSo we need 3425 datagrams to carry 5 million bytes.\n\nProf. Maulik Trivedi, CE Department | 2140709 — Computer Networks (CN) 28\n\n"
    }
  ]
}