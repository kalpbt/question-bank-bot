[
  {
    "page_number": 1,
    "content": "2°\nDarsh an 1 — Introduction to Computer Networks & Internet\n\nComputer Network\n\nA computer network is a system in which multiple computers are connected to each other to\nshare information and resources.\n\nThe physical connection between networked computing devices is established using either cable\nmedia or wireless media.\n\nThe best-known computer network is the Internet.\n\n[_\nwe\neee\n\n|\n\nCOMPUTER\nWETWORK\n\nSy\n\na\n\nFigure 1: Computer Network\n\nAdvantages of Computer Networks\n\nFile sharing\n\nThe major advantage of a computer network is that allows file sharing and remote file access. A\nperson sitting at one workstation that is connected to a network can easily see files present on\nanother workstation, provided he is authorized to do so.\n\nResource sharing\n\nAll computers in the network can share resources such as printers, fax machines, modems, and\nscanners.\n\nBetter connectivity and communications\n\nIt allows users to connect and communicate with each other easily. Various communication\napplications included e-mail and groupware are used. Through e-mail, members of a network\ncan send a message and ensure safe delivery of data to other members, even in their absence.\nInternet access\n\nComputer networks provide internet service over the entire network. Every single computer\nattached to the network can experience the high-speed internet.\n\nEntertainment\n\nMany games and other means of entertainment are easily available on the internet.\nFurthermore, Local Area Networks (LANs) offers and facilitates other ways of enjoyments, such\nas many players are connected through LAN and play a particular game with each other from a\nremote location.\n\nProf. Maulik Trivedi, CE Department | 2140709 — Computer Networks (CN) 1\n"
  },
  {
    "page_number": 2,
    "content": "D Darshan\n\nasesuée ot Encinaectug ak reohsokes 1 — Introduction to Computer Networks & Internet\n\ne Inexpensive system\nShared resources mean reduction in hardware costs. Shared files mean reduction in memory\nrequirement, which indirectly means a reduction in file storage expenses. A particular software\ncan be installed only once on the server and made available across all connected computers at\nonce. This saves the expense of buying and installing the same software as many times for as\nmany users.\n\ne Flexible access\nA user can log on to a computer anywhere on the network and access his files. This offers\nflexibility to the user as to where he should be during the course of his routine.\n\ne Instant and multiple access\nComputer networks are multiple processes. Many users can access the same information at the\nsame time. Immediate commands such as printing commands can be made with the help of\ncomputer networks.\n\nDisadvantages of Computer Networks\n\ne Lack of data security and privacy\nBecause there would be a huge number of people who would be using a computer network to\nget and share some of their files and resources, a certain user’s security would be always at risk.\nThere might even be illegal activities that would occur, which you need to be careful about and\naware of.\n\ne Presence of computer viruses and malware\nIf even one computer on a network gets affected by a virus, there is a possible threat for the\nother systems getting affected too. Viruses can spread on a network easily, because of the inter-\nconnectivity of workstations. Moreover, multiple systems with common resources are the\nperfect breeding ground for viruses that multiply.\n\ne Lack of Independence\nSince most networks have a centralized server and dependent clients, the client users lack any\nfreedom whatsoever. Centralized decision making can sometimes hinder how a client user\nwants to use his own computer.\n\ne Lack of Robustness\nAs previously stated, if a computer network’s main server breaks down, the entire system would\nbecome useless. Also, if it has a bridging device or a central linking server that fails, the entire\nnetwork would also come to a standstill.\n\ne Need an efficient handler\nFor a computer network to work efficiently and optimally, it requires high technical skills and\nknow-how of its operations and administration. A person just having basic skills cannot do this\njob. Take note that the responsibility to handle such a system is high, as allotting permissions\nand passwords can be daunting. Similarly, network configuration and connection is very tedious\nand cannot be done by an average technician who does not have advanced knowledge.\n\nUse (Applications) of Computer Networks\ne Financial services\nNowadays, almost all the financial services depend on the computer network. You can access\nthe financial services across the world. For example, a user can transfer money from one place\nto another by using the electronic fund transfer feature. You can use networking in various\nfinancial areas such as ATM, foreign exchange and credit history search.\ne Business\n\nProf. Maulik Trivedi, CE Department | 2140709 - Computer Networks (CN) 2\n"
  },
  {
    "page_number": 3,
    "content": "eo\n| Dar. sh qn 1 — Introduction to Computer Networks & Internet\n\nInstitute of Engineering & Technology\n\nNowadays, most of the works of businesses are done over the computers. To exchange the data\nand ideas, you need effective data and resources sharing features. To do this, you need to\nconnect the computer with each other through a network. For example, a person of one\ndepartment of an organization can share or access the electronic data of other departments\nthrough a network.\n\nEmail services\n\nA computer network provides you the facility to send or receive emails across the globe in few\nseconds.\n\nMobile applications\n\nBy using mobile applications, such as cellular or wireless phones, you can communicate\n(exchange your views and ideas) with one other.\n\nDirectory services\n\nIt provides you the facility to store files on a centralized location to increase the speed of search\noperation worldwide.\n\nTeleconferencing\n\nIt contains voice conferencing and video conferencing which are based on networking. In\nteleconferencing, the participants need not be presented at the same location.\n\nTypes of Computer Networks\nLAN (Local Area Network)\n\nIt is privately-owned networks within a single building or campus of up to a few kilometers in\nsize.\n\nThey are widely used to connect personal computers and workstations in company offices and\nfactories to share resources (e.g., printers) and exchange information.\n\nLANs are easy to design and troubleshoot\n\nIn LAN, all the machines are connected to a single cable.\n\nDifferent types of topologies such as Bus, Ring, Star, and Tree are used.\n\nThe data transfer rates for LAN is up to 10 Gbits/s.\n\nThey transfer data at high speeds. The high transmission rate is possible in LAN because of the\nshort distance between various computer networks.\n\nThey exist in a limited geographical area.\n\nAdvantages\n> LAN transfers data at high speed.\n> LAN technology is generally less expensive.\n\nLocal Area Network (LAN)\n\ni? fe\n\n\\ 4\nPrinter __ Ll a 3% Floppy (A:)\n\\\n\n/\n-—= f-\n\nFigure 2: Local Area Network\n\nProf. Maulik Trivedi, CE Department | 2140709 - Computer Networks (CN) 3\n"
  },
  {
    "page_number": 4,
    "content": "2°\n| Darsh an 1 — Introduction to Computer Networks & Internet\n\nMAN (Metropolitan Area Network)\n\ne MAN is a larger version of LAN which covers an area that is larger than the covered by LAN but\nsmaller than the area covered by WAN.\n\ne A metropolitan area network or MAN covers a city. The best-known example of a MAN is the\ncable television network available in many cities.\n\ne MAN connects two or more LANs.\n\ne At first, the companies began jumping into the business, getting contracts from city\ngovernments to wire up an entire city.\n\ne The next step was television programming and even entire channels designed for cable only.\n\n|=\na=\nBe —\n\nBranch Office\n\nWarehouse\n\nCentral Office\n\nFactory\nFigure 3: Metropolitan Area Network\n\nWAN ( Wide Area Network)\n\nWAN spans a large geographical area, often a country or region.\n\ne WAN links different metropolitan's countries and national boundaries thereby enabling easy\ncommunication.\n\ne It may be located entirely within a state or a country or it may be interconnected around the\nworld.\n\ne It contains a collection of machines intended for running user (i.e., application) programs.\nWe will follow traditional usage and call these machines hosts.\n\ne The communication between different users of WAN is established using leased telephone\n\nlines or satellite links and similar channels.\nMetropolitan Area Network (MAN) Metropolitan Area Network sor\n\nMetropolitan Area Network (MAN) Metropolitan Area Network (MAN)\nFigure 4: Wide Area Network\n\nProf. Maulik Trivedi, CE Department | 2140709 - Computer Networks (CN) 4\n"
  },
  {
    "page_number": 5,
    "content": "D Darshan\n\niaehhe Of Snaineurtng ad Tochiseleny 1 — Introduction to Computer Networks & Internet\n\nDifference between LAN, MAN, and WAN.\n\nParameter LAN MAN WAN\n\nArea covered Covers a small area. i.e. | Covers larger than LAN | Covers large area\nwithin building & smaller than WAN\n\nError rates Lowest Moderate Highest\n\nTransmission speed High speed Moderate speed Low speed\n\nEquipment cost Inexpensive Moderate-expensive Most expensive\n\nDesign & maintenance | Easy Moderate Difficult\n\nInternet\n\ne The internet is a type of world-wide computer network.\n\ne = The internet is the collection of infinite numbers of connected computers that are spread across\nthe world.\n\ne We can also say that the Internet is a computer network that interconnects hundreds of millions\nof computing devices throughout the world.\n\ne It is established as the largest network and sometimes called a network of a network that\nconsists of numerous academic, business and government networks, which together carry\nvarious information.\n\ne The Internet is a global computer network providing a variety of information and\ncommunication facilities, consisting of interconnected networks using standardized\ncommunication protocols.\n\ne When two computers are connected over the Internet, they can send and receive all kinds of\ninformation such as text, graphics, voice, video, and computer programs.\n\nCompany Network as coy\n\nKey:\n\nBp i }\n= VW B&B @eei'sa\n\n(or ond system) switch station fink\n\nFigure 5: Some pieces of the Internet\n\nProf. Maulik Trivedi, CE Department | 2140709 — Computer Networks (CN) 5\n"
  },
  {
    "page_number": 6,
    "content": "(D Darshan\n\niaehhe Of Snaineurtng ad Tochiseleny 1 — Introduction to Computer Networks & Internet\n\nProtocol\n\nA protocol is a set of rules that govern (manages) data communications.\nProtocols define methods of communication, how to communicate when to communicate etc.\nA protocol is an agreement between the communicating parties on how communication is to\nproceed.\nImportant elements of protocols are\n\n1. Syntax 2. Semantics 3. Timing\nSyntax:- Syntax means format of data or the structure how it is presented e.g. first eight bits are\nfor sender address, next eight bits are for receiver address and rest of the bits for message data.\nSemantics:- Semantics is the meaning of each section of bits e.g. the address bit means the\nroute of transmission or final destination of a message.\nTiming:- Timing means, at what time data can be sent and how fast data can be sent.\nSome protocols also support message acknowledgment and data compression designed for\nreliable and/or high-performance network communication.\nExample: HTTP, IP, FTP etc...\n\nFigure 6: A human protocol and a computer network protocol\n\nThe Network Edge\n\nIt defines those computers of the network used at the edge (end) of the network. These\ncomputers are known as hosts or end system.\nA host can be classified into the following two types:\n> Clients: Refer to the computer systems that request servers for the completion of a task.\nThe clients are generally called desktop PCs or workstations.\n> Servers: Refer to the computer systems that receive requests from the clients and\nprocess them. After the processing is complete, the servers send a reply to the clients\nwho sent the request.\n\nProf. Maulik Trivedi, CE Department | 2140709 — Computer Networks (CN) 6\n"
  },
  {
    "page_number": 7,
    "content": "e\nDar. sh an 1 - Introduction to Computer Networks & Internet\n\nInstitute of Engineering & Technology\n\ne The concept of clients and servers is essential in the network design. The various networks\ndesign models are as follows:\n1. Peer to Peer network 2. Client-Server network\n\nPeer to Peer network\ne In this network group of computers is connected together so that users can share resources and\ninformation.\ne There is no central location (server) for authenticating users, storing files, or accessing resources\nand each of them works as both client and server.\ne This means that users must remember which computers in the workgroup have the shared\nresource or information that they want to access.\ne Advantage:\n>  Itis easy to set up.\n> There is no need for any committed server as each peer acts as both server and client.\n> The network implementation is quite cheap.\n> The resources of a peer can be shared with other peers very easily in the network.\ne Disadvantage:\nThe speed of the network decreases due to heavy usage.\nIt is not easy to keep track of information on each computer.\nThere is no central backup of files and folders.\nNetwork and data security are weak.\n\nCentral Server\npe Distributed\nEe} Clients\n\nA\\. 8+ 38\nS865 -g°\n\nClient / Server Peer to Peer\n\nVVVV\n\nFigure 7: Network Edge - Client/Server Network and Peer to Peer\nClient/Server network\ne Aclient/server network is a system where one or more computers called clients to connect to a\ncentral computer named as a server to share or use resources.\n\ne The client requests a service from a server, which may include running an application,\nquerying a database, printing a document, performing a backup or recovery procedure. The\nrequest made by the client is handled by a server.\n\ne Aclient/server network is that in which the files and resources are centralized. This means\nthat the server can hold them and other computers (Client) can access them.\n\ne Advantage:\n> The server system holds the shared files.\n> The server system can be scheduled to take the file backups automatically.\n\nProf. Maulik Trivedi, CE Department | 2140709 — Computer Networks (CN) 7\n"
  },
  {
    "page_number": 8,
    "content": "D Darshan\n\nasesuée ot Encinaectug ak reohsokes 1 — Introduction to Computer Networks & Internet\n\n> Network access is provided only to authorized users through user security at the\nserver.\n> The server system is a kind of central repository for sharing a printer with clients.\n> Internet access, e-mail routing, and such other networking tasks are quite easily\nmanaged by the server.\n> The software applications shared by the server are accessible to the clients.\ne Disadvantage:\nThe implementation of the network is quite expensive.\nAn NOS (Network Operating System) is essential.\nIf a server fails, the entire network crashes.\nThere may be congestion if more than one client requests for a service at the same\ntime.\n\nTechniques used in data communications to transfer data\n\n1. Connection-oriented method 2. Connectionless method\n\nConnection-oriented method\n\ne Connection-oriented communication includes the steps of setting up a call from one computer\nto another, transmitting/receiving data, and then releasing the call, just like a voice phone call.\n\ne However, the network connecting the computers is a packet switched network, unlike the\nphone system's circuit switched network.\n\ne Connection-oriented communication is done in one of two ways over a packet switched\nnetwork:\n\n1. Without virtual circuits\n2. With virtual circuits.\nWithout virtual circuits:\n\ne = This is what TCP does on the Internet.\n\ne The only two machines on the Internet are aware of the connection which is established\nbetween the two computers at the endpoints.\n\ne The Internet itself, its routers and links have no information about the presence of a connection\nbetween the two computers.\n\ne This means that all of the packets flowing between the two computers can follow different\nroutes.\n\ne One benefit of establishing the connection is that the flow of packets from the source to the\ndestination can be slowed down if the Internet is congested and speeded up when congestion\ndisappears.\n\ne Another benefit is that the endpoints can anticipate traffic between them, and agree to\ncooperate to ensure the integrity and continuity of the data transfers. This allows the network\nto be treated as a \"stream\" of data.\n\nWith virtual circuit:\n\ne This is not used on the Internet, but is used in other types of networks (eg. the \"X.25\" protocol,\nstill popular in Europe).\n\ne The routers within the network route all packets in one connection over the same route. The\nadvantage is that video and voice traffic is easier to carry because routers can reserve memory\nspace to buffer the transmission.\n\nVVVV\n\nProf. Maulik Trivedi, CE Department | 2140709 - Computer Networks (CN) 8\n"
  },
  {
    "page_number": 9,
    "content": "eo\n| Dar. sh qn 1 — Introduction to Computer Networks & Internet\n\nInstitute of Engineering & Technology\n\nConnectionless method\ne Connectionless communication is just packet switching where no call establishment and release\noccur.\ne A message is broken into packets, and each packet is transferred separately. Moreover, the\npackets can travel a different route to the destination since there is no connection.\ne Connectionless service is typically provided by the UDP (User Datagram Protocol). The packets\n\ntransferred using UDP are also called datagrams.\nA Virtual Circuit\n\n{a} Connectionless Network {b) Connection-Oriented Network\n\nFeature Connectionless Connection-oriented\n\nHow is data sent? One packet at a time Continuous stream of packets\n\nDo packets follow the same route? No Virtual circuit: yes\nWithout virtual circuit: no\n\nAre resources reserved in the | No Virtual circuit: yes\n\nnetwork? Without virtual circuit: no\n\nAre resources reserved in No Yes\n\ncommunicating hosts?\n\nIs connection establishment done? No Yes\n\nIs state information stored at No Virtual circuit: yes\n\nnetwork nodes? Without virtual circuit: no\n\nWhat is the impact of node/switch Only packets at a node All virtual circuits through node fail\n\ncrash? are lost\n\nWhat addressing information is Full source and Virtual circuit: virtual circuit number\n\nneeded on each packet? destination address Without virtual circuit: full source and\ndestination address\n\nProf. Maulik Trivedi, CE Department | 2140709 - Computer Networks (CN) 9\n"
  },
  {
    "page_number": 10,
    "content": "D Darshan\n\niaieniee Of Enginearting sl Techootiny 1 — Introduction to Computer Networks & Internet\n\nTransmission Media\n\ne Atransmission media can be defined as anything that can carry information from a source to a\ndestination.\n\ne On the basis of transmission of data, the transmission media can be classified into two\ncategories:\n1. Guided (Physical) transmission media\n2. Unguided (Wireless) transmission media\n\nTransmission Media\n\nGuided Media\n\nUnguided Media\n\nTwisted-Pair Coaxial Fiber Optic Radio Microwave Infrared\nCable Cable Cable Wave\n\nWave\n\nFigure 8: Classification Transmission Media\n\nGuided Transmission Media\ne Guided media are those that provide a channel from one device to another.\ne The three Guided (Physical) media commonly used for data transmission are:\n\n1. Twisted-Pair 2. Coaxial 3. Fiber Optics\n1. Twisted Pair\n\ne Atwisted pair consists of two insulated copper wires, typically about 1 mm thick.\ne The wires are twisted together in a helical form, just like a DNA molecule.\ne Twisting is done because two parallel wires constitute a fine antenna.\n\ne When the wires are twisted, the waves from different twists cancel out, so the wire radiates less\neffectively.\n\nInsulator < SOCDOCK > Conductors\n\nFigure 9: Twisted Pair Cable\nWhy cable is twisted?\n\ne If the two wires are parallel, the effect of these unwanted signals is not the same in both wires\nbecause they are at different locations relatives to the noise or crosstalk sources.\ne This results in a difference at the receiver.\n\ne By twisting the pair, a balance is maintained.\n\nProf. Maulik Trivedi, CE Department | 2140709 — Computer Networks (CN) 10\n"
  },
  {
    "page_number": 11,
    "content": "D Darshan\n\nasesuée ot Encinaectug ak reohsokes 1 — Introduction to Computer Networks & Internet\n\nTypes of Twisted-Pair Cable\n\n1)\n\nUnshielded twisted-pair (UTP)\n\nTwisted pair cabling comes in several varieties, two of which are important for computer\nnetworks.\n\nCategory 3 twisted pairs consist of two insulated wires gently twisted together.\n\nMost office buildings had one category 3 cable running from a central wiring closet on each floor\ninto each office.\n\nCategory 5 is the more advanced twisted pairs were introduced.\n\nThey are similar to category 3 pairs, but with more twists per centimeter, which results in less\ncrosstalk and a better-quality signal over longer distances, making them more suitable for high-\nspeed computer communication.\n\nUp-and-coming categories are 6 and 7, which are capable of handling signals with bandwidths of\n250 MHz and 600 MHz, respectively (versus a mere 16 MHz and 100 MHz for categories 3 and 5\nrespectively).\n\nCategory 3 UTP. Category 5 UTP.\n\nFigure 10: Unshielded twisted-pair\n\nShielded twisted-pair (STP).\nSTP cable has a metal foil or braided mesh covering that encases each pair of insulated\nconductors.\nMetal casing improves the quality of cable by preventing the penetration of noise or crosstalk.\nIt is bulkier and more expensive.\nApplications:\n> Used in telephone lines to provide voice and data channels.\n> The DSL lines use by telephone companies use the high-bandwidth capability of UTP\ncables.\n> LANs, such as 10Base-T, 100Base-T also uses twisted-pair cables.\n\n2. Coaxial Cable\n\nIt has better shielding than twisted pairs, so it can span longer distances at higher speeds.\n\nTwo kinds of the coaxial cable are widely used. One kind is a 50-ohm cable which is commonly\nused when it is intended for digital transmission from the start.\n\nThe other kind is a 75-ohm cable which is commonly used for analog transmission and cable\ntelevision but is becoming more important with the advent of the Internet over cable.\n\nA coaxial cable consists of stiff copper wire as the core surrounded by an insulating material.\n\nThe insulator is encased by a cylindrical conductor, often as a closely-woven braided mesh.\n\nThe outer conductor is covered in a protective plastic sheath.\n\nThe construction and shielding of the coaxial cable give it a good combination of high bandwidth\nand excellent noise immunity.\n\nThe bandwidth possible depends on the cable quality, length, and signal-to-noise ratio of the\ndata signal. Modern cables have a bandwidth of close to 1 GHz.\n\nProf. Maulik Trivedi, CE Department | 2140709 — Computer Networks (CN) 11\n"
  },
  {
    "page_number": 12,
    "content": "J\n| Darsh an 1 — Introduction to Computer Networks & Internet\n\ne Coaxial cables used is widely used within the telephone system for long-distance lines but have\nnow largely been replaced by fiber optics on long-haul routes.\n\nCopper Insulating Braided Protective\nmaterial outer plastic\nconductor covering\n\n\\ NESTS STE STN\nDOO OA AX 4\n\nFigure 11: Coaxial Cable\n3. Fiber Optics\ne A fiber-optic cable is made of glass or plastic and transmits signals in the form of light.\ne Optical fibers use reflection to guide light through a channel.\ne  Aglass or plastic core is surrounded by a cladding of less dense glass or plastic.\ne The difference in density of the two materials must be such that a beam of light moving through\nacore is reflected off the cladding instead of being refracted into it.\n\nSheath ~“ Jacket\nCore\n\\\n\nCladding Jacket\n(glass) (plastic) Core Cladding\n(a) (b)\n\nFigure 12: Fiber Optic Cable\n\ne Fiber optic cables are similar to coax, except without the braid.\ne The figure shows a single fiber viewed from the side. At the center is the glass core through\nwhich the light propagates.\ne The core is surrounded by a glass cladding with a lower index of refraction than the core, to keep\nall the light in the core.\ne Next comes a thin plastic jacket to protect the cladding. Fibers are typically grouped in bundles,\nprotected by an outer sheath. The figure shows a sheath with three fibers.\nUnguided (Wireless) transmission media\ne Unguided media transport electromagnetic waves without using a physical conductor. This type\nof communication is often referred to as wireless communication.\n1. Radio Transmission 3. Infrared\n2. Microwave Transmission 4. Lightwave Transmission\n\nProf. Maulik Trivedi, CE Department | 2140709 — Computer Networks (CN) 12\n"
  },
  {
    "page_number": 13,
    "content": "D Darshan\n\niaieniee Of Enginearting sl Techootiny 1 — Introduction to Computer Networks & Internet\n\n1. Radio Transmission\n\ne Radio waves are easy to generate, can travel long distances, and can penetrate buildings easily,\nso they are widely used for communication, both indoors and outdoors.\n\ne Radio waves also are omnidirectional, meaning that they travel in all directions from the source,\nso the transmitter and receiver do not have to be carefully aligned physically.\n\ne The properties of radio waves are frequency dependent.\n\ne At low frequencies, radio waves pass through obstacles well, but the power falls off sharply with\ndistance from the source, roughly as 1/r’ in the air.\n\ne At high frequencies, radio waves tend to travel in straight lines and bounce off obstacles. They\nare also absorbed by rain.\n\ne At all frequencies, radio waves are subject to interference from motors and other electrical\nequipment.\n\nNie?\n<<\n\nV\n\nEarth's surface\nFigure 13: Ground wave\ne Inthe VLF, LF, and MF bands, radio waves follow the curvature of the earth.\ne Inthe HF they bounce off the ionosphere.\n2. Microwave Transmission\n\ne Since the microwaves travel in a straight line, if the towers are too far apart, the earth will get in\nthe way. Consequently, repeaters are needed periodically.\n\ne Unlike radio waves at lower frequencies, microwaves do not pass through buildings well. In\naddition, even though the beam may be well focused at the transmitter, there is still some\ndivergence in space.\n\ne Above 100 MHz, the waves travel in straight lines and can, therefore, be narrowly focused.\nConcentrating all the energy into a small beam using a parabolic antenna gives a much higher\nsignal to noise ratio.\n\ne Advantages:\n\n> No right way is needed (compared to wired media).\n> Relatively inexpensive.\n> Simple to install.\ne Disadvantages:\nDo not pass through buildings well.\nMultipath fading problem (the delayed waves cancel the signal).\nAbsorption by rain above 8 GHz.\nA severe shortage of spectrum.\n\nVVVV\n\n3. Infrared\ne Unguided infrared and millimetre waves are widely used for short-range communication.\ne The remote controls used on televisions, VCRs, and stereos all use infrared communication.\n\nProf. Maulik Trivedi, CE Department | 2140709 — Computer Networks (CN) 13\n"
  },
  {
    "page_number": 14,
    "content": "e\n| Dar. sh an 1 - Introduction to Computer Networks & Internet\n\nInstitute of Engineering & Technology\n\n“» remote control\n\nFigure 14: Infrared wave connection\n\ne They are relatively directional, cheap, and easy to build but have a major drawback: they do not\npass through solid objects (try standing between your remote control and your television and\nsee if it still works).\n\ne In general, as we go from long-wave radio toward visible light, the waves behave more and more\nlike light and less and less like a radio.\n\ne On the other hand, the fact that infrared waves do not pass through solid walls well is also a\nplus.\n\ne It means that an infrared system in one room of a building will not interfere with a similar\nsystem in adjacent rooms or buildings.\n\ne Furthermore, security of infrared systems against eavesdropping is better than that of radio\nsystems precisely for this reason.\n\ne Therefore, no government license is needed to operate an infrared system, in contrast to radio\nsystems, which must be licensed outside the ISM bands.\n\nTopologies (Network Topologies)\nNetwork Topology is the schematic description of a network arrangement, connecting various\nnodes (sender and receiver) through lines of connection.\ne A Network Topology is the arrangement with which computer systems or network devices are\nconnected to each other.\ne Types of network topologies :\n\n1. Bus 3. Star 5. Tree\n2. Ring 4. Mesh 6. Hybrid\nBus Topology\ne Bus topology is a network type in which every computer and network device is connected to a\nsingle cable.\nCable End Cable End\n\n| Drop Line | Drop Line | Drop Line\n\nProf. Maulik Trivedi, CE Department | 2140709 - Computer Networks (CN) 14\n"
  },
  {
    "page_number": 15,
    "content": "2°\n| Darsh an 1 — Introduction to Computer Networks & Internet\n\nFeatures:\ne It transmits data only in one direction.\ne Every device is connected to a single cable.\nAdvantages:\ne It is cost effective (cheaper).\ne Cable required is least compared to other network topology.\ne Used in small networks.\ne It is easy to understand.\ne Easy to expand joining two cables together.\nDisadvantages:\ne Cables fail then the whole network fails.\ne If network traffic is heavy or nodes are more the performance of the network decreases.\ne Cable has a limited length.\nRing Topology\ne It is called ring topology because it forms a ring as each computer is connected to another\ncomputer, with the last one connected to the first. Exactly two neighbors for each device.\n\n=\nae\n= x\n\\\nZ \\\nFi i\nyf \\\nx Ring Topology a4\n<a 1\n\n=\n\n7 mS. 7\n\n™~ Re\ni a“\n™ “\nBo “\nbe a“\n™~ rs\n“ EI e\n= a\n~\nS—\naa\n\nFeatures:\ne Anumber of repeaters are used and the transmission is unidirectional.\ne Adiate is transferred in a sequential manner that is bitten by bit.\nAdvantages:\ne Transmitting network is not affected by high traffic or by adding more nodes, as only the nodes\nhaving tokens can transmit data.\ne Cheap to install and expand.\nDisadvantages:\ne Troubleshooting is difficult in a ring topology.\ne Adding or deleting the computers disturbs the network activity.\ne Failure of one computer disturbs the whole network.\nStar Topology\ne In this type of topology, all the computers are connected to a single hub through a cable. This\nhub is the central node and all others nodes are connected to the central node.\n\nProf. Maulik Trivedi, CE Department | 2140709 — Computer Networks (CN) 15\n"
  },
  {
    "page_number": 16,
    "content": "| <d Darsh an 1 — Introduction to Computer Networks & Internet\n\nFeatures:\ne Every node has its own dedicated connection to the hub.\ne Acts as a repeater for data flow.\ne Can be used with twisted pair, Optical Fibre or coaxial cable.\nAdvantages:\ne Fast performance with few nodes and low network traffic.\ne Hub can be upgraded easily.\ne Easy to troubleshoot.\ne Easy to set up and modify.\ne Only that node is affected which has failed rest of the nodes can work smoothly.\nDisadvantages:\ne Cost of installation is high.\ne Expensive to use.\ne If the hub is affected then the whole network is stopped because all the nodes depend on the\nhub.\ne Performance is based on the.\nMesh Topology\ne It is a point-to-point connection to other nodes or devices.\ne Traffic is carried only between two devices or nodes to which it is connected.\n\nLI Oo\noa _\nSe wwe\n\neee oN\n\n———|\n—\nFeatures:\ne Fully connected.\ne Robust.\n\ne Not flexible.\n\nProf. Maulik Trivedi, CE Department | 2140709 — Computer Networks (CN) 16\n"
  },
  {
    "page_number": 17,
    "content": "e\n| Darsh an 1 - Introduction to Computer Networks & Internet\n\nInstitute of Engineering & Technology\n\nAdvantages:\ne Each connection can carry its own data load.\ne — Itis robust.\ne A fault is diagnosed easily.\ne Provides security and privacy.\nDisadvantages:\ne Installation and configuration are difficult.\ne Cabling cost is more.\ne = Bulk wiring is required.\nTree Topology\ne It has a root node and all other nodes are connected to it forming a hierarchy.\ne It is also called hierarchical topology.\ne It should at least have three levels to the hierarchy.\n\nFeatures:\ne Ideal if workstations are located in groups.\ne Used in Wide Area Network.\nAdvantages:\ne Extension of bus and star topologies.\ne Expansion of nodes is possible and easy.\ne Easily managed and maintained.\ne Error detection is easily done.\nDisadvantages:\ne Heavily cabled.\ne Costly.\ne If more nodes are added maintenance is difficult.\n\ne = Central hub fails then network fails.\nHybrid Topology\ne A network structure whose design contains more than one topology is said to be hybrid\ntopology.\n\nProf. Maulik Trivedi, CE Department | 2140709 — Computer Networks (CN) 17\n"
  },
  {
    "page_number": 18,
    "content": "® ™\n7.\n: D Darsh an 1 — Introduction to Computer Networks & Internet\n\nology\n\ne For example, if in an office in one department ring topology is used and in another star,\ntopology is used, connecting these topologies will result in Hybrid Topology (ring topology and\nstar topology).\n\nStar\n\nFeatures:\n\ne It is a combination of two or more topologies\n\ne Inherits the advantages and disadvantages of the topologies included\nAdvantages:\n\ne Reliable as error detecting and troubleshooting is easy.\n\ne Scalable as size can be increased easily.\n\ne Flexible.\nDisadvantages:\n\ne Complex in design.\n\ne Costly.\n\nThe Network Core\ne Network core defines the connection of different network segments together and the process to\ntransmit the data packets across the network.\ne The network core is implemented through the use of switching techniques.\ne = The classification of a switching network is shown below:\n\nProf. Maulik Trivedi, CE Department | 2140709 — Computer Networks (CN) 18\n"
  },
  {
    "page_number": 19,
    "content": "&) Darshan\n\nInstitute of Engineering & Technology\n\nCircuit-Switched\nNetworks\n\nCircuit Switching\n\n1 — Introduction to Computer Networks & Internet\n\nSwitched\nNetworks\n\nPacket-Switched Message-Switched\nNetworks Networks\n\nDatagram Virtual-Circuit\nNetworks Networks\n\ne Circuit switching is used in public telephone networks and is the basis for private networks built\n\non leased-lines.\n\ne = Circuit switching was developed to handle voice traffic but also digital data (although inefficient)\ne =With circuit switching a dedicated path is established between two stations for communication.\n\ne Switching and transmission resources within the network are reserved for the exclusive use of\nthe circuit for the duration of the connection.\ne The connection is transparent: once it is established, it appears to attach devices as if there\n\nwere a direct connection.\n\ne Communication via circuit switching involves three phases:\n\n1. Circuit Establishment\n2. Data Transfer\n3. Circuit Disconnect\n\nTotal delay\n\noo\n\nDisconnect\n\nData transfer\n\nTime Time Time Time\n\nProf. Maulik Trivedi, CE Department | 2140709 — Computer Networks (CN) 19\n"
  },
  {
    "page_number": 20,
    "content": "D Darshan\n\niaehhe Of Snaineurtng ad Tochiseleny 1 — Introduction to Computer Networks & Internet\n\ne Connection path must be established before data transmission begins. Nodes must have\nswitching capacity and channel capacity to establish a connection.\n\ne = Circuit switching is inefficient\n\n1. Channel capacity dedicated for a duration of a connection\n\n2. If no data, capacity wasted\ne Set up (connection) takes time\ne Once connected, a transfer is transparent to the users\n\n1. Data is transmitted at a fixed data rate with no delay (except for the propagation delay)\ne Developed for voice traffic (phone)\n\n1. May also be used for data traffic via modem\n\ne Interconnection of telephones within a building or office.\n\ne In circuit switching, a direct physical connection between two devices is created by space-\ndivision switches, time-division switches, or both OR Circuit switching use any of below two\ntechnologies:\n\nSpace Division Switching\n\ne Ina space-division switch, the path from one device to another is spatially separate from other\npaths.\n\ne Developed for the analogue environment.\n\ne Acrossbar is the most common space-division switch. It connects n inputs to m outputs via n x\nm cross points.\n\ne Crossbar switch.\n\nTo control station\n\n20\n\nCrossbar Switch\n| il mow\n\nFigure 15: Space Division Switching\nTime Division Switching\ne Ina time-division switch, the inputs are divided in time, using TDM. A control unit sends the\n\ninput to the correct output device.\ne Use digital time division techniques to set up and maintain virtual circuits.\n\nProf. Maulik Trivedi, CE Department | 2140709 — Computer Networks (CN) 20\n"
  },
  {
    "page_number": 21,
    "content": "e\nDar. sh an 1 - Introduction to Computer Networks & Internet\n\nInstitute of Engineering & Technology\n\n* Switching Techniques:\n* TSI (Time Slot\n\nInterchange)\n* TST (Time\nSpace Time)\n* TDM Bus\nb. Switching\nFigure 16: Time Division Switching\nPacket Switching\n\nPacket switching was designed to provide a more efficient facility than circuit-switching for burst\ndata traffic.\nWith packet switching, a station transmits data in small blocks, called packets.\nAt each node, packets are received, stored briefly (buffered) and passed on to the next node.\n1. Store and forward mechanism\nEach packet contains some portion of the user data plus control info needed for proper\nfunctioning of the network.\nA key element of packet-switching networks is whether the internal operation is datagram or\nvirtual circuit (VC).\n1. With internal VCs, a route is defined between two endpoints and all packets for that VC\nfollow the same route.\n2. With internal diagrams, each packet is treated independently, and packets intended for\nthe same destination may follow different routes.\nExamples of packet switching networks are X.25, Frame Relay, ATM and IP.\nStation breaks a long message into packets. Packets sent one at a time to the network.\nPackets handled in two ways:\n1. Datagram\n= Each packet treated independently\n= Packets can take any practical route\n= Packets may arrive out of order\n= Packets may go missing\n= Up to receiver to re-order packets and recover from missing packets\n2. Virtual Circuit\n= Pre-planned route established before any packets sent.\n\nProf. Maulik Trivedi, CE Department | 2140709 — Computer Networks (CN) 21\n"
  },
  {
    "page_number": 22,
    "content": "e\n| Dar. sh qn 1 — Introduction to Computer Networks & Internet\n\nInstitute of Engineering & Technology\n\n= Once the route is established, all the packets between the two communicating\nparties follow the same route through the network\n\n= Call request and call accept packets to establish a connection (handshake)\n\n=\" Each packet contains a Virtual Circuit Identifier (VCI) instead of a destination\naddress\n\n= No routing decisions required for each packet\n\n= Clear request to drop circuit\n\n= Not a dedicated path\n\nMessage Switching\n\ne This technique was somewhere in the middle of circuit switching and packet switching.\n\ne In message switching, the whole message is treated as a data unit and is transferred in its\nentirety.\n\ne A switch working on message switching first receives the whole message and buffers it until\nthere are resources available to transfer it to the next hop.\n\ne If the next hop is not having enough resource to accommodate large size message, the message\nis stored and switch waits.\n\nProtocols layers and their service model\n\nOSI Layer Architecture\n\ne OSI model is based on a proposal developed by the International Standards Organization (ISO) as\nthe first step toward international standardization of the protocols used in the various layers.\n\ne It was revised in 1995.\n\ne The model is called the OSI (Open Systems Interconnection) Reference Model because it deals\nwith connecting open systems—that is, systems that are open for communication with other\nsystems.\n\ne The OSI model has seven layers.\n\n1. Physical Layer\nData Link Layer\nNetwork Layer\nTransport Layer\nSession Layer\nPresentation Layer\nApplication Layer\n\nNOUR WN\n\nProf. Maulik Trivedi, CE Department | 2140709 — Computer Networks (CN) 22\n"
  },
  {
    "page_number": 23,
    "content": "CD Darshan\n\nasesuée ot Encinaectug ak reohsokes 1 — Introduction to Computer Networks & Internet\n\nLayer Name of unit\nexchanged\nae Application protocol ae:\n7 Application |~------------------------------------ =| Application | APDU\nr r\nInterface |\n6 | Presentation |}~----------- RBS ONtA NON PIO CON nee *| Presentation | PPDU\nry A\ny Bedi y\n5 Session ct LL =| Session SPDU\n\nCommunication subnet boundary\n\nTransport TPDU\n\nY Internal subnet protocol\n\nESS\n4\n=\n»\n=|\na\nZU\n°\n=\n4\n=|\n2\n=]\na\nue]\n°\na\na\n°\n~\nQ\nQ\n2\nY\n< -\n\n3 Network Je-3 | Network 2 Network |- --*| Network | Packet\n’ ry\ny y\n\n2 Data link _- Data link |. Datalink j|«+--»| Datalink Frame\nry ry\ny y\n\n1 Physical |~, Physical J=——te Physical | --*| Physical | Bit\n\nHost A Router Router Host B\n\nNetwork layer host-router protocol\nData link layer host-router protocol\nPhysical layer host-router protocol\n\nFigure 17: OSI Reference Model\n\nPhysical Layer\n\ne The physical layer, the lowest layer of the OSI model, is concerned with the transmission and\nreception of the unstructured raw bit stream over a physical medium.\n\ne It describes the electrical/optical, mechanical, and functional interfaces to the physical medium,\nand carries the signals for all of the higher layers. It provides:\n\ne Data encoding: modifies the simple digital signal pattern (1s and Os) used by the PC to better\naccommodate the characteristics of the physical medium, and to aid in a bit and frame\nsynchronization.\n\ne Transmission technique: determines whether the encoded bits will be transmitted by baseband\n(digital) or broadband (analog) signalling.\n\ne Physical medium transmission: transmits bits as electrical or optical signals appropriate for the\nphysical medium.\n\nProf. Maulik Trivedi, CE Department | 2140709 — Computer Networks (CN) 23\n"
  },
  {
    "page_number": 24,
    "content": "D Darshan\n\nasesuée ot Encinaectug ak reohsokes 1 — Introduction to Computer Networks & Internet\n\nData link Layer\n\nThe data link layer provides error-free transfer of data frames from one node to another over\nthe physical layer, allowing layers above it to assume virtually error-free transmission over the\nlink.\n\nTo do this, the data link layer provides:\n\nLink establishment and termination: establishes and terminates the logical link between two\nnodes.\n\nFrame traffic control: tells the transmitting node to \"back-off\" (stop) when no frame buffers are\navailable.\n\nFrame sequencing: transmits/receives frames sequentially.\n\nFrame acknowledgment: provides/expects frame acknowledgments. Detects and recovers from\nerrors that occur in the physical layer by retransmitting non-acknowledged frames and handling\nduplicate frame receipt.\n\nFrame delimiting: creates and recognizes frame boundaries.\n\nFrame error checking: checks received frames for integrity.\n\nMedia access management: determines when the node \"has the right\" to use the physical\nmedium.\n\nNetwork Layer\n\nThe network layer controls the operation of the subnet, deciding which physical path the data\nshould take based on network conditions, a priority of service, and other factors.\n\nTo do this, the data link layer provides:\n\nRouting: routes frames among networks.\n\nSubnet traffic control: routers (network layer intermediate systems) can instruct a sending\nstation to \"throttle back\" its frame transmission when the router's buffer fills up.\n\nFrame fragmentation: if it determines that a downstream router's maximum transmission unit\n(MTU) size is less than the frame size, a router can fragment a frame for transmission and re-\nassembly at the destination station.\n\nLogical-physical address mapping translates logical addresses or names, into physical addresses.\nSubnet usage accounting: has accounting functions to keep track of frames forwarded by\nsubnet intermediate systems, to produce billing information.\n\nTransport Layer\n\nThe transport layer ensures that messages are delivered error-free, in sequence, and with no\nlosses or duplications. It relieves (release) the higher layer protocols from any concern with the\ntransfer of data between them and their peers.\n\nThe size and complexity of a transport protocol depend on the type of service it can get from the\nnetwork layer. For a reliable network layer with virtual circuit capability, a minimal transport\nlayer is required. If the network layer is unreliable and/or only supports datagrams, the\ntransport protocol should include extensive error detection and recovery.\n\nThe transport layer provides:\n\nMessage segmentation: accepts a message from the (session) layer above it, splits the message\ninto smaller units (if not already small enough), and passes the smaller units down to the\nnetwork layer. The transport layer at the destination station reassembles the message.\n\nMessage acknowledgment: provides reliable end-to-end message delivery with\nacknowledgments.\n\nProf. Maulik Trivedi, CE Department | 2140709 - Computer Networks (CN) 24\n"
  },
  {
    "page_number": 25,
    "content": "eo\n| Dar. sh qn 1 — Introduction to Computer Networks & Internet\n\nInstitute of Engineering & Technology\n\nMessage traffic control: tells the transmitting station to \"back-off\" when no message buffers are\navailable.\n\nTypically, the transport layer can accept relatively large messages, but there are strict message\nsize limits imposed by the network (or lower) layer. Consequently, the transport layer must\nbreak up the messages into smaller units, or frames, prepending a header to each frame.\n\nThe transport layer header information must then include control information, such as message\nstart and message end flags, to enable the transport layer on the other end to recognize\nmessage boundaries.\n\nIn addition, if the lower layers do not maintain sequence, the transport header must contain\nsequence information to enable the transport layer on the receiving end to get the pieces back\ntogether in the right order before handing the received message up to the layer above.\n\nSession Layer\n\nThe session layer allows session establishment between processes running on different stations.\nIt provides:\n\nSession establishment, maintenance, and termination: allows two application processes on\ndifferent machines to establish, use and terminate a connection, called a session.\n\nSession support: performs the functions that allow these processes to communicate over the\nnetwork, performing security, name recognition, logging, and so on.\n\nPresentation Layer\n\nThe presentation layer formats the data to be presented to the application layer. It can be\nviewed as the translator for the network. This layer may translate data from a format used by\nthe application layer into a common format at the sending station, then translate the common\nformat to a format known to the application layer at the receiving station.\n\nThe presentation layer provides:\n\nCharacter code translation: for example, ASCII to EBCDIC.\n\nData conversion: bit order, CR-CR/LF, integer-floating point, and so on.\n\nData compression reduces the number of bits that need to be transmitted on the network.\n\nData encryption: encrypt data for security purposes. For example, password encryption.\n\nApplication Layer\n\nThe application layer serves as the window for users and application processes to access\n\nnetwork services.\n\nThis layer contains a variety of commonly needed functions:\n1. Resource sharing and device redirection\n\nRemote file access\n\nRemote printer access\n\nInter-process communication\n\nNetwork management\n\nDirectory services\n\nElectronic messaging (such as mail)\n\n8 Network virtual terminals\n\nNOUR WN\n\nTCP/IP Reference Model (Internet Protocol Stack layers)\n\nTransmission Control Protocol/Internet Protocol (TCP/IP) protocol suite is the engine for the\nInternet and networks worldwide.\nTCP/IP either combines several OSI layers into a single layer or does not use certain layers at all.\n\nProf. Maulik Trivedi, CE Department | 2140709 — Computer Networks (CN) 25\n"
  },
  {
    "page_number": 26,
    "content": "DD Var nee rshan 1 — Introduction to Computer Networks & Internet\n\ne TCP/IP is a set of protocols developed to allow cooperating computers to share resources across\nthe network.\ne The TCP/IP model has five layers.\n1. Application Layer\n2. Transport Layer\n3. Internet Layer\n4. Data Link Layer\n5. Physical Network\n\nTCP/IP model Protocols and services OSI model\n\nHTTP, FTTP, ene ean\nApplication Telnet, NTP,\nDHCP, PING\n\n[_Trenspot_J cP, uoP Transport\nIP, ARP, ICMP, ICMP Network\n\nSsssceeeteeeeeseettesssstssnnenennsenee Data Link\nPhysical\n\nNetwork\nona Ethernet\n\nInterface\n\nFigure 18: TCP/IP Reference Model\n\ne As we can see from the above figure, the presentation and session layers are not there in the\nTCP/IP model. Also, note that the Network Access Layer in the TCP/IP model combines the\nfunctions of Data link Layer and Physical Layer.\n\nApplication Layer\n\ne The application layer is the topmost layer of the four-layer TCP/IP model.\n\ne The application layer is present on the top of the Transport layer.\n\ne Application layer defines TCP/IP application protocols and how host programs interface with\nTransport layer services to use the network.\n\ne Application layer includes all the higher-level protocols like DNS (Domain Naming System), HTTP\n(Hypertext Transfer Protocol), Telnet, SSH, FTP (File Transfer Protocol), TFTP (Trivial File Transfer\nProtocol), SNMP (Simple Network Management Protocol), SMTP (Simple Mail Transfer Protocol),\nDHCP (Dynamic Host Configuration Protocol), X Windows, RDP (Remote Desktop Protocol) etc.\n\nTransport Layer\n\ne The purpose of the Transport layer is to permit devices on the source and destination hosts to\ncarry on a conversation.\n\nProf. Maulik Trivedi, CE Department | 2140709 — Computer Networks (CN) 26\n"
  },
  {
    "page_number": 27,
    "content": "eo\n| Dar. sh qn 1 — Introduction to Computer Networks & Internet\n\nInstitute of Engineering & Technology\n\nTransport layer defines the level of service and status of the connection used when transporting\ndata.\n\nThe transport layer provides the end-to-end data transfer by delivering data from an application\nto its remote peer.\n\ne The most-used transport layer protocol is the Transmission Control Protocol (TCP), which\n\nprovides:\n> Reliable delivery data > Congestion control\n> Duplicate data suppression > Flow control\ne Another transport layer protocol is the User Datagram Protocol (UDP), which provides:\n> Connectionless > Best-effort service\n\n\\\n\n> Unreliable\n\ne UDP is used by applications that need a fast transport mechanism and can tolerate the loss of\nsome data.\n\nNetwork Layer (Internet Layer)\n\ne The internet layer also called the network layer.\n\ne Internet layer pack data into data packets known as IP datagrams, which contain source and\ndestination address (logical address or IP address) information that is used to forward the\ndatagrams between hosts and across networks.\n\ne The Internet layer is also responsible for the routing of IP datagrams.\n\ne Internet Protocol (IP) is the most important protocol in this layer.\n\ne It is a connectionless protocol that does not assume reliability from lower layers. IP does not\nprovide reliability, flow control or error recovery.\n\ne IP provides a routing function that attempts to deliver transmitted messages to their\n\ndestination.\n\ne These message units in an IP network are called an IP datagram.\n\ne Example: IP, ICMP, IGMP, ARP, and RARP.\n\nNetwork Interface Layer (Network Access Layer)\n\ne Network Access Layer defines details of how data is physically sent through the network,\nincluding how bits are electrically or optically signalled by hardware devices that interface\ndirectly with a network medium, such as coaxial cable, optical fiber, or twisted pair copper wire.\n\ne The protocols included in Network Access Layer are Ethernet, Token Ring, FDDI, X.25, Frame\nRelay etc.\n\nTCP/IP (Transmission Control Protocol /\n\nOSI (Open System Interconnection) Internet Protocol)\n\ne It has 7 layers e Ithas 4 layers\ne OSI provides layer functioning and also defines | e TCP/IP model is more based on protocols\nfunctions of all the layers. and protocols are not flexible with other\nlayers.\ne Inthe OSI model, the transport layer e Inthe TCP/IP model, the transport layer\nguarantees the delivery of packets does not guarantee delivery of packets.\ne Follows horizontal approach e Follows a vertical approach.\ne OSI model has a separate presentation layer e TCP/IP doesn’t have a separate presentation\nlayer\n\nProf. Maulik Trivedi, CE Department | 2140709 — Computer Networks (CN) 27\n"
  },
  {
    "page_number": 28,
    "content": "D Darshan\n\niaehhe Of Snaineurtng ad Tochiseleny 1 — Introduction to Computer Networks & Internet\n\ne OSI is a general model. e TCP/IP model cannot be used in any other\napplication.\ne The network layer of the OSI model provides e The Network layer in the TCP/IP model\nboth connection-oriented and connectionless provides connectionless service.\nservice.\ne OSI model has a problem of fitting the e TCP/IP model does not fit any protocol\n\nprotocols in the model\ne Protocols are hidden in the OSI model and are e In TCP/IP replacing protocol is not easy.\neasily replaced as the technology changes.\ne OSI model defines services, interfaces, and e In TCP/IP, it is not clearly separated its\nprotocols very clearly and makes a clear services, interfaces, and protocols.\ndistinction between them.\n\nUnderstanding of Delay, Loss, and Throughput in the Packet Switching\nNetwork\n\nBasics\n= Recall that a packet starts in a host (the source), passes through a series of routers, and ends its\njourney in another host (the destination).\n= As a packet travels from one node (host or router) to the subsequent node (host or router)\nalong this path, the packet suffers from several types of delays at each node along the path.\n= The most important of these delays are the\n> Nodal processing delay > Transmission delay\n> Queuing delay > Propagation delay\n= Together, these delays accumulate to give a total nodal delay.\n= The performance of many Internet applications—such as search, Web browsing, email, maps,\ninstant messaging, and voice-over-IP—are greatly affected by network delays.\n\nB\n\nPaes\n\n—f\n\nT\nPropagation\n\nNodal Queueing Transmission\nprocessing (waiting for\ntransmission)\n\nFigure 19: Delay in Packet Switched Network\n\nProcessing Delay\ne The time required to examine the packet’s header and determine where to direct the packet is\npart of the processing delay.\n\nProf. Maulik Trivedi, CE Department | 2140709 — Computer Networks (CN) 28\n"
  },
  {
    "page_number": 29,
    "content": "eo\n| Dar. sh qn 1 — Introduction to Computer Networks & Internet\n\nInstitute of Engineering & Technology\n\nThe processing delay can also include other factors, such as the time needed to check for bit-\nlevel errors in the packet that occurred in transmitting the packet's bits from the upstream node\nto the router.\n\nIt is typically on the order of microseconds or less.\n\nQueuing Delay\n\nAt the queue, the packet experiences a queuing delay as it waits to be transmitted onto the link.\nThe length of the queuing delay of a specific packet will depend on the number of earlier-\narriving packets that are queued and waiting for transmission onto the link.\n\nIf the queue is empty and no other packet is currently being transmitted, then our packet’s\nqueuing delay will be zero.\n\nOn the other hand, if the traffic is heavy and many other packets are also waiting to be\ntransmitted, the queuing delay will be long.\n\nQueuing delays can be on the order of microseconds to milliseconds in practice.\n\nTransmission Delay\n\nAssuming that packets are transmitted in a first-come-first-served manner like packet-switched\nnetworks.\n\nNow packet can be transmitted only after all the packets that have arrived before it have been\ntransmitted.\n\nDenote the length of the packet by L bits, and denote the transmission rate of the link from a\nrouter to a router by R bits/sec.\n\nThe transmission delay is L/R.\n\nTransmission delays are typically on the order of microseconds to milliseconds in practice.\n\nPropagation Delay\n\nPacke\n\nOnce a bit is pushed into the link, it needs to propagate to router B. The time required to\npropagate from the beginning of the link to router B is the propagation delay.\n\nThe bit propagates at the propagation speed of the link.\n\nThe propagation speed depends on the physical medium of the link.\n\nPropagation delays are on the order of milliseconds.\n\nPropagations delay=d (Length of Physical Link) /s (Propagation speed in medium).\n\nt Loss\n\nPacket loss is the failure of one or more transmitted packets to arrive at their destination.\n\nThis event can cause noticeable effects on all types of digital communications.\n\nThe loss of data packets depends on the switch queue. The loss of data packets increases with\nthe increases in the traffic intensity.\n\nIt affects the performance of the network.\n\nThroughput\n\nThroughput or Network Throughput is the rate of successful message delivery over a\ncommunication channel.\n\nThe data these messages belong to may be delivered over a physical or logical link or it can pass\nthrough a certain network node.\n\nThroughput is usually measured in bits per second (bit/s or bps), and sometimes in data packets\nper second (p/s or pps) or data packets per time slot.\n\nProf. Maulik Trivedi, CE Department | 2140709 — Computer Networks (CN) 29\n"
  },
  {
    "page_number": 30,
    "content": "eo\nDarsh qn 1 — Introduction to Computer Networks & Internet\n\nProblem:\n\nIn this problem, we consider sending real-time voice from Host A to Host B over a packet-\nswitched network (VoIP). Host A converts analog voice to a digital 64 kbps bit stream on the\nfly. Host A then groups the bits into 56-byte packets. There is one link between Hosts A and\nB; its transmission rate is 2 Mbps and its propagation delay is 10 msec. As soon as Host A\ngathers a packet, it sends it to Host B. As soon as Host B receives an entire packet, it converts\nthe packet's bits to an analog signal. How much time elapses from the time a bit is created\n(from the original analog signal at Host A) until the bit is decoded (as part of the analog\nsignal at Host B)?\n\nHost A rH Host B\n\nGiven:\n\nAnalog to Digital conversion rate = 64 kbps\n\nPacket size = 56 bytes (Convert into bits so 56 bytes = 56 * 8 = 448 bits).\nTransmission rate = 2 Mbps\n\nPropagation delay = 10 msec\n\nVVVV\n\ne Since this is a packet switched network, the data will be transmitted packet by packet.\n\ne A packet is 56 byte and the analog to digital conversation rate is 64 kbps, thus the preparing\ntime\nPT for a packet is 448/(64*1000)= 0.007 sec = 7 msec\n\ne The transition delay TD for a packet is (Size or Length of packet) / (Speed or Transmission rate)\nSo, TD = (56*8) / (2*1000*1000) =0.000224 s = 0.224msec.\n\ne Propagation delay PD = 10msec (Given in sum)\n\ne Finally, the total time elapses from the time a bit is create until the bit is decoded is PT+TD+PD=\n7+0.224+10 = 17.224 msec.\n\nProf. Maulik Trivedi, CE Department | 2140709 — Computer Networks (CN) 30\n"
  },
  {
    "page_number": 31,
    "content": "eo\nDarshan 2 - Application Layer\n\nNetwork Applications OR\n\nPrinciples of Network Applications\n\ne A Network application is an application running on one host and _ provides\ncommunication to another application running on a different host.\n\ne At the core of network application development is writing programs that run on\ndifferent end systems and communicate with each other over the network.\n\ne In the Web application, there are two distinct programs that communicate with each\nother: the browser program running in the user's host; and the Web server program\nrunning in the Web server host.\n\ne Examples of network applications are\n\ne-mail\n\nweb\n\ntext messaging\n\nremote login\n\nP2P file sharing\n\nmulti-user network games\nstreaming stored video (YouTube)\nvoice over IP (e.g., Skype)\nreal-time video conferencing\nsocial networking\n\nNetwork Application Architectures\n\nNetwork Application Architectures\n\ne There are two possible structure of applications\n1. Client-Server architecture\n2. P2P (Peer to Peer) architecture\n\nClient-Server architecture\n\ne Ina client-server architecture, there is an always-on host, called the server, which provides\nservices requested from many other hosts, called clients.\n\ne Aclassic example is the Web application for which an always-on Web server services requests\nfrom browsers running on client hosts. When a Web server receives a request for an object from\na client host, it responds by sending the requested object to the client host.\n\ne Note that with the client-server architecture, clients do not directly communicate with each\nother; for example, in the Web application, two browsers do not directly communicate with\neach other.\n\ne Another characteristic of the client-server architecture is that the server has a fixed, well-known\naddress, called an IP address. Because the server is always on, a client can always contact the\nserver by sending a packet to the server’s IP address.\n\ne Some of the better-known applications with client-server architecture include the Web, FTP,\nTelnet, and e-mail.\n\nP2P architecture\ne In P2P architecture, there is no dedicated server.\ne Pairs of hosts, called peers communicate directly with each other.\n\nVVVVVVVVV V\n\nMaulik Trivedi, CE Department | 2140709 — Computer Networks (CN) 1\n"
  },
  {
    "page_number": 32,
    "content": "D Darshan\n\nsasesinc OF ergntarng a Teasley 2 — Application Layer\n\nBecause the peers communicate without passing through a dedicated server, the architecture is\ncalled peer-to-peer.\nMany of today’s most popular and traffic-intensive applications are based on P2P architectures.\n\nClient-Server architecture P2P (Peer to Peer) architecture\n\nProcesses Communicating\nProcess\n\nA process is an instance of a program running on a computer or we can say that process is a\nprogram under execution.\n\nWhen processes are running on the same end system, they can communicate with each other\nwith interprocess communication, using rules that are governed by the end system’s operating\nsystem.\n\nProcesses on two different end systems communicate with each other by exchanging messages\nacross the computer network.\n\nA sending process creates and sends messages into the network; a receiving process receives\nthese messages and possibly responds by sending messages back.\n\nIn the context of a communication session between a pair of processes, the process that\ninitiates the communication is called the client. The process that waits to be contacted to begin\nthe session is the server.\n\nThe client is a process (program) that sends a message to a server process (program), requesting\nthat the server perform a task (service).\n\nA server is a process (program) that fulfills the client request by performing the task requested\nby the client. Server programs generally receive requests from client programs, execute it and\ndispatch responses to client requests.\n\nMaulik Trivedi, CE Department | 2140709 — Computer Networks (CN) 2\n"
  },
  {
    "page_number": 33,
    "content": "(D Darshan\n\nsasesinc OF ergntarng a Teasley 2 — Application Layer\n\nAn interface between the Process and the Computer Network\nOR Socket\n\ne Any message sent from one process to another must go through the underlying network.\n\ne A process sends messages into and receives messages from, the network through a software\ninterface called a socket.\n\ne Aprocess is similar to a house and its socket is similar to its door. When a process wants to send\na message to another process on another host, it shoves (passes) the message out its door\n(socket). This sending process assumes that there is a transportation infrastructure on the other\nside of its door that will transport the message to the door of the destination process. Once the\nmessage arrives at the destination host, the message passes through the receiving process’s\ndoor (socket), and the receiving process then acts on the message.\n\nHost or Host or\nserver server\n\nControlled __ _ a a _\\— Controtted\n\nby application | Process } , Process by application\ndeveloper Xs 4 J a a we developer\n\nControlled: TCP with TcPwith 7—— Controlled\nby operating buffers, . > buffers, by operating\nsystem variables internet variables system\n\nFig. 2 Application processes, sockets, and underlying transport protoco\n\nAddressing Processes\ne To identify the receiving process, two pieces of information need to be specified:\n1. the address of the host and\n2. an identifier that specifies the receiving process in the destination host.\n\ne On the Internet, the host is identified by its IP address.\n\ne AnIP address is a 32-bit that uniquely identify the host.\n\ne In addition to knowing the address of the host to which a message is destined, the sending\nprocess must also identify the receiving process (more specifically, the receiving socket) running\nin the host.\n\ne This information is needed because in general, a host could be running many network\napplications.\n\nTransport Services available to Applications\n\nReliable Data Transfer\ne Reliable data transfer is to guarantee that the data sent by one end of the application is\ndelivered correctly and completely to the other end of the application.\n\nMaulik Trivedi, CE Department | 2140709 — Computer Networks (CN) 3\n"
  },
  {
    "page_number": 34,
    "content": "Darshan\n\nInstitute of Engineering & Technology\n\n( |\n\ne If a protocol provides such a guaranteed data delivery service, it is said to provide reliable data\ntransfer.\n\ne One important service that a transport-layer protocol can potentially provide to an application is\nprocess-to-process reliable data transfer.\n\ne When a transport protocol provides this service, the sending process can just pass its data into\nthe socket and know with complete confidence that the data will arrive without errors at the\nreceiving process.\n\nThroughput\ne Throughput is the rate at which the sending process can deliver bits to the receiving process.\ne The transport protocol ensures that the available throughput is always at least r bits/sec.\nTiming\n\ne Atransport-layer protocol can also provide timing guarantees.\n\ne An example guarantee might be that every bit that the sender pumps into the socket arrives at\nthe receiver’s socket no more than 100 msec later. Such a service would be appealing to\ninteractive real-time applications, such as Internet telephony, virtual environments,\nteleconferencing, and multiplayer games, all of which require tight timing constraints on data\ndelivery in order to be effective.\n\nSecurity\n\ne Finally, a transport protocol can provide an application with one or more security services.\n\ne For example, in the sending host, a transport protocol can encrypt all data transmitted by the\nsending process, and in the receiving host, the transport-layer protocol can decrypt the data\nbefore delivering the data to the receiving process.\n\nDifference between TCP (Service) and UDP (Service)\n\n2 - Application Layer\n\nDescription TCP UDP\n\nFull Name Transmission Control Protocol User Datagram Protocol\n\nConnection TCP is a  connection-oriented | UDP is a connectionless protocol.\nprotocol.\n\nFunction A point to point connection is | A point to point connection is not\nestablished between client and | established before sending messages.\nserver before sending a message.\n\nUsage TCP is suited for applications that | UDP is suitable for applications that\nrequire high reliability, and | need a fast, efficient transmission,\ntransmission time is relatively less | such as games.\ncritical.\n\nReliability There is an absolute guarantee that | There is no guarantee that the\nthe data transferred remains intact | messages or packets sent would\nand arrives in the same order in | reach at all.\nwhich it was sent.\n\nUse by other protocols HTTP, HTTPs, FTP, SMTP, Telnet DNS, DHCP, SNMP, RIP, VOIP\n\nThe ordering of data | TCP rearranges data packets in the | UDP has no inherent order as all\n\npackets order specified. packets are independent of each\n\nother.\n\nMaulik Trivedi, CE Department | 2140709 — Computer Networks (CN) 4\n\n"
  },
  {
    "page_number": 35,
    "content": "D Dars\n\nInstitute of Engineering & Technology\n\n2 - Application Layer\n\nDescription\n\nTCP\n\nUDP\n\nSpeed of transfer\n\nThe speed for TCP is slower than\nUDP.\n\nUDP is faster because there is no\nerror-checking for packets.\n\nHeader Size\n\nTCP header size is 20 bytes\n\nUDP Header size is 8 bytes.\n\nData Flow Control\n\nTCP does Flow Control.\n\nUDP does not have an option for flow\ncontrol.\n\nError Checking\n\nTCP does error checking\n\nUDP does error checking, but no\nrecovery options.\n\nAcknowledgment\n\nAcknowledgment segments\n\nNo Acknowledgment\n\nHandshake SYN, SYN-ACK, ACK No handshake\nThe Web and HTTP\nWeb\n\ne A Web page consists of objects.\n\ne An object is simply a file - such as an HTML file, a JPEG image, a Java applet, or a video clip, that\nis addressable by a single URL.\n\ne Most Web pages consist of a base HTML file and several referenced objects.\n\ne For example, if a Web page contains HTML text and five JPEG images, then the Web page has six\nobjects: the base HTML file plus the five images.\n\ne The base HTML file references the other objects in the page with the objects’ URLs.\n\ne Each URL has two components: the hostname of the server that houses the object and the\nobject’s path name.\n\ne For example, the has\n\nURL “http://www.someSchool.edu/someDepartment/picture. gif”\n\n“www.someSchool.edu” is hostname and “/someDepartment/picture.gif” is a pathname.\nHTTP (HyperText Transfer Protocol)\ne HTTP is Web’s application layer protocol which defines how Web clients request Web pages\nfrom Web servers and how servers transfer Web pages to clients.\n\nServer running\nApache Web server\n\nPC running\nInternet Explorer\n\nLinux running\nFirefox\n\nFig. 3 HTTP request-response behavior\n\nMaulik Trivedi, CE Department | 2140709 — Computer Networks (CN) 5\n"
  },
  {
    "page_number": 36,
    "content": "J\n| Darshan 2 - Application Layer\n\nWhen a user requests a Web page (for example, clicks on a hyperlink), the browser sends HTTP\nrequest messages for the objects in the page to the server.\n\nThe server receives the requests and responds with HTTP response messages that contain the\nobjects.\n\nHTTP uses TCP as its underlying transport protocol.\n\nThe HTTP client first initiates a TCP connection with the server.\n\nOnce the connection is established, the browser and the server processes access TCP through\ntheir socket interfaces.\n\nHTTP follows client/server model\n\n> client: a browser that requests, receives, (using HTTP protocol) and \"displays\" Web objects\n> server: Web server sends (using HTTP protocol) objects in response to requests\n\nHTTP connection types\n\n1. Non-persistent HTTP\n\n2. Persistent HTTP\n\nNon-persistent HTTP\n\nA non-persistent connection is the one that is closed after the server sends the requested object\n\nto the client. In other words, the connection is used exactly for one request and one response.\n\nFor downloading multiple objects it required multiple connections.\n\nNon-persistent connections are the default mode for HTTP/1.0.\n\nsuppose a user enters URL: \"www.someSchool.edu/someDepartment/home.index\"\n\nAbove link contains text and references to 10 jpeg images.\n\nta. HTTP client initiates TCP\nconnection to HTTP server\n(process) at\nwww.someSchool.edu on port 80\n\nib. HTTP server at host\nwww.someSchool.edu waiting\n\nfor TCP connection at port 80.\n“accepts” connection, notifying\n2. HTTP client sends HTTP client\nrequest message (containing\nURL) into TCP connection 3. HTTP server receives request\nsocket. Message indicates message, forms response\nthat client wants object message containing requested\nsomeDepartment/home.index object, and sends message\n\n= into its socket\n\n_— 4. HTTP server closes TCP\n\nconnection.\n5. HTTP client receives response\nmessage containing html file,\ndisplays html. Parsing html\nfile, finds 10 referenced jpeg\nobjects\n\n6. Steps 1-5 repeated for each\nof 10 jpeg objects\n\nMaulik Trivedi, CE Department | 2140709 — Computer Networks (CN) 6\n"
  },
  {
    "page_number": 37,
    "content": "(D Darshan\n\nsasesinc OF ergntarng a Teasley 2 — Application Layer\n\n6.\n\nThe HTTP client process initiates a TCP connection to the server www.someSchool.edu\non port number 80, which is the default port number for HTTP. Associated with the TCP\nconnection, there will be a socket at the client and a socket at the server.\n\nThe HTTP client sends an HTTP request message to the server via its socket. The request\nmessage includes the path name /someDepartment/home.index.\n\nThe HTTP server process receives the request message via its socket, retrieves the\nobject /someDepartment/home.index from its storage (RAM or disk), encapsulates the\nobject in an HTTP response message, and sends the response message to the client via\nits socket.\n\nThe HTTP server process tells TCP to close the TCP connection. (But TCP doesn’t actually\nterminate the connection until it knows for sure that the client has received the\nresponse message intact.).\n\nThe HTTP client receives the response message. The TCP connection terminates. The\nmessage indicates that the encapsulated object is an HTML file. The client extracts the\nfile from the response message, examines the HTML file, and finds references to the 10\nJPEG objects.\n\nThe first four steps are then repeated for each of the referenced JPEG objects.\n\ne RTT (Round Trip Time) - which is the time it takes for a small packet to travel from client to\nserver and then back to the client.\n\nInitiate TCP\nconnection\n\nRIT\n\n\\l\n\nOT\n\nRIT ae\n_—\n\n‘+ Time to transmit file\n\nEntire file received\n\nTime Time\nat client at server\n\nFig. 4 Calculation for the time needed to request and receive an HTML file\n\nMaulik Trivedi, CE Department | 2140709 — Computer Networks (CN) 7\n"
  },
  {
    "page_number": 38,
    "content": "2°\nDarshan 2 - Application Layer\n\nHTTP response time:\n1. one RTT to initiate TCP connection\n2. one RTT for HTTP request and first few bytes of the HTTP response to return\n3. file transmission time\n\nNon-persistent HTTP response time = 2RTT+ file transmission time\n\nIt is overhead for each TCP connection.\n\nPersistent HTTP\n\nWith persistent connections, the server leaves the TCP connection open after sending responses\nand hence the subsequent requests and responses between the same client and server can be\nsent.\n\nThe server closes the connection only when it is not used for a certain configurable amount of\ntime.\n\nIt requires as little as one RTT for all the referenced objects\n\nWith persistent connections, the performance is improved by 20%.\n\nPersistent connections are the default mode for HTTP/1.1.\n\nHTTP message format\n\nThere are two types of HTTP messages:\n1. Request 2. Response\n\nHTTP request message\n\nAn HTTP request message is in ASCII format which means in human-readable format.\nCarriage return character\n\n. line-feed character\nrequest line\n\n(GET, POST, > GET /index.html HTTP/1. 1\\7\\h\nHEAD commands) Host: www-net.cs.umass.edu\\r\\n\nUser-Agent: Firefox/3.6.10\\r\\n\nheader Accept: text/html,application/xhtml+xml\\r\\n\n” Accept-Language: en-us,en;q=0.5\\r\\n\nlines | Accept-Encoding: gzip,deflate\\r\\n\nAccept-Charset: ISO-8859-1,utf-8 ;q=0.7\\r\\n\n\ncarriage return, Keep-Alive: 115\\r\\n\nline feed at start Connection: keep-alive\\r\\n\n—+\\r\\n\n\nof line indicates\nend of header lines\n\nFig. 5 HTTP request message\nHTTP request message consist three part\n1. Request line 2. Header line 3. Carriage return\nThe message is written in ordinary ASCII text so that your ordinary computer-literate human\nbeing can read it.\nEach line is followed by a carriage return and a line feed.\nThe last line is followed by an additional carriage return and line feed.\nThe first line of an HTTP request message is called the request line; the subsequent lines are\ncalled the header lines.\n\nMaulik Trivedi, CE Department | 2140709 — Computer Networks (CN) 8\n"
  },
  {
    "page_number": 39,
    "content": "(D Darshan\n\nsasesinc OF ergntarng a Teasley 2 — Application Layer\n\nThe request line has three fields: the method field, the URL field, and the HTTP version field.\n\nThe method field can take on several different values, including getting, POST, HEAD, PUT, and\nDELETE.\n\nIn this example, the browser is requesting the object /somedir/page.html. The version is self-\nexplanatory; in this example, the browser implements version HTTP/1.1.\n\nThe header line Host: www.someschool.edu specifies the host on which the object resides.\n\nHTTP response message\nstatus line\n(protocol\n\nstatus code BTTE/1.1 200 OK\\r\\n\nstatus phrase) Date: Sun, 26 Sep 2010 20:09:20 GmT\\r\\n\n\nServer: Apache/2.0.52 (CentOs)\\r\\n\nLast-Modified: Tue, 30 Oct 2007 17:00:02\nGMT\\r\\n\nheader ETag: \"17dc6-a5c-b£716880\"\\r\\n\nlines Accept-Ranges: bytes\\r\\n\n\nContent-Length: 2652\\r\\n\n\nKeep-Alive: timeout=10, max=100\\r\\n\n\nConnection: Keep-Alive\\r\\n\n\nContent-Type: text/html; charset=ISO-8859-\n\n1\\r\\n\n\\r\\n\ndata, eg.. data data data data...\nrequested\nHTML file\n\nFig. 6 HTTP request message\nHTTP response message consist three part\n1. Status line 2. Header line 3. Data (Entity body)\nThe status line has three fields: the protocol version field, a status code, and a corresponding\nstatus message.\nIn this example, the status line indicates that the server is using HTTP/1.1 and that everything is\nOK.\nThe Date: header line indicates the time and date when the HTTP response was created and\nsent by the server.\nThe Server: header line indicates that the message was generated by an Apache Web server.\nThe Last-Modified: header line indicates the time and date when the object was created or last\nmodified.\nThe Content-Length: header line indicates the number of bytes in the object being sent.\nThe Content-Type: header line indicates that the object in the entity body is HTML text.\n\nUser-Server Interaction OR Cookies\n\nA small text file created by a Web site that is stored in the user's computer either temporarily\nfor that session only or permanently on the hard disk (persistent cookie).\nCookies provide a way for the Web site to recognize you and keep track of your preferences.\n\nFiroz A. Sherasiya, CE Department | 2140709 — Computer Networks (CN) 9\n"
  },
  {
    "page_number": 40,
    "content": "P Darshan\n\nsasesinc OF ergntarng a Teasley 2 — Application Layer\n\ne Cookie technology has four components\n1. acookie header line in the HTTP response message\n2. acookie header line in the HTTP request message\n3. acookie file kept on the user’s end system and managed by the user’s browser\n4. a back-end database at the Web site\n\nClient host Server host\n\nws)\nebay: 8734\n\n—— Server creates\nID 1678 for user\nentry in backend\n\nis database\namazon: 1678\nebay: 8734 : access (\n—— Cookie-specific <> agai!\naction\nOne week later\naccess\n\nSe\n\namazon: 1678\nebay: 8734 — Cookie-specific\n\naction\n\nTime Time\n\nFig. 7 keeping user state with cookies\n\ne Suppose Susan, access Amazon.com for the first time.\n\ne Let us suppose that in the past she has already visited the eBay site.\n\ne When the request comes into the Amazon Web server, the server creates a unique identification\nnumber and creates an entry in its back-end database by the identification number.\n\ne The Amazon Web server then responds to Susan’s browser, including in the HTTP response a\nset-cookie: header, which contains the identification number.\n\ne For example, the header line might be Set-cookie: 1678.\n\ne When Susan's browser receives the HTTP response message, it sees the Set-cookie: header.\n\ne The browser then appends a line to the special cookie file that it manages.\n\nFiroz A. Sherasiya, CE Department | 2140709 — Computer Networks (CN) 10\n"
  },
  {
    "page_number": 41,
    "content": "| Darsha qn 2 — Application Layer\n\ne This line includes the hostname of the server and the identification number in the Set-cookie:\nheader.\n\ne The cookie file already has an entry for eBay, since Susan has visited that site in the past.\n\ne As Susan continues to browse the Amazon site, each time she requests a Web page, her browser\nconsults her cookie file, extracts her identification number for this site, and puts a cookie header\nline that includes the identification number in the HTTP request.\n\ne Specifically, each of her HTTP requests to the Amazon server includes the header line: Cookie:\n1678.\n\ne Inthis manner, the Amazon server is able to track Susan’s activity at the Amazon site.\n\nUse of cookies\n> authorization > recommendations\n> shopping carts > user session state (Web e-mail)\n\nWeb Caching OR Proxy Server\ne A Web cache OR a proxy server is a network entity that satisfies HTTP requests on the behalf of\nan origin Web server.\ne The Web cache has its own disk storage and keeps copies of recently requested objects in this\n\nstorage.\nProxy\nTe SA se\nClient ew” Origin\nPons AR server\nx .\n2 > rp feq\nws on 4 Les,\ner 2\n<e 5\n* ns.\n\nClient Origin\nserver\nFig. 8 Clients requesting objects through a Web cache\ne A Web cache OR a proxy server is a network entity that satisfies HTTP requests on the behalf of\nan origin Web server.\ne The Web cache has its own disk storage and keeps copies of recently requested objects in this\nstorage.\ne Auser’s browser can be configured so that all of the user’s HTTP requests are first directed to\nthe Web cache.\ne Asan example, suppose a browser is requesting the object\nhttp://www.someschool.edu/campus.gif.\ne Here is what happens\n1. The browser establishes a TCP connection to the Web cache and sends an HTTP request\nfor the object to the Web cache.\n\nFiroz A. Sherasiya, CE Department | 2140709 — Computer Networks (CN) 11\n"
  },
  {
    "page_number": 42,
    "content": "D Darshan\n\nsasesinc OF ergntarng a Teasley 2 — Application Layer\n\n2. The Web cache checks to see if it has a copy of the object stored locally. If it does, the\nWeb cache returns the object within an HTTP response message to the client browser.\n\n3. If the Web cache does not have the object, the Web cache opens a TCP connection to the\norigin server, that is, to www.someschool.edu. The Web cache then sends an HTTP\nrequest for the object into the cache-to-server TCP connection. After receiving this\nrequest, the origin server sends the object within an HTTP response to the Web cache.\n\n4. When the Web cache receives the object, it stores a copy in its local storage and sends a\ncopy, within an HTTP response message, to the client browser.\n\ne Note that a cache is both a server and a client at the same time.\n\ne When it receives requests from and sends responses to a browser, it is a server.\n\ne When it sends requests to and receives responses from an origin server, it is a client.\nWhy Web caching is needed (Required)? OR Advantages of Caching\n\n> To reduce response time for a client request\n\n> To reduce traffic on an institution’s access link\n\n> To enable \"poor\" content providers to effectively deliver content\n\nFTP (File Transfer Protocol)\n\ne File Transfer Protocol (FTP) is the commonly used protocol for exchanging files over the Network\nor Internet.\n\ne FTP uses the Internet's TCP/IP protocols to enable data transfer.\ne FTP uses client-server architecture.\n\ne FTP promotes sharing of files via remote computers with reliable and efficient data transfer.\n\nFile transfer\n\nUser\nor host\n\nLocal file Remote file\nsystem system\n\nFig. 9 FTP moves files between local and remote file systems\ne Inthe above figure, a user interacts with FTP through an FTP user agent.\ne The user first provides the hostname of the remote host, causing the FTP client process in the\nlocal host to establish a TCP connection with the FTP server process in the remote host.\ne The user then provides the user identification and password, which are sent over the TCP\nconnection as part of FTP commands.\ne Once the server has authorized the user, the user copies one or more files stored in the local file\nsystem into the remote file system (or vice versa).\ne FTP uses two parallel TCP connections to transfer a file,\n1. control connection\n2. data connection\n\nFiroz A. Sherasiya, CE Department | 2140709 — Computer Networks (CN) 12\n"
  },
  {
    "page_number": 43,
    "content": "D Darshan\n\ntaeitute Of Emgtnearing d Techsiohipy 2 - Application Layer\n\na TCP contro! connection port 21 4\nZ\nI\n\nTCP data connection port 20 3\n\nFIP FTP\nclient server\n\nFig. 10 Control and data connections\nThe control connection is used for sending control information between the two hosts such as\nuser identification, password, commands to change remote directory and commands to put and\nget files.\nThe data connection is used to actually send a file.\nBecause FTP uses a separate control connection, FTP is said to send its control information out-\nof-band.\nWhen a user starts an FTP session with a remote host, the client side of FTP (user) first initiates a\ncontrol TCP connection with the server side (remote host) on server port number 21.\nThe client side of FTP sends the user identification and password over this control connection.\nThe client side of FTP also sends, over the control connection, commands to change the remote\ndirectory.\nWhen the server side receives a command for a file transfer over the control connection (either\nto or from, the remote host), the server side initiates a TCP data connection to the client side.\nFTP sends exactly one file over the data connection and then closes the data connection.\nIf during the same session, the user wants to transfer another file, FTP opens another data\nconnection.\nThus, with FTP, the control connection remains open throughout the duration of the user\nsession, but a new data connection is created for each file transferred within a session (that is,\nthe data connections are non-persistent).\n\nElectronic mail on the Internet (Email)\n\nAs with ordinary postal mail, e-mail is an asynchronous communication medium in which people\nsend and read messages when it is convenient for them, without having to coordinate with\nother people’s schedules.\nIn contrast with postal mail, electronic mail is fast, easy to distribute, and inexpensive.\nModern e-mail has many powerful features, including messages with attachments, hyperlinks,\nHTML-formatted text, and embedded photos.\nEmail has three major components\n\n1. user agents\n\n2. mail servers\n\n3. Simple Mail Transfer Protocol (SMTP)\nUser agents allow users to read, reply to, forward, save, and compose messages.\nMicrosoft Outlook and Apple Mail are examples of user agents for e-mail.\n\nFiroz A. Sherasiya, CE Department | 2140709 — Computer Networks (CN) 13\n"
  },
  {
    "page_number": 44,
    "content": "oi Darshan 2 - Application Layer\n\ne OS\n\nKey:\niM sey queue in| User mailbox\n\nFig. 11 A high-level view of the Internet e-mail system\n\nKey:\nESSN DL) Message queue User mailbox\n\nFig. 12 Alice sends a message to Bob\ne In the above figure when Alice is finished composing her message, her user agent sends the\nmessage to her mail server, where the message is placed in the mail server’s outgoing message\nqueue.\n\nFiroz A. Sherasiya, CE Department | 2140709 — Computer Networks (CN) 14\n"
  },
  {
    "page_number": 45,
    "content": "“a> Darshan 2 — Application Layer\n\nInstitute of Engineering & Technology\n\ne When Bob wants to read a message, his user agent retrieves the message from his mailbox in his\nmail server.\n\ne Mail servers form the core of the e-mail infrastructure.\n\ne Each recipient, such as Bob, has a mailbox located in one of the mail servers.\n\ne Bob’s mailbox manages and maintains the messages that have been sent to him.\n\ne Atypical message starts its journey in the sender’s user agent, travels to the sender’s mail server\nand travels to the recipient’s mail server, where it is deposited in the recipient’s mailbox.\n\ne When Bob wants to access the messages in his mailbox, the mail server containing his mailbox\nauthenticates Bob (with usernames and passwords).\n\ne Alice’s mail server must also deal with failures in Bob’s mail server.\n\ne If Alice’s server cannot deliver mail to Bob’s server, Alice’s server holds the message in a\nmessage queue and attempts to transfer the message later.\n\ne Reattempts are often done every 30 minutes or so; if there is no success after several days, the\nserver removes the message and notifies the sender (Alice) with an e-mail message.\n\ne =SMTP is the principal application-layer protocol for Internet electronic mail. It uses the reliable\ndata transfer service of TCP to transfer mail from the sender’s mail server to the recipient’s mail\nserver.\n\ne SMTP has two sides: a client side, which executes on the sender’s mail server, and a server side,\nwhich executes on the recipient’s mail server.\n\ne Both the client and server sides of SMTP run on every mail server.\n\ne When a mail server sends mail to other mail servers, it acts as an SMTP client. When a mail\nserver receives mail from other mail servers, it acts as an SMTP server.\n\nSMTP (Simple Mail Transfer Protocol)\n\nSMTP transfers messages from senders’ mail servers to the recipients’ mail servers.\n\ne = It restricts the body (not just the headers) of all mail messages to simple 7-bit ASCII.\n\ne To illustrate the basic operation of SMTP, let’s take a common scenario. Suppose Alice wants to\nsend Bob a simple ASCII message.\n\nAlice’s\nKo server\n\n5 300\n\nge queue User mailbox\n\nFig. 13 Alice sends a message to Bob\n1. Alice invokes her user agent for e-mail, provides Bob’s e-mail address (for example,\nbob@someschool.edu), composes a message and instructs the user agent to send the\nmessage.\n\nFiroz A. Sherasiya, CE Department | 2140709 — Computer Networks (CN) 15\n"
  },
  {
    "page_number": 46,
    "content": "D Darshan\n\ntaeitute Of Emgtnearing d Techsiohipy 2 - Application Layer\n\n2. Alice’s user agent sends the message to her mail server, where it is placed in a message\nqueue.\n\n3. The client side of SMTP, running on Alice’s mail server, sees the message in the message\nqueue. It opens a TCP connection to an SMTP server, running on Bob’s mail server.\n\n4. After some initial SMTP handshaking, the SMTP client sends Alice’s message into the TCP\nconnection.\n\n5. At Bob’s mail server, the server side of SMTP receives the message. Bob’s mail server then\nplaces the message in Bob’s mailbox.\n\n6. Bob invokes his user agent to read the message at his convenience.\n\nSMTP does not normally use intermediate mail servers for sending mail, even when the two mail\n\nservers are located at opposite ends of the world.\n\nIf Bob’s mail server is down, the message remains in Alice’s mail server and waits for a new\n\nattempt and the message does not get placed in some intermediate mail server.\n\nHow SMTP transfers a message from a sending mail server to a receiving mail\nserver\n\nFirst, the client SMTP (running on the sending mail server host) has TCP establish a connection\nto port 25 at the server SMTP (running on the receiving mail server host).\n\nIf the server is down, the client tries again later.\n\nOnce this connection is established, the server and client perform some application-layer\nhandshaking, just as humans often introduce themselves before transferring information from\none to another.\n\nDuring this SMTP handshaking phase, the SMTP client indicates the e-mail address of the sender\n(the person who generated the message) and the e-mail address of the recipient.\n\nOnce the SMTP client and server have introduced themselves to each other, the client sends the\nmessage.\n\nSMTP can count on the reliable data transfer service of TCP to get the message to the server\nwithout errors.\n\nThe client then repeats this process over the same TCP connection if it has other messages to\nsend to the server; otherwise, it instructs TCP to close the connection.\n\nComparison of SMTP with HTTP\n\nHTTP is mainly a pull protocol-someone loads information on a web server and users use HTTP\nto pull the information from the server. On the other hand, SMTP is primarily a push protocol-\nthe sending mail server pushes the file to receive mail server.\n\nSMTP requires each message, including the body of each message, to be in seven-bit ASCII\nformat. If the message contains binary data, then the message has to be encoded into seven-bit\nASCII format. HTTP does not have this restriction.\n\nHTTP encapsulate each object of a message in its own response message while SMTP places all\nof the message's objects into one message.\n\nMail Access Protocols (POP3 and IMAP)\nPOP3 (Post Office Protocol)\n\nPOP3 is an extremely simple mail access protocol.\nPOP3 begins when the user agent of the client opens a TCP connection to the mail server of the\nserver on port 110.\n\nFiroz A. Sherasiya, CE Department | 2140709 — Computer Networks (CN) 16\n"
  },
  {
    "page_number": 47,
    "content": "D Darshan\n\ntaeitute Of Emgtnearing d Techsiohipy 2 - Application Layer\n\nWith the TCP connection established, POP3 progresses through three phases: authorization,\ntransaction, and update.\n\nDuring the first phase, authorization, the user agent sends a username and a password to\nauthenticate the user.\n\nDuring the second phase, transaction, the user agent retrieves messages; also during this phase,\nthe user agent can mark messages for deletion, remove deletion marks and obtain mail\nstatistics.\n\nThe third phase, update, occurs after the client has issued the quit command, ending the POP3\nsession; at this time, the mail server deletes the messages that were marked for deletion.\n\nPOP3 is designed to delete mail on the server as soon as the user has downloaded it.\n\nHowever, some implementations allow users or an administrator to specify that mail is saved for\nsome period of time. POP can be thought of as a \"store-and-forward\" service.\n\nIMAP (Internet Message Access Protocol)\n\nWith POP3 access, once a receiver has downloaded his messages to the local machine, he can\ncreate mail folders and move the downloaded messages into the folders.\n\nA receiver can then delete messages, move messages across folders, and search for messages\n(by sender name or subject).\n\nBut this paradigm—namely, folders and messages in the local machine—poses a problem for\nthe roaming user, who would prefer to maintain a folder hierarchy on a remote server that can\nbe accessed from any computer.\n\nThis is not possible with POP3—the POP3 protocol does not provide any means for a user to\ncreate remote folders and assign messages to folders.\n\nAn IMAP server will associate each message with a folder; when a message first arrives at the\nserver, it is associated with the recipient’s INBOX folder.\n\nThe recipient can then move the message into a new, user-created folder, read the message,\ndelete the message, and so on.\n\nThe IMAP protocol provides commands to allow users to create folders and move messages\nfrom one folder to another.\n\nIMAP also provides commands that allow users to search remote folders for messages matching\nspecific criteria.\n\nAnother important feature of IMAP is that it has commands that permit a user agent to obtain\ncomponents of messages. For example, a user agent can obtain just the message header of a\nmessage or just one part of a multipart MIME message.\n\nThis feature is useful when there is a low-bandwidth connection (for example, a slow-speed\nmodem link) between the user agent and its mail server.\n\nWith a low bandwidth connection, the user may not want to download all of the messages in its\nmailbox, particularly avoiding long messages that might contain, for example, an audio or video\nclip.\n\nDNS (Domain Name System)\n\nDNS (Domain Name System) is an internet service that translates domain names into IP\naddresses.\n\nBecause domain names are alphabetic, they're easier to remember for a human being but The\nInternet is really based on IP addresses.\n\nFiroz A. Sherasiya, CE Department | 2140709 — Computer Networks (CN) 17\n"
  },
  {
    "page_number": 48,
    "content": "“a> Darshan 2 — Application Layer\n\nInstitute of Engineering & Technology\n\ne Every time you use a domain name, therefore, a DNS service must translate the domain name\ninto the corresponding IP address. For example, the domain name www.google.com might\ntranslate to 198.105.232.4.\n\ne The DNS system is, in fact, its own network. If one DNS server doesn't know how to translate a\nparticular domain name, it asks another one, and so on, until the correct IP address is returned.\n\nDistributed database design is more preferred over a centralized design to\nimplement DNS in the Internet\n\n1. A single point of failure: If the DNS server crashes then the entire Internet will not stop.\n\n2. Traffic volume: Today the Internet is so huge, with millions of device and users accessing\nits services from all over the globe at the same time. A Single DNS Server cannot handle\nthe huge global DNS traffic but with a distributed system, this traffic is distributed and\nreduce overload on the server.\n\n3. Distant centralized database: A single DNS server cannot be “close to” all the querying\nclients. If we put the single DNS server in New York City, then all queries from Australia\nmust travel to the other side of the globe, perhaps over slow and congested links. This\ncan lead to significant delays.\n\n4. Maintenance: The single DNS server would have to keep records for all Internet hosts.\nNot only would this centralized database be huge, but it would have to be updated\nfrequently to account for every new host.\n\nA Distributed, Hierarchical Database\n\nRoot DNS servers\ncom DNS servers org DNS servers edu DNS servers\nyahoo.com amazon.com pbs.org poly.edu umass.edu\nDNS servers DNS servers DNS servers DNS servers DNS servers\n\nFig. 14 Portion of the hierarchy of DNS servers\ne suppose a DNS client wants to determine the IP address for the hostname www.amazon.com:\n\n1. The client first contacts one of the root servers, which returns IP addresses for TLD servers\nfor the top-level domain com.\n\n2.The client then contacts one of these TLD servers, which returns the IP address of an\nauthoritative server for amazon.com.\n\n3. Finally, the client contacts one of the authoritative servers for amazon.com, which returns\nthe IP address for the hostname www.amazon.com.\n\nFiroz A. Sherasiya, CE Department | 2140709 — Computer Networks (CN) 18\n"
  },
  {
    "page_number": 49,
    "content": "an\n\nsasesinc OF ergntarng a Teasley 2 — Application Layer\n\nRecursive queries and iterative queries\n\nRoot DNS server\n\na\na\n\nLocal DNS server TLD DNS server\ndns .poly.edu\n\niz\n\nAuthoritative DNS server\n\nss dns.umass.edu\nRequesting host\ncis.poly.edu\n\ngaia.cs.umass.edu\n\nFig. 15 Interaction of the various DNS servers\ne The example shown in the above figure makes use of both recursive queries and iterative\nqueries.\ne The query 1 sent from cis.poly.edu to dns.poly.edu is a recursive query because the query asks\ndns.poly.edu to obtain the mapping on its behalf.\n\ne But the subsequent three queries 2, 4 and 6 are iterative since all of the replies are directly\nreturned to dns.poly.edu.\n\nFiroz A. Sherasiya, CE Department | 2140709 — Computer Networks (CN) 19\n"
  },
  {
    "page_number": 50,
    "content": "Darshan\n\ninsthcuey of Engineering a Teehsology 3 — Transport Layer\n\nTransport-Layer services\n\nA transport-layer protocol provides logical communication between application\nprocesses running on different hosts.\n\nBy logical communication, application processes communicate with each other by\nusing the logical communication provided by the transport layer to send messages to\neach other, free from the worry of the details of the physical infrastructure used to\ncarry these messages.\n\nTransport-layer protocols are implemented in the end systems but not in network\nrouters.\n\nOn the sending side, the transport layer converts the application-layer messages it\nreceives from a sending application process into transport-layer packets, known as\ntransport-layer segments.\n\nOn the receiving side, the transport layer reassembles segments into messages,\npasses to application layer.\n\nA network-layer protocol provides logical communication between hosts.\n\nRelationship between Transport and Network Layers\n\nThe transport layer lies just above the network layer in the protocol stack.\n\nWhereas a transport-layer protocol provides logical communication between\nprocesses running on different hosts, a network-layer protocol provides logical\ncommunication between hosts.\n\nLet's examine this distinction with the aid of a household analogy.\n\nConsider two houses, one on the East Coast and the other on the West Coast, with\neach house being home to a dozen kids.\n\nThe kids in the East Coast household are cousins of the kids in the West Coast\nhousehold.\n\nThe kids in the two households love to write to each other-each kid writes each\ncousin every week, with each letter delivered by the traditional postal service in a\nseparate envelope.\n\nThus, each household sends 144 letters to the other household every week.\n\nIn each of the households there is one kid Ann in the West Coast house and Bill in\nthe East Coast house responsible for mail collection and mail distribution.\n\nEach week Ann visits all her brothers and sisters, collects the mail, and gives the mail\nto a postal-service mail person who makes daily visits to the house.\n\nWhen letters arrive at the West Coast house, Ann also has the job of distributing the\nmail to her brothers and sisters. Bill has a similar job on the East Coast.\n\nIn this example, the postal service provides logical communication between the two\nhouses-the postal service moves mail from house to house, not from person to\nperson.\n\nOn the other hand, Ann and Bill provide logical communication among the cousins-\nAnn and Bill pick up mail from and deliver mail to their brothers and sisters.\n\nNote that from the cousins' perspective, Ann and Bill are the mail service, even\nthough Ann and Bill are only a part (the end system part) of the end-to-end delivery\nprocess.\n\nProf. Maulik Trivedi, CE Department | 2140709 — Computer Networks (CN) 1\n"
  },
  {
    "page_number": 51,
    "content": "Darshan\n\nInstitute of Engineering & Technology 3 -— Transport Layer\n\ne This household example serves as a nice analogy for explaining how the transport\nlayer relates to the network layer:\nhosts (also called end systems) = houses\nprocesses = cousins\napplication messages = letters in envelopes\nnetwork-layer protocol = postal service (including mail persons)\ntransport-layer protocol = Ann and Bill\n\ne Continuing with this analogy, observe that Ann and Bill do all their work within their\nrespective homes; they are not involved, for example, in sorting mail in any\nintermediate mail centre or in moving mail from one mail centre to another.\n\ne Similarly, transport-layer protocols live in the end systems. Within an end system, a\ntransport protocol moves messages from application processes to the network edge\n(that is, the network layer) and vice versa; but it doesn't have any say about how the\nmessages are moved within the network core.\n\ne In fact, intermediate routers neither act on, nor recognize, any information that the\ntransport layer may have appended to the application messages.\n\nMultiplexing and Demultiplexing\n\nmultiplexing at sender:\nhandle data trom multiple\nsockets, add transport header\n(later used for demultiplexing)\n\ndemultiplexing at receiver:\nuse header info to deliver\nreceived segments to correct\nsocket\n\napplication\n\napplication application\n\n[EB] socket\nC_ process\n\n=\ntransport\n\nFig. 1 Transport-layer multiplexing and demultiplexing\n\ne The job of gathering data chunks at the source host from different sockets,\nencapsulating each data chunk with header information (that will later be used in\ndemultiplexing) to create segments, and passing the segments to the network layer\nis called multiplexing.\n\ne At the receiving end, the transport layer examines these fields to identify the\nreceiving socket and then directs the segment to that socket. This job of delivering\nthe data in a transport-layer segment to the correct socket is called demultiplexing.\n\nProf. Maulik Trivedi, CE Department | 2140709 — Computer Networks (CN) 2\n"
  },
  {
    "page_number": 52,
    "content": "Darshan\n\nIaieieaed of Engineering a Tachactogy 3 — Transport Layer\n\ne Transport layer in the middle host in Figure 1 must demultiplex segments arriving\nfrom the network layer below to either process P1 or P2 above; this is done by\ndirecting the arriving segment’s data to the corresponding process’s socket.\n\ne The transport layer in the middle host must also gather outgoing data from these\nsockets, form transport-layer segments, and pass these segments down to the\nnetwork layer.\n\nEndpoint Identification\n\ne Sockets must have unique identifiers.\n\ne Each segment must include header fields identifying the socket, these header fields\nare the source port number field and the destination port number field.\n\ne Each port number is a 16-bit number: 0 to 65535.\n\n32 bits\nl\n\nSource port # Dest. port #\n\nOther header fields\n\nApplication\ndata\n(message)\n\nFig. 2 Source and destination port-number fields in a transport-layer segment\n\nConnectionless Multiplexing and Demultiplexing\ne Suppose a process on Host A, with port number 19157, wants to send data to a\nprocess with UDP port 46428 on Host B.\n\n_- Client process\n\n> __|- Socket\nHost A — Server B\n\nsource port: dest. port: -\n19157 46428 E\n\nsource port: dest. port:\n46428 19157\n\nFig. 3 The inversion of source and destination port numbers\ne Transport layer in Host A creates a segment containing source port, destination port,\nand data and then passes it to the network layer in Host A.\ne Transport layer in Host B examines destination port number and delivers segment to\nsocket identified by port 46428.\ne Note: a UDP socket is fully identified by a two-tuple consisting of\n1. adestination IP address\n\nProf. Maulik Trivedi, CE Department | 2140709 — Computer Networks (CN) 3\n"
  },
  {
    "page_number": 53,
    "content": "@\nC Darshan 3 — Transport Layer\n\nInstitute of Engineering & Technology\n\n2. adestination port number\ne Source port number from Host A is used at Host B as \"return address\".\n\nConnection-Oriented Multiplexing and Demultiplexing\n\ne Each TCP connection has exactly two end-points.\n\ne This means that two arriving TCP segments with different source IP addresses or\nsource port numbers will be directed to two different sockets, even if they have the\nsame destination port number.\n\ne SoaTCP socket is identified by four-tuple.\n\nProf. Maulik Trivedi, CE Department | 2140709 — Computer Networks (CN) 4\n"
  },
  {
    "page_number": 54,
    "content": "P Darshan\n\n[aca of Engurnertng a Thales) 3 — Transport Layer\n\nsource IP address 2. destination IP address\n1. source port # 3. destination port #\ne Whereas UDP is identified by only two-tuples\n1. destination IP address 2. destination port #\nWeb client Web Per-connection\n\nHTTP\n\nhost C server B\n7 processes\n\nTransport-\nlayer\ndemultiplexing\n\nWeb client\nhost A\n\nFig. 4 Two clients, using the same destination port number (80) to communicate with the same\nWeb server application\n\nProf. Maulik Trivedi, CE Department | 2140709 — Computer Networks (CN) 5\n"
  },
  {
    "page_number": 55,
    "content": "Darshan\n\nInstitute of Engineering & Technology 3 -— Transport Layer\n\nUDP Segment Structure\n32 bits\n\nSource port # Dest. port #\n\nLength Checksum\n\nApplication\ndata\n(message)\n\nFig. 5 UDP segment structure\n\ne The port numbers allow the destination host to pass the application data to the\ncorrect process running on the destination end system (that is used to perform the\ndemultiplexing function).\n\ne The length field specifies the number of bytes in the UDP segment (header plus\ndata).\n\ne The checksum is used by the receiving host to check whether errors have been\nintroduced into the segment.\n\nHow to calculate (find) checksum:\n\ne The UDP checksum is calculated on the sending side by summing all the 16-bit words\nin the segment, with any overflow being wrapped around and then the 1's\ncomplement is performed and the result is added to the checksum field inside the\nsegment.\n\ne At the receiver side, all words inside the packet are added and the checksum is\nadded upon them if the result is 1111 1111 1111 1111 then the segment is valid else\nthe segment has an error.\n\n0110011001100110\n0101010101010101 } re is wns\n0000111100001111\n\nThe sum of first of two 16-bit words is:\n\n0110011001100110\n0101010101010101\n\nLOL101110111011 > Sum of 1* two 16 bit words.\n\nAdding the third word to the above sum ges:\n\n1011101110111011 > Sum of 1*two 16 bit words\n0000111100001111 + Third 16 bits word\n\n1100101011001010 — Sum ofall three 16 bit words.\n\nTaking 1’s complement for the final sum:\n\n1100101011001010 > Sum ofall three 16 bit words.\n0011010100110101 > 1’s complement for the final sum.\n\nThe 1’s complement value is called as Checksum.\n\nProf. Maulik Trivedi, CE Department | 2140709 — Computer Networks (CN) 6\n"
  },
  {
    "page_number": 56,
    "content": "c Darshan 3 — Transport Layer\n\nInstitute of Engineering & Technology\n\nPrinciples of Reliable Data Transfer\n\nrdt_send() : called from above, deliver _data() : called by\n(e.g., by app.). Passed data to rdt to deliver data to upper\n\ndeliver to receiver upper layer\n\nrdt_send()\n\ndeliver data()\n\nreliable data receive\ntransfer protocol F\nreceiving side side\n\nudt_send(){ packet rdt rev()\n/ L qunerabe channel \\d\n\nudt_send() : called by rdt, rdt_rev() : called when packet\nto transfer packet over arrives on rcv-side of channel\nunreliable channel to receiver\n\nFig. 7 Reliable data transfer commands\n\ne The sending side of the data transfer protocol will be invoked from above by a call to\nrdt_send().\n\ne On the receiving side, rdt_rcv() will be called when a packet arrives from the\nreceiving side of the channel.\n\ne When the rdt protocol wants to deliver data to the upper layer, it will do so by calling\ndeliver_data().\n\ne Both the send and receive sides of rdt send packets to the other side by a call to\nudt_send().\n\nBuilding a Reliable Data Transfer Protocol\n\nReliable Data Transfer over a Perfectly Reliable Channel: rdt1.0\n\ne We first consider the simplest case in which the underlying channel is completely\nreliable.\n\ne The protocol itself, which we will call rdt1.0, is trivial.\n\nrdt_rcv(packet)\n\nextract (packet,data)\ndeliver_data(data)\n\nNait for\ncall from\nabove\n\nrdt_send(data)\ncall from\nbelow\n\npacket = make_pkt(data)\nudt_send(packet)\n\nsender receiver\n\ne The sender and receiver FSMs (Finite State Machines) have only one state.\n\nProf. Maulik Trivedi, CE Department | 2140709 — Computer Networks (CN) 7\n"
  },
  {
    "page_number": 57,
    "content": "Darshan\n\ninsthcuey of Engineering a Teehsology 3 — Transport Layer\n\nThe arrows in the FSM description indicate the transition of the protocol from one\nstate to another. (Since each FSM has just one state, a transition is necessarily from\nthe one state back to itself).\n\nThe event causing the transition is shown above the horizontal line labelling the\ntransition, and the action(s) taken when the event occurs are shown below the\nhorizontal line.\n\nThe sending side of rdt simply accepts data from the upper-layer via the\nrdt_send(data) event, puts the data into a packet (via the action\nmake_pkt(packet,data)) and sends the packet into the channel.\n\nOn the receiving side, rdt receives a packet from the underlying channel via the\nrdt_rcv(packet) event, removes the data from the packet using the action\nextract(packet,data) and passes the data up to the upper-layer.\n\nAlso, all packet flow is from the sender to receiver - with a perfectly reliable channel\nthere is no need for the receiver side to provide any feedback to the sender since\nnothing can go wrong.\n\nReliable Data Transfer over a Channel with Bit Errors: rdt2.0\n\nA more realistic model of the underlying channel is one in which bits in a packet may\nbe corrupted.\n\nSuch bit errors typically occur in the physical components of a network as a packet is\ntransmitted, propagates, or is buffered.\n\nWe'll continue to assume for the moment that all transmitted packets are received\n(although their bits may be corrupted) in the order in which they were sent.\n\nBefore developing a protocol for reliably communicating over such a channel, first\nconsider how people might deal with such a situation.\n\nConsider how you yourself might dictate a long message over the phone. In a typical\nscenario, the message taker might say “‘OK\" after each sentence has been heard,\nunderstood, and recorded. If the message taker hears a garbled sentence, you're\nasked to repeat the garbled sentence. This message dictation protocol uses both\npositive acknowledgements (\"OK\") and negative acknowledgements (“Please repeat\nthat''). These control messages allow the receiver to let the sender know what has\nbeen received correctly, and what has been received in error and thus requires\nrepeating. In a computer network setting, reliable data transfer protocols based on\nsuch retransmission are known ARQ (Automatic Repeat reQuest) protocols.\nFundamentally, two additional protocol capabilities are required in ARQ protocols to\nhandle the presence of bit errors:\n\nError detection: First, a mechanism is needed to allow the receiver to detect when\nbit errors have occurred. UDP transport protocol uses the Internet checksum field for\nexactly this purpose. Error detection and correction techniques allow the receiver to\ndetect, and possibly correct packet bit errors.\n\nReceiver feedback: Since the sender and receiver are typically executing on different\nend systems, possibly separated by thousands of miles, the only way for the sender\nto learn of the receiver's view of the world (in this case, whether or not a packet was\nreceived correctly) is for the receiver to provide explicit feedback to the sender. The\npositive (ACK) and negative acknowledgement (NAK) replies in the message dictation\n\nProf. Maulik Trivedi, CE Department | 2140709 — Computer Networks (CN) 8\n"
  },
  {
    "page_number": 58,
    "content": "@\nC Darshan 3 — Transport Layer\n\nInstitute of Engineering & Technology\n\nscenario are an example of such feedback. Our rdt2.0 protocol will similarly send\nACK and NAK packets back from the receiver to the sender.\n\nrdt_send(data)\n\nsndpkt = make_pkt(data, checksum) receiver\n\nudt_send(sndpkt)\nrdt_rev(revpkt) &&\nisNAK(rcvpkt)\nrdt_rcv(rcvpkt) &&\ncall from udt_send(sndpkt) corrupt(rcvpkt)\n\nabove ——\nudt_send(NAK)\n\nio)\n\nrdt_rcev(rcvpkt) && isACK(rcvpkt) * Avait\n—————— ait for\n\nA call from\nbelow\n\nsender\n\nrdt_rcev(revpkt) &&\nnotcorrupt(rcvpkt)\nextract(rcvpkt,data)\ndeliver_data(data)\nudt_send(ACk)\n\ne The send side of rdt2.0 has two states.\n\ne Inone state, the send-side protocol is waiting for data to be passed down from the\nupper layer.\n\ne Inthe other state, the sender protocol is waiting for an ACK or a NAK packet from\nthe receiver.\n\ne If an ACK packet is received (the notation rdt_rcv(rcvpkt) && isACK(rcvpkt), the\nsender knows the most recently transmitted packet has been received correctly and\nthus the protocol returns to the state of waiting for data from the upper layer.\n\ne If a NAK is received, the protocol retransmits the last packet and waits for an ACK or\nNAK to be returned by the receiver in response to the retransmitted data packet.\n\ne It is important to note that when the receiver is in the wait-for-ACK-or-NAK state, it\ncannot get more data from the upper layer; that will only happen after the sender\nreceives an ACK and leaves this state.\n\ne Thus, the sender will not send a new piece of data until it is sure that the receiver\nhas correctly received the current packet.\n\ne Because of this behaviour, protocols such as rdt2.0 are known as stop-and-wait\nprotocols.\n\ne The receiver-side FSM for rdt2.0 still has a single state.\n\ne On packet arrival, the receiver replies with either an ACK or a NAK, depending on\nwhether or not the received packet is corrupted.\n\ne In above figure the notation rdt_rcv(rcvpkt) && corrupt(rcvpkt) corresponds to the\nevent where a packet is received and is found to be in error.\n\nrdt2.1: sender, handles garbled ACK/NAKs\n\ne Protocol rdt2.0 may look as if it works but unfortunately has a fatal flaw.\n\nProf. Maulik Trivedi, CE Department | 2140709 — Computer Networks (CN) 9\n"
  },
  {
    "page_number": 59,
    "content": "Darshan\n\ninsthcuey of Engineering a Teehsology 3 — Transport Layer\n\ne In particular, we haven't accounted for the possibility that the ACK or NAK packet\ncould be corrupted.\n\ne Minimally, we will need to add checksum bits to ACK/NAK packets in order to detect\nsuch errors.\n\ne The more difficult question is how the protocol should recover from errors in ACK or\nNAK packets.\n\ne The difficulty here is that if an ACK or NAK is corrupted, the sender has no way of\nknowing whether or not the receiver has correctly received the last piece of\ntransmitted data.\n\ne An approach is for the sender to simply resend the current data packet when it\nreceives a garbled ACK or NAK packet.\n\ne This, however, introduces duplicate packets into the sender-to-receiver channel.\n\ne The fundamental difficulty with duplicate packets is that the receiver doesn't know\nwhether the ACK or NAK it last sent was received correctly at the sender.\n\ne Thus, it cannot know a priori whether an arriving packet contains new data or is a\nduplicate.\n\ne Asimple solution to this new problem is to add a new field to the data packet and\nhave the sender number its data packets by putting a sequence number into this\nfield.\n\ne The receiver then need only check this sequence number to determine whether or\nnot the received packet is a retransmission.\n\ne For this simple case of a stop-and-wait protocol, a 1-bit sequence number will\nsuffice, since it will allow the receiver to know whether the sender is resending the\npreviously transmitted packet (the sequence number of the received packet has the\nsame sequence number as the most recently received packet) or a new packet (the\nsequence number changes).\n\ne Since we are currently assuming a channel that does not lose packets, ACK and NAK\npackets do not themselves need to indicate the sequence number of the packet they\nare ACKing or NAKing, since the sender knows that a received ACK or NAK packet\n(whether garbled or not) was generated in response to its most recently transmitted\ndata packet.\n\nProf. Maulik Trivedi, CE Department | 2140709 — Computer Networks (CN) 10\n"
  },
  {
    "page_number": 60,
    "content": "Darshan\n\nInstitute of Engineering & Technology 3-Tra nsport Layer\n\nrdt_send(data)\n\nsndpkt = make_pkt(0, data, checksum)\nudt_send(sndpkt)\n\nrdt_rcv(revpkt) &&\n( corrupt(rcvpkt) ||\nisNAK(rcvpkt) )\n\nudt_send(sndpkt)\n\nrdt_rcv(rcvpkt)\n\n&& notcorrupt(rcevpkt) rdt_rev(revpkt)\n&& isACK(revpkt) && notcorrupt(revpkt)\nTTT && isACK(rcvpkt)\n\nA ———+!—\n\nA\n\nrdt_rev(rcvpkt) &&\n( corrupt(rcvpkt) ||\nisNAK(rcvpkt) ) rdt_send(data)\nudt_send(sndpkt) sndpkt = make_pkt(1, data, checksum)\n\nudt_send(sndpkt)\nFig 10 rdt 2.1 Sender\n\nrdt_rev(revpkt) && notcorrupt(rcvpkt)\n&& has_seqQO(rcvpkt)\n\nextract(revpkt,data)\n\ndeliver_data(data)\n\nsndpkt = make_pkt(ACK, chksum)\nudt_send(sndpkt)\n\n\\\n\\\n\nrdt_rev(revpkt) && (corrupt(revpkt) \\\nsndpkt = make_pkt(NAK, chksum) ‘\\\n\nudt_send(sndpkt) or\n\nrdt_rev(revpkt) && rdt_rev(revpkt) &&\nnot corrupt(revpkt) && ( below,\n\nnot corrupt(revpkt) &&\nhas_seq1(rcvpkt) has_seq0(rcvpkt)\nsndpkt = make_pkt(ACK, chksum)\n\nsndpkt = make_pkt(ACK, chksum)\nudt_send(sndpkt) udt_send(sndpkt)\n\nrdt_rev(revpkt) && (corrupt(revpkt)\n\nsndpkt = make_pkt(NAK, chksum)\nudt_send(sndpkt)\n\nrdt_rev(revpkt) && notcorrupt(revpkt)\n&& has_seq1(rcvpkt)\n\nextract(rcvpkt,data)\ndeliver_data(data)\n\nsndpkt = make_pkt(ACK, chksum)\nudt_send(sndpkt)\n\nFig 11 rdt 2.1 Receiver\n\ne The rdt2.1 sender and receiver FSM's each now have twice as many states as rdt2.0.\n\ne This is because the protocol state must now reflect whether the packet currently\nbeing sent (by the sender) or expected (at the receiver) should have a sequence\nnumber of 0 or 1.\n\ne Note that the actions in those states where a O-numbered packet is being sent or\nexpected are mirror images of those where a 1-numbered packet is being sent or\n\nProf. Maulik Trivedi, CE Department | 2140709 — Computer Networks (CN) 11\n"
  },
  {
    "page_number": 61,
    "content": "Darshan\n\ninsthcuey of Engineering a Teehsology 3 — Transport Layer\n\nexpected; the only differences have to do with the handling of the sequence\nnumber.\n\nProtocol rdt2.1 uses both positive and negative acknowledgements from the\nreceiver to the sender.\n\nA negative acknowledgement is sent whenever a corrupted packet, or an out of\norder packet, is received.\n\nWe can accomplish the same effect as a NAK if instead of sending a NAK, we instead\nsend an ACK for the last correctly received packet.\n\nA sender that receives two ACKs for the same packet (i.e., receives duplicate ACKs)\nknows that the receiver did not correctly receive the packet following the packet\nthat is being ACKed twice. Our NAK-free reliable data transfer protocol for a channel\nwith bit errors is rdt2.2.\n\nReliable Data Transfer over a Lossy Channel with Bit Errors: rdt3.0\n\nSuppose now that in addition to corrupting bits, the underlying channel can lose\npackets as well.\n\nTwo additional concerns must now be addressed by the protocol: how to detect\npacket loss and what to do when this occurs.\n\nThe use of checksumming, sequence numbers, ACK packets, and retransmissions -\nthe techniques already developed in rdt 2.2 - will allow us to answer the latter\nconcern. Handling the first concern will require adding a new protocol mechanism.\nThere are many possible approaches towards dealing with packet loss.\n\nSuppose that the sender transmits a data packet and either that packet, or the\nreceiver's ACK of that packet, gets lost.\n\nIn either case, no reply is forthcoming at the sender from the receiver.\n\nIf the sender is willing to wait long enough so that it is certain that a packet has been\nlost, it can simply retransmit the data packet.\n\nBut how long must the sender wait to be certain that something has been lost? It\nmust clearly wait at least as long as a round trip delay between the sender and\nreceiver (which may include buffering at intermediate routers or gateways) plus\nwhatever amount of time is needed to process a packet at the receiver.\n\nIf an ACK is not received within this time, the packet is retransmitted.\n\nNote that if a packet experiences a particularly large delay, the sender may\nretransmit the packet even though neither the data packet nor its ACK have been\nlost.\n\nThis introduces the possibility of duplicate data packets in the sender-to-receiver\nchannel.\n\nHappily, protocol rdt2.2 already has enough functionality (i.e., sequence numbers) to\nhandle the case of duplicate packets.\n\nFrom the sender's viewpoint, retransmission is a solution. The sender does not know\nwhether a data packet was lost, an ACK was lost, or if the packet or ACK was simply\noverly delayed.\n\nIn all cases, the action is the same: retransmit. In order to implement a time-based\nretransmission mechanism, a countdown timer will be needed that can interrupt the\nsender after a given amount of timer has expired.\n\nProf. Maulik Trivedi, CE Department | 2140709 — Computer Networks (CN) 12\n"
  },
  {
    "page_number": 62,
    "content": "Darshan\n\nInstitute of Engineering & Technology 3-Tra nsport Layer\n\ne The sender will thus need to be able to (i) start the timer each time a packet (either a\nfirst time packet, or a retransmission) is sent, (ii) respond to a timer interrupt (taking\nappropriate actions), and (iii) stop the timer.\n\ne The existence of sender-generated duplicate packets and packet (data, ACK) loss also\ncomplicates the sender's processing of any ACK packet it receives.\n\ne If an ACK is received, how is the sender to know if it was sent by the receiver in\nresponse to its (sender's) own most recently transmitted packet, or is a delayed ACK\nsent in response to an earlier transmission of a different data packet? The solution to\nthis dilemma is to augment the ACK packet with an acknowledgement field. When\nthe receiver generates an ACK, it will copy the sequence number of the data packet\nbeing ACK'ed into this acknowledgement field. By examining the contents of the\nacknowledgment field, the sender can determine the sequence number of the\npacket being positively acknowledged.\n\nrdt_send(data) rdt_rev(revpkt) &&\n\\. sndpkt = make_pkt(0, data, checksum) ( corrupt(revpkt) ||\n\n\\ udt_send(sndpkt) isACK(revpkt, 1) )\n\nrdt_rew(revpkt) \\_ start_timer A\nabove udt_send(sndpkt)\n\nstart_timer\n\nrdt_rev(revpkt)\n&& notcorrupt(revpkt)\n&& isACK(revpkt, 1)\n\nstop_timer\n\ntimeout\nudt_send(sne send(sndpkt) AE)\nstart_timer\n\nrdt_rev(revpkt)\n&& notcorrupt(revpkt)\n&& isACK(revpkt,0)\n\nstop_timer\n\nWait for\ncall 1 from\nabove\n\nrdt_rev(revpkt)\n\nA\nrdt_rev(revpkt) iS rdt_send(data)\n( corrupt(revpkt) || sndpkt = make_pkt(1, data, checksum)\nisACK(revpkt,0) ) udt_send(sndpkt)\nTTT start_timer\n\nA\nFig 12 rdt 3.0 Sender\n\nProf. Maulik Trivedi, CE Department | 2140709 — Computer Networks (CN) 13\n"
  },
  {
    "page_number": 14,
    "content": "Darshan\n\nInstitute of Engineering & Technology\n\n3 — Transport Layer\n\nSender Receiver\n\nsend pkt0 Pkto\n\n[\n\nrev pkto\npose send ACKO\n\n‘\n\nrev ACKO\nsend pktl u\nees rev pktl\nport send ACKl\nrev ACKl ae\nsend pkt0 ae\nrev pkt0\n\nPw send ACKO\n\na. Operation with no loss\n\nSender Receiver\n\nPk:\n\nsend pkt0 to\noe te rev pkt0O\n\naw send ACKO\nrev ACKO Pkey\nsend pktl tg rev pktl\n\nx\npce send ACKL\n(loss) X —\n\ntimeout\nresend pkt1 pkey\nPea rev pktl\npot (detect\nwail duplicate)\nrev ACK1 send ACK1\nsend pkt0 Pkto\nae rev pkt0\nsend ACKO\n\n\\.\n\nc. Lost ACK\n\nSender\n\nsend pkt0 Pkto\n\n[\n\npad\nrev ACKO Pky\nsend pktl —. (loss)\ntimeout\n\nresend pktl\n\nrev ACKL\nsend pkt0\n\n\\\n\nb. Lost packet\n\nSender\n\nsend pkt0 ko\n\n;\n\n9\n\nrev ACKO\nsend pktl [ ty\n\n[\\\n\ntimeout t? 4\nresend pktl S\nrev ACK1\nsend pkt0 : Pkto\n\nNy\n\nrev ACKL\ndo nothing\n\n°\n\nyy.\n\\\n\nd. Premature timeout\n\nFig. 13 Operation of rdt3.0, the alternating-bit protocol\n\nProtocol pipelining\n\nReceiver\n\nrev pkto\nsend ACKO\n\nrev pktl\nsend ACKl\n\nrev pktd\nsend ACKO\n\nReceiver\n\nrev pkt0\nsend ACKO\n\nrev pktl\nsend ACKl\n\nrev pkt 1\n(detect duplicate)\nsend ACK1\n\nrev pkt0\nsend ACKO\n\ne Protocol pipelining is a technique in which multiple requests are written out to a\nsingle socket without waiting for the corresponding responses (acknowledged).\ne Pipelining can be used in various application layer network protocols, like HTTP/1.1,\n\nSMTP and FTP.\n\ne Range of sequence numbers must be increased.\ne Data or Packet should be buffered at sender and/or receiver.\n\nTrivedi, CE Department | 2140709 — Computer Networks (CN)\n\n14\n"
  },
  {
    "page_number": 64,
    "content": "Darshan\n\nIaieieaed of Engineering a Tachactogy 3 — Transport Layer\n\nno pipelining pipelining\nclient server client server\nopen—-_ open—e-\n1 £\n= a closeq*\ni |\nnein ’ ’ '\n\nTwo generic forms of pipelined protocols are\n1. Go-Back-N\n2. Selective repeat\n\nGo-Back-N\n\nGo-Back-N ARQ is a specific instance of the automatic repeat request (ARQ) protocol,\nin which the sending process continues to send a number of frames specified by a\nwindow size even without receiving an acknowledgement (ACK) packet from the\nreceiver.\n\nThe receiver process keeps track of the sequence number of the next frame it\nexpects to receive, and sends that number with every ACK it sends.\n\nThe receiver will discard any frame that does not have the exact sequence number it\nexpects (either a duplicate frame it already acknowledged or an out-of-order frame\nit expects to receive later) and will resend an ACK for the last correct in-order frame.\nOnce the sender has sent all of the frames in its window, it will detect that all of the\nframes since the first lost frame are outstanding, and will go back to the sequence\nnumber of the last ACK it received from the receiver process and fill its window\nstarting with that frame and continue the process over again.\n\nGo-Back-N ARQ is a more efficient use of a connection than Stop-and-wait ARQ,\nsince unlike waiting for an acknowledgement for each packet; the connection is still\nbeing utilized as packets are being sent.\n\nHowever, this method also results in sending frames multiple times — if any frame\nwas lost or damaged or the ACK acknowledging them was lost or damaged then that\nframe and all following frames in the window (even if they were received without\nerror) will be re-sent. To avoid this, Selective Repeat ARQ can be used.\n\nHow does Go-Back-N ARQ protocol works:\n\nConsider a scenario given in fig 14 there are four frames 0,1,2,3 respectively. Now as\nsending window size is 3 it will send frame 0, 1 and 2 at atime.\n\nProf. Maulik Trivedi, CE Department | 2140709 — Computer Networks (CN) 15\n"
  },
  {
    "page_number": 65,
    "content": "Darshan\n\nInstitute of Engineering & Technology 3 -— Transport Layer\n\nData (0)\n\nData (1)\n\nData (2) ACK (0)\nACK (1)\nNAK (2)\n\nData (3)\n\nData (0)\n\nData (2)\n\nData (3)\nACK (2)\n\nTime\n\nFig. 14 Go-Back-N Protocol\nAt receiver side frame 0 arrives it sends ACK for that.\nNow at sender side window shift at frame 3 and it sends frame no 3.\nAt receiver side frame 1 arrives it sends ACK for that.\nNow at sender side window shift at frame 4 and it sends frame no 4.\nNow receiver detects frame 2 is missing or lost. It will send NAK for that.\nSender receives NAK at this point sending window is pointing towards frame 2, 3 and\n4 so send will resend frame 2, 3 and 4.\n\nSelective repeat\n\nSelective Repeat attempts to retransmit only those packets that are actually lost due\nto errors.\n\nReceiver must be able to accept packets out of order\n\nSince receiver must release packets to higher layer in order, the receiver must be\nable to buffer some packets\n\nThe receiver acknowledges every good packet, packets that are not ACKed before a\ntime-out are assumed lost or in error.\n\nNotice that this approach must be used to be sure that every packet is eventually\nreceived.\n\nAn explicit NAK (selective reject) can request retransmission of just one packet.\n\nThis approach can speed up the retransmission but is not strictly needed.\n\nProf. Maulik Trivedi, CE Department | 2140709 — Computer Networks (CN) 16\n"
  },
  {
    "page_number": 66,
    "content": "PD Darshan\n\n[aR of Engineurtega Techealogy 3 — Transport Layer\n\nSender Receiver\n\npktO sent\n0123456789\n\npktO revd, delivered, ACKO sent\n0123456789\n\npktl sent\n0123456789\n\npktl revd, delivered, ACK1 sent\n01123456789\n\nr— pkt2 sent\n0123456789\n\npkt3 sent, window full\n0123456789\n\npkt3 rcevd, buffered, ACK3 sent\nACKO revd, pkt4 sent 0123456789\n\n0123456789\n\npkt4 rcvd, buffered, ACK4 sent\n0123456789\n\nACK1 revd, pkt5 sent\n0123456789\n\npkt5 revd; buffered, ACK5S sent\n0123456789\n\n\\— pkt2 TIMEOUT, pkt2\nresent\n\n0123456789\npkt2 revd, pkt2,pkt3,pkt4,pkt5\ndelivered, ACK2 sent\n0123456789\n\nACK3 revd, nothing sent\n0123456789\n\nv v\n\nFig. 15 Selective Repeat\nTCP segment structure\n\n22 bits\n\nSource port # Dest port #\nSequence number\nAcknowledgment number\n\nInternet checksum Urgent data pointer\n\nFig. 16 TCP segment structure\ne The unit of transmission in TCP is called segments.\n\ne The header includes source and destination port numbers, which are used for\nmultiplexing/demultiplexing data from/to upper-layer applications.\n\nProf. Maulik Trivedi, CE Department | 2140709 — Computer Networks (CN) 17\n"
  },
  {
    "page_number": 67,
    "content": "Darshan\n\nIaieieaed of Engineering a Tachactogy 3 — Transport Layer\n\nThe 32-bit sequence number field and the 32-bit acknowledgment number field are\nused by the TCP sender and receiver in implementing a reliable data transfer service.\nThe sequence number for a segment is the byte-stream number of the first byte in\nthe segment.\n\nThe acknowledgment number is the sequence number of the next byte a Host is\nexpecting from another Host.\n\nThe 4-bit header length field specifies the length of the TCP header in 32-bit words.\nThe TCP header can be of variable length due to the TCP options field.\n\nThe 16-bit receive window field is used for flow control. It is used to indicate the\nnumber of bytes that a receiver is willing to accept.\n\nThe 16-bit checksum field is used for error checking of the header and data.\n\nUnused 6 bits are reserved for future use and should be sent to zero.\n\nUrgent Pointer is used in combining with the URG control bit for priority data\ntransfer. This field contains the sequence number of the last byte of urgent data.\nData: The bytes of data being sent in the segment.\n\nURG (1 bit): indicates that the Urgent pointer field is significant.\n\nACK (1 bit): indicates that the Acknowledgment field is significant.\n\nPSH (1 bit): Push function. Asks to push the buffered data to the receiving\napplication.\n\nRST (1 bit): Reset the connection.\n\nSYN (1 bit): Synchronize sequence numbers. Only the first packet sent from each end\nshould have this flag set. Some other flags and fields change meaning based on this\nflag, and some are only valid for when it is set, and others when it is clear.\n\nFIN (1 bit): No more data from sender.\n\nFlow Control\n\nIn data communications, flow control is the process of managing the rate of data\ntransmission between two nodes to prevent a fast sender from overwhelming a slow\nreceiver.\nIt prevent receiver from becoming overloaded.\nReceiver advertises a window rwnd with each acknowledgement\nWindow\n> closed (by sender) when data is sent and ack’d\n> opened (by receiver) when data is read\nThe size of this window can be the performance limit (e.g. on a LAN).\n\nCongestion Control\n\nWhen a connection is established, a suitable window size has to be chosen.\n\nThe receiver can specify a window based on its buffer size.\n\nIf the sender sticks to this window size, problems will not occur due to buffer\noverflow at the receiving end, but they may still occur due to internal congestion\nwithin the network.\n\nIn Figure 17 (a), we see a thick pipe leading to a small-capacity receiver.\n\nAs long as the sender does not send more water than the bucket can contain, no\nwater will be lost.\n\nProf. Maulik Trivedi, CE Department | 2140709 — Computer Networks (CN) 18\n"
  },
  {
    "page_number": 68,
    "content": "Darshan\n\nInstitute of Engineering & Technology 3 -— Transport Layer\n\ne In Figure 17 (b), the limiting factor is not the bucket capacity, but the internal\ncarrying capacity of the network.\n\nbe\n\nTransmission\nrate adjustment\n\nTransmission\n\nnetwork Internal\n\ncongestion\n\nSmall-capacity Large-capacity\nreceiver ~~ receiver\n\n(a) (b)\nFig. 17 TCP segment structure\n\ne Figure 17: (a) a fast network feeding a low capacity receiver. Figure 17: (b) A slow\nnetwork feeding a high-capacity receiver.\n\ne If too much water comes in too fast, it will back up and some will be lost (in this case\nby overflowing the funnel).\n\ne Each sender maintains two windows: the window the receiver has granted and a\nsecond window, the congestion window.\n\ne ach reflects the number of bytes the sender may transmit.\n\ne The number of bytes that may be sent is the minimum of the two windows.\n\ne Thus, the effective window is the minimum of what the sender thinks is all right and\nwhat the receiver thinks is all right.\n\ne When a connection is established, the sender initializes the congestion window to\nthe size of the maximum segment in use on the connection.\n\ne It then sends one maximum segment.\n\ne If this segment is acknowledged before the timer goes off, it adds one segment's\nworth of bytes to the congestion window to make it two maximum size segments\nand sends two segments.\n\ne As each of these segments is acknowledged, the congestion window is increased by\none maximum segment size.\n\ne When the congestion window is n segments, if all n are acknowledged on time, the\ncongestion window is increased by the byte count corresponding to n segments.\n\nTCP Slow Start\n\ne Slow-start is part of the congestion control strategy used by TCP, the data\n\ntransmission protocol used by many Internet applications.\n\nProf. Maulik Trivedi, CE Department | 2140709 — Computer Networks (CN) 19\n"
  },
  {
    "page_number": 69,
    "content": "@\nC Darshan 3 — Transport Layer\n\nInstitute of Engineering & Technology\n\ne Slow-start is used in conjunction with other algorithms to avoid sending more data\nthan the network is capable of transmitting to avoid causing network congestion.\n\nf segments\n\nFig. 18 TCP Slow start\n\ne Slow-start begins initially with a congestion window Size (cwnd) of 1, 2 or 10.\n\ne The value of the Congestion Window will be increased with each acknowledgement\n(ACK) received, effectively doubling the window size each round trip time (\"although\nit is not exactly exponential because the receiver may delay its ACKs, typically\nsending one ACK for every two segments that it receives).\n\ne The transmission rate will be increased with slow-start algorithm until either a loss is\ndetected, or the receiver's advertised window (rwnd) is the limiting factor, or the\nslow start threshold (ssthresh) is reached.\n\ne If a loss event occurs, TCP assumes that it is due to network congestion and takes\nsteps to reduce the offered load on the network.\n\ne Once ssthresh is reached, TCP changes from slow-start algorithm to the linear\ngrowth (congestion avoidance) algorithm. At this point, the window is increased by 1\nsegment for each RTT.\n\nProf. Maulik Trivedi, CE Department | 2140709 — Computer Networks (CN) 20\n"
  },
  {
    "page_number": 70,
    "content": "D D ar shan 4 —- Network Layer\n\nInstitute of Engineering & Technology\n\nRouting and Forwarding\n\nFigure 1 shows a simple network with two hosts, H1 and H2, and several routers on the path\nbetween H1 and H2.\n\nSuppose that H1 is sending information to H2, and consider the role of the network layer in\nthese hosts and in the intervening routers.\n\nThe network layer in H1 takes segments from the transport layer in H1, encapsulates each\nsegment into a datagram (that is, a network-layer packet), and then sends the datagrams to its\nnearby router, R1.\n\nAt the receiving host, H2, the network layer receives the datagrams from its nearby router R2,\nextracts the transport-layer segments, and delivers the segments up to the transport layer at\nH2.\n\nThe primary role of the routers is to forward datagrams from input links to output links.\n\nNational or\nie . Global ISP\n\nEnd system H1\n\nApplication ]\nTransport\n\nData link\nPhysical\n\nPhysical\n\nRouter R2\n\nData link\n\nPhysical\n\nEnd system H2\n\nApplication\n\n| Went |\n\nEnterprise Network\n\nPhysical\n\nFig. 1 Network Layer\n\nProf. Maulik Trivedi, CE Department | 2140709 — Computer Networks (CN) 1\n"
  },
  {
    "page_number": 71,
    "content": "Darshan\n\nInstitute of Engineering & Technology 4- Network Layer\n\ne The role of the network layer is thus deceptively simple—to move packets from a sending host\nto a receiving host. To do so, two important network-layer functions can be identified:\n\n>\n\n>\n\nForwarding: When a packet arrives at a router’s input link, the router must move the\npacket to the appropriate output link.\n\nFor example, a packet arriving from Host H1 to Router R1 must be forwarded to the next\nrouter ona path to H2.\n\nRouting: Routing is the process of selecting best paths in a network.\n\nThe network layer must determine the route or path taken by packets as they flow from\na sender to a receiver.\n\nThe algorithms that calculate these paths are referred to as routing algorithms. A\nrouting algorithm would determine, for example, the path along which packets flow\nfrom H1 to H2.\n\ne Every router has a forwarding table. A router forwards a packet by examining the value of a\nfield in the arriving packet’s header, and then using this header value to index into the router’s\nforwarding table.\n\ne The value stored in the forwarding table entry for that header indicates the router’s outgoing\nlink interface to which that packet is to be forwarded.\n\ne Depending on the network-layer protocol, the header value could be the destination address of\nthe packet or an indication of the connection to which the packet belongs.\n\nNetwork service model\ne Services provided by network layer for individual datagrams\n\n1.\n\nGuaranteed delivery: This service guarantees that the packet will eventually arrive at its\ndestination.\n\nGuaranteed delivery with bounded delay: This service not only guarantees delivery of\nthe packet, but delivery within a specified host-to-host delay bound (for example, within\n100 msec).\n\ne Services provided by network layer for a flow of datagrams\n\n3.\n\n4.\n\nIn-order packet delivery: This service guarantees that packets arrive at the destination\nin the order that they were sent.\n\nGuaranteed minimal bandwidth: This network-layer service emulates the behaviour of\na transmission link of a specified bit rate (for example, 1 Mbps) between sending and\nreceiving hosts. As long as the sending host transmits bits at a rate below the specified\nbit rate, then no packet is lost.\n\nGuaranteed maximum jitter: This service guarantees that the amount of time between\nthe transmission of two successive packets at the sender is equal to the amount of time\nbetween their receipt at the.\n\nSecurity services: Using a secret session key known only by a source and destination\nhost, the network layer in the source host could encrypt the payloads of all datagrams\nbeing sent to the destination host. The network layer in the destination host would then\nbe responsible for decrypting the payloads. With such a service, confidentiality would be\nprovided to all transport-layer segments (TCP and UDP) between the source and\ndestination hosts.\n\nProf. Maulik Trivedi, CE Department | 2140709 — Computer Networks (CN) 2\n"
  },
  {
    "page_number": 72,
    "content": "D Darshan\n\nInstitute of Engineering & Technology 4- Network Layer\n\nVirtual and Datagram networks\n\nVirtual Circuit Switching (Connection Oriented Service)\n\ne AVC consists of\n1. a path (that is, a series of links and routers) between the source and destination hosts\n2. VC numbers, one number for each link along the path\n3. Entries in the forwarding table in each router along the path.\n\ne A packet belonging to a virtual circuit will carry a VC number in its header. Because a virtual circuit\nmay have a different VC number on each link, each intervening router must replace the VC number\nof each traversing packet with a new VC number.\n\ne The new VC number is obtained from the forwarding table.\n\n4\n\nVC number\n\ng . interface\nforwarding table in number\n\nnorthwest router:\n\nIncoming interface | Incoming VC # | Outgoing interface | Outgoing VC #\n\n1 12 3 22\n2 63 1 18\n3 7 2 17\n1 97 3 87\n\nFig. 2 A simple virtual circuit network\n\ne The numbers next to the links of R1 in above figure are the link interface numbers.\n\ne Suppose now that Host A requests that the network establishes a VC between itself and Host B.\n\ne Suppose also that the network chooses the path A-R1-R2-B and assigns VC numbers 12, 22 and 32 to\nthe three links in this path for this virtual circuit.\n\ne In this case, when a packet in this VC leaves Host A, the value in the VC number field in the packet\nheader is 12; when it leaves R1, the value is 22; and when it leaves R2, the value is 32.\n\ne How does the router determine the replacement VC number for a packet traversing the router? For\na VC network, each router’s forwarding table includes VC number translation; for example, the\nforwarding table in R1 might look something like above fig. 2\n\ne Whenever a new VC is established across a router, an entry is added to the forwarding table.\n\ne Similarly, whenever a VC terminates, the appropriate entries in each table along its path are\nremoved.\n\ne Apath from the source router to the destination router must be established before any data packets\ncan be sent.\n\ne This connection is called a VC (virtual circuit), and the subnet is called a virtual-circuit subnet.\n\nProf. Maulik Trivedi, CE Department | 2140709 — Computer Networks (CN) 3\n"
  },
  {
    "page_number": 73,
    "content": "Darshan\n\nInstitute of Engineering & Technology 4 — Network Layer\n\ne When aconnection is established, a route from the source machine to the destination machine is\nchosen as part of the connection setup and stored in tables inside the routers.\n\ne That route is used for all traffic flowing over the connection, exactly the same way that the\ntelephone system works.\n\n| Application Application\n/4. Call connected 3. Accept call\n\nTransport Transport\n\n5. Data flow 6. Receive —\n\nData link\n\nPhysical\n\n1. Initiate call\n\nData link\nPhysical\n\n2. Incoming call\n\nFig. 3 Virtual-Circuit Setup\ne There are three identifiable phases in a virtual circuit:\n1. VCsetup:\n= During the setup phase, the sending transport layer contacts the network layer,\nspecifies the receiver’s address, and waits for the network to set up the VC.\n= The network layer determines the path between sender and receiver, that is, the\nseries of links and routers through which all packets of the VC will travel.\n= The network layer also determines the VC number for each link along the path.\n= Finally, the network layer adds an entry in the forwarding table in each router along\nthe path. During VC setup, the network layer may also reserve resources (for\nexample, bandwidth) along the path of the VC.\n2. Data transfer:\n= As shown in Figure 3, once the VC has been established, packets can begin to flow\nalong the VC.\n3. VC teardown:\n= This is initiated when the sender (or receiver) informs the network layer of its\ndesire to terminate the VC.\n= The network layer will then typically inform the end system on the other side of the\nnetwork of the call termination and update the forwarding tables in each of the\npacket routers on the path to indicate that the VC no longer exists.\nDatagram Network (Connection-Less Service)\ne In connection less service, packets are injected into the subnet individually and routed\nindependently of each other.\ne No advance setup is needed. In this context, the packets are frequently called datagrams (in analogy\nwith telegrams) and the subnet is called a datagram subnet.\ne Suppose that the process P1 in Figure 4 has a long message for P2. It hands the message to the\ntransport layer with instructions to deliver it to process P2 on host H2.\n\nProf. Maulik Trivedi, CE Department | 2140709 — Computer Networks (CN) 4\n\n"
  },
  {
    "page_number": 74,
    "content": "B\n\nDarshan\n\nInstitute of Engineering & Technology\n\n4 —- Network Layer\n\ne Let us assume that the message is four times longer than the maximum packet size, so the network\nlayer has to break it into four packets, 1, 2, 3, and 4 and sends each of them in turn to router A using\nsome point-to-point protocol, for example, PPP.\n\nApplication Application\nTransport Transport\n1. Send 2. Receive\n——— Data link data Data link _——\niz) Physical Physical a\nSs —_——_\n\nFig. 4 Datagram Network\n\ne Atthis point the carrier takes over. Every router has an internal table telling it where to send packets\nfor each possible destination. Each table entry is a pair consisting of a destination and the outgoing\nline to use for that destination.\n\ne Only directly-connected lines can be used.\n\nDatagram Network vs. Virtual Circuit Network\n\naddress\n\nIssue Datagram Virtual Circuit\nConnection Setup | None Required\nAddressing Packet contains full source and destination | Packet contains short virtual circuit\n\nnumber identifier.\n\nState Information\n\nNone other than\ndestination network\n\nrouter table containing\n\nEach virtual circuit number entered\nto table on setup, used for routing.\n\nRouting\n\nPackets routed independently\n\nRoute established at setup, all\n\npackets follow same route.\n\nEffect of Router\nFailure\n\nOnly on packets lost during crash\n\nAll virtual circuits passing through\nfailed router terminated.\n\nCongestion\nControl\n\nDifficult since all packets routed independently\nrouter resource requirements can vary.\n\nSimple by pre-allocating enough\nbuffers to each virtual circuit at\nsetup, since maximum number of\ncircuits fixed.\n\nRouter architecture\ne Routers have four components:\n1. Input ports\n2. Switching fabric\n3. Output ports\n4. Routing processor\n\nProf. Maulik Trivedi, CE Department\n\n| 2140709 — Computer Networks (CN)\n\n"
  },
  {
    "page_number": 75,
    "content": "Darshan\n\nInstitute of Engineering & Technology 4 — Network Layer\n\nRouting\n\n; processor\nRouting, management\n\ncontrol plane (software)\nForwarding\ndata plane (hardware)\n\nInput port Output port\nam me, a 2.\nSwitch\nInput port Output port\n\nFig. 5 Router architecture\n\nInput ports\n\ne An input port performs several key functions.\n\ne It performs the physical layer function of terminating an incoming physical link at a router; this is\nshown in the leftmost box of the input port and the rightmost box of the output port in Figure 5.\n\ne An input port also performs link-layer functions needed to interoperate with the link layer at the\nother side of the incoming link; this is represented by the middle boxes in the input and output\nports.\n\ne Perhaps most crucially, the lookup function is also performed at the input port; this will occur in the\nrightmost box of the input port. It is here that the forwarding table is consulted to determine the\nrouter output port to which an arriving packet will be forwarded via the switching fabric.\n\ne Control packets (for example, packets carrying routing protocol information) are forwarded from an\ninput port to the routing processor.\n\nSwitching fabric\n\ne The switching fabric connects the router’s input ports to its output ports.\n\ne This switching fabric is completely contained within the router - a network inside of a network\nrouter!\n\nOutput ports\n\ne An output port stores packets received from the switching fabric and transmits these packets on the\noutgoing link by performing the necessary link-layer and physical-layer functions.\n\ne When alink is bidirectional (that is, carries traffic in both directions), an output port will typically be\npaired with the input port for that link on the same line card.\n\nRouting processor\n\ne The routing processor executes the routing protocols, maintains routing tables and attached link\nstate information and computes the forwarding table for the router.\n\ne It also performs the network management functions.\n\nProf. Maulik Trivedi, CE Department | 2140709 — Computer Networks (CN) 6\n"
  },
  {
    "page_number": 76,
    "content": "Darshan\n\nInstitute of Engineering & Technology 4 — Network Layer\n\nTypes of switching fabrics\n\nThree types of switching fabrics\n1. Switching via memory\n2. Switching via a bus\n3. Switching via an interconnection network\n\nSwitching via memory\n\nThe simplest, earliest routers were traditional computers, with switching between input and output\nports being done under direct control of the CPU (routing processor).\n\nAn input port with an arriving packet first signalled the routing processor via an interrupt. The\npacket was then copied from the input port into processor memory.\n\nThe routing processor then extracted the destination address from the header, looked up the\nappropriate output port in the forwarding table, and copied the packet to the output port’s buffers.\nIn this scenario, if the memory bandwidth is such that B packets per second can be written into, or\nread from, memory, then the overall forwarding throughput must be less than B/2.\n\nNote also that two packets cannot be forwarded at the same time, even if they have different\ndestination ports, since only one memory read/write over the shared system bus can be done at a\ntime.\n\nMemory Crossbar\n\n>I\n\nKey:\nCO ft] input port f=) (10 output port\n\nFig. 6 Three switching techniques\n\nSwitching via a bus\n\nIn this approach, an input port transfers a packet directly to the output port over a shared bus,\nwithout intervention by the routing processor.\n\nProf. Maulik Trivedi, CE Department | 2140709 — Computer Networks (CN) 7\n"
  },
  {
    "page_number": 77,
    "content": "Darshan\n\nInstitute of Engineering & Technology 4- Network Layer\n\nThis is typically done by having the input port pre-pend a switch-internal label (header) to the packet\nindicating the local output port to which this packet is being transferred and transmitting the packet\nonto the bus.\n\nThe packet is received by all output ports, but only the port that matches the label will keep the\npacket.\n\nThe label is then removed at the output port, as this label is only used within the switch to cross the\nbus.\n\nIf multiple packets arrive to the router at the same time, each at a different input port, all but one\nmust wait since only one packet can cross the bus at a time. Because every packet must cross the\nsingle bus, the switching speed of the router is limited to the bus speed.\n\nSwitching via an interconnection network\n\nOne way to overcome the bandwidth limitation of a single, shared bus is to use a more sophisticated\ninterconnection network, such as those that have been used in the past to interconnect processors\nin a multiprocessor computer architecture.\n\nA crossbar switch is an interconnection network consisting of 2N buses that connect N input ports to\nN output ports, as shown in Figure 6.\n\nEach vertical bus intersects each horizontal bus at a crosspoint, which can be opened or closed at\nany time by the switch fabric controller (whose logic is part of the switching fabric itself).\n\nWhen a packet arrives from port A and needs to be forwarded to port Y, the switch controller closes\nthe crosspoint at the intersection of busses A and Y, and port A then sends the packet onto its bus,\nwhich is picked up (only) by bus Y.\n\nNote that a packet from port B can be forwarded to port X at the same time, since the A-to-Y and B-\nto-X packets use different input and output busses.\n\nThus, unlike the previous two switching approaches, crossbar networks are capable of forwarding\nmultiple packets in parallel.\n\nHowever, if two packets from two different input ports are destined to the same output port, then\none will have to wait at the input, since only one packet can be sent over any given bus at a time.\n\nIPv4 datagram format\n\nVersion number: These 4 bits specify the IP protocol version of the datagram. It determines how to\ninterpret the header. Currently the only permitted values are 4 (0100) or 6 (0110).\n\nHeader length: Specifies the length of the IP header, in 32-bit words.\n\nType of service: The type of service (TOS) bits were included in the IPv4 header to allow different\ntypes of IP datagrams (for example, datagrams particularly requiring low delay, high throughput, or\nreliability) to be distinguished from each other.\n\nDatagram length: This is the total length of the IP datagram (header plus data), measured in bytes.\nIdentifier: Uniquely identifies the datagram. It is incremented by 1 each time a datagram is sent. All\nfragments of a datagram contain the same identification value. This allows the destination host to\ndetermine which fragment belongs to which datagram.\n\nFlags: In order for the destination host to be absolutely sure it has received the last fragment of the\noriginal datagram, the last fragment has a flag bit set to 0, whereas all the other fragments have this\nflag bit set to 1.\n\nFragmentation offset: When fragmentation of a message occurs, this field specifies the offset, or\nposition, in the overall message where the data in this fragment goes. It is specified in units of 8\nbytes (64 bits).\n\nProf. Maulik Trivedi, CE Department | 2140709 — Computer Networks (CN) 8\n"
  },
  {
    "page_number": 78,
    "content": "Darshan\n\n[niahevtd of Engineering @ioehiclésy 4—- Network Layer\n\n32 bits\n|\nI\nHead\nVersion | anyth Type of service Datagram length (bytes)\n16-bit Identifier Flags 13-bit Fragmentation offset\nTime-to-live Uppelarss Header checksum\n\nprotocol\n\n32-bit Source IP address\n32-bit Destination IP address\nOptions (if any)\nData\n\nFig. 7 IPv4 datagram format\nTime-to-live: Specifies how long the datagram is allowed to “live” on the network. Each router\ndecrements the value of the TTL field (reduces it by one) prior to transmitting it. If the TTL field\ndrops to zero, the datagram is assumed to have taken too long a route and is discarded.\nProtocol: This field is used only when an IP datagram reaches its final destination. The value of this\nfield indicates the specific transport-layer protocol to which the data portion of this IP datagram\nshould be passed. For example, a value of 6 indicates that the data portion is passed to TCP, while a\nvalue of 17 indicates that the data is passed to UDP.\nHeader checksum: The header checksum aids a router in detecting bit errors in a received IP\ndatagram.\nSource and destination IP addresses: When a source creates a datagram, it inserts its IP address\ninto the source IP address field and inserts the address of the ultimate destination into the\ndestination IP address field.\nOptions: The options fields allow an IP header to be extended.\nData (payload): The data to be transmitted in the datagram, either an entire higher-layer message\nor a fragment of one.\n\nIP addressing: Introduction\n\nIP address: It is 32-bit identifier for host, router interface\nInterface: It is a connection between host/router and physical link.\n> Arouter’s typically have multiple interfaces\n> Ahost typically has one or two interfaces\nThere is an IP addresses associated with each interface.\nSubnets: To determine the subnets, detach each interface from its host or router, creating islands of\nisolated networks, with interfaces terminating the end points of the isolated networks. Each of\nthese isolated networks is called a subnet.\nSubnet part: high order bits defines subnet\nHost part: low order bits defines host.\n\nProf. Maulik Trivedi, CE Department | 2140709 — Computer Networks (CN) 9\n"
  },
  {
    "page_number": 79,
    "content": "©) Darshan\n\nInstitute of Engineering & Technology 4- Network Layer\n\n223.1.1.1\n22311A B28 223.1.2.1\nP~223.1.3.27\n223.1.1.2\n223.1.2.2\n2231.13\n\n223.1.3.1 223.1.3.2\n\nFig. 8 Interface addresses and subnets\n\nClassification of IP Addresses (Classful Addressing)\n\nClass: A\n7 Bit 24 Bit\nFix Network ID ~Y Host ID\nClass: B\nce Ne 14 Bit 16 Bit Dy)\nNetwork IDV Host IDV\nClass: C\nFix 21 Bit 8 Bit J\nNetwork ID Vv ~Y~ Host ID\nClass: D\nEE A\nFix & DD\nClass: E ~Y Multicast address\nFix ~~” Reserved address\n\nCIDR (Classless Inter-Domain Routing)\n\ne Originally, IP addresses were assigned in four major address classes, A through D.\n\nProf. Maulik Trivedi, CE Department | 2140709 — Computer Networks (CN) 10\n"
  },
  {
    "page_number": 11,
    "content": "Darshan\n\nInstitute of Engineering & Technology\n\nEach of these classes allocates one portion of the 32-bit IP address format to identify a network\ngateway - the first 8 bits for class A, the first 16 for class B, and the first 24 for class C. The remainder\nidentify hosts on that network.\n\ne More than 16 million in class A, 65,535 in class B and 254 in class C. (Class D addresses identify\nmulticast domains.)\n\ne To illustrate the problems with the class system, consider that one of the most commonly used\nclasses was Class B.\n\ne An organization that needed more than 254 host machines (500 hosts) would often get a Class B\nlicense, even though it would have far fewer than 65,534 hosts.\n\ne This resulted in most of the block of addresses allocated going unused.\n\ne CIDR reduced the problem of wasted address space by providing a new and more flexible way to\nspecify network addresses in routers.\n\ne Asingle IP address can be used to designate many unique IP addresses with CIDR.\n\ne A CIDR IP address looks like a normal IP address except that it ends with a slash followed by a\nnumber, called the IP network prefix. CIDR addresses reduce the size of routing tables and make\nmore IP addresses available within organizations.\n\nsubnet\npart part\n11001000 00010111 00010000 00000000\n\n200.23.16.0/23\n\n4 —- Network Layer\n\nhost\n\n_—_—_—_—_\n\nIP Addressing Summary:\n\nSize Default subnet\n\nSi:\nLeading of network ze Number Addresses _ Total addresses Start mask in dot- CIDR\nClass \" of rest . End address . \"\nbits number bit ,.. ,. of networks | per network in class address decimal notation\n- bit field 7\nfield notation\n16,777,216 2,147,483,648\nClass A ) 8 24 128 (27) (224) (231) 0.0.0.0 127.255.255.255 255.0.0.0 /8\n16,384 65,536 1,073,741,824\nClass B 10 16 16 (a8) (26) (230) 128.0.0.0 191.255.255.255 | 255.255.0.0  /16\nClass C 110 24 8 ee 256 (28) = 192.0.0.0 223.255.255.255 | 255.255.255.0 124\nClass D not not not not 268,435,456 7 not\n(multicast) 1110 defined defined defined defined (228) EDOOO | BOARS || mebeeiinss) defined\nClass E not not not not 268,435,456 ' not\n1111 oe, 240.0.0.0 255.255.255.255 st defined\nreserve lefine jefine lefine lefine not detine! jefine\nd) defined defined defined defined pe defined\n\nDHCP: Dynamic Host Configuration Protocol\n\ne Dynamic Host Configuration Protocol is a protocol for assigning dynamic IP addresses to devices ona\n\nnetwork.\n\nProf. Maulik Trivedi, CE Department\n\n| 2140709 — Computer Networks (CN)\n\n11\n"
  },
  {
    "page_number": 12,
    "content": "Darshan\n\nInstitute of Engineering & Technology\n\n223.1.1.0/24\n\n223.1.3.1\n\nDHCP\nserver\n\n‘|\n\n223.1.2.0/24\n\n1.3.2\n\n223.1.3.0/24\nFig. 9 DHCP client-server scenario\n\nDHCP server: 223.1.2.5 DHCP discover\n\nBroadcast: is there a\nDHCP server out there?\n\n4—- Network Layer\n\narriving DHCP\nclient needs\naddress in this\nnetwork\n\narriving\nclient\n\nDHCP offer\n\nserver! Here's an IP\naddress you can use\n\nDHCP request\n\nBroadcast: I’m a DHCP\n\nBroadcast: OK. I'll take |\n\nthat IP address!\n\nFig. 10 DHCP client-server interaction\n\nDHCP server discovery\n\nDHCP ACK\n\nBroadcast: OK. You've\n\ngot that IP address!\n\ne = The first task of a newly arriving host is to find a DHCP server with which to interact.\n\ne This is done using a DHCP discover message, which a client sends within a UDP packet to port 67.\n\nProf. Maulik Trivedi, CE Department\n\n| 2140709 — Computer Networks (CN)\n\nWith dynamic addressing, a device can have a different IP address every time it connects to the\n\nnetwork.\nIn some systems, the device's IP address can even change while it is still connected. It allows reuse\n\nof addresses (only hold address while connected “on”). It also support mobile users who want to\njoin network.\n\n12\n"
  },
  {
    "page_number": 82,
    "content": "Darshan\n\nInstitute of Engineering & Technology 4- Network Layer\n\nThe UDP packet is encapsulated in an IP datagram. But to whom should this datagram be sent? The\nhost doesn’t even know the IP address of the network to which it is attaching.\n\nGiven this, the DHCP client creates an IP datagram containing its DHCP discover message along with\nthe broadcast destination IP address of 255.255.255.255 and a “this host” source IP address of\n0.0.0.0.\n\nThe DHCP client passes the IP datagram to the link layer, which then broadcasts this frame to all\nnodes attached to the subnet.\n\nDHCP server offer(s)\n\nA DHCP server receiving a DHCP discover message responds to the client with a DHCP offer message\nthat is broadcast to all nodes on the subnet, again using the IP broadcast address of\n255.255.255.255.\n\nSince several DHCP servers can be present on the subnet, the client may find itself in the enviable\nposition of being able to choose from among several offers.\n\nEach server offer message contains the transaction ID of the received discover message, the\nproposed IP address for the client, the network mask, and an IP address lease time - the amount of\ntime for which the IP address will be valid.\n\nDHCP request\n\nThe newly arriving client will choose from among one or more server offers and respond to its\nselected offer with a DHCP request message, echoing back the configuration parameters.\n\nDHCP ACK\n\nThe server responds to the DHCP request message with a DHCP ACK message, confirming the\nrequested parameters.\n\nNetwork Address Translation (NAT)\n\nThe Internet has grown larger than anyone ever imagined it could be.\n\nAlthough the exact size is unknown, the current estimate is that there are about 100 million hosts\nand more than 350 million users actively on the Internet.\n\nIn fact, the rate of growth has been such that the Internet is effectively doubling in size each year.\nSo what does the size of the Internet have to do with NAT? For a computer to communicate with\nother computers and Web servers on the Internet, it must have an IP address.\n\nAn IP address is a unique 32-bit number that identifies the location of your computer on a network.\nWhen IP addressing first came out, everyone thought that there were sufficiently of addresses to\ncover any need. Theoretically, you could have 4,294,967,296 unique addresses (232). The actual\nnumber of available addresses is smaller (somewhere between 3.2 and 3.3 billion) because of the\nway that the addresses are separated into classes, and because some addresses are set aside for\nmulticasting, testing or other special uses.\n\nWith the explosion of the Internet and the increase in home networks and business networks, the\nnumber of available IP addresses is simply not enough.\n\nThe obvious solution is to redesign the address format to allow for more possible addresses. This is\nbeing developed (called IPv6), but will take several years to implement because it requires\nmodification of the entire infrastructure of the Internet.\n\nThis is where NAT (RFC 1631) comes to the rescue.\n\nNetwork Address Translation allows a single device, such as a router, to act as an agent between the\nInternet (or \"public network\") and a local (or \"private\") network.\n\nProf. Maulik Trivedi, CE Department | 2140709 — Computer Networks (CN) 13\n"
  },
  {
    "page_number": 83,
    "content": "Darshan\n\nInstitute of Engineering & Technology 4- Network Layer\n\ne This means that only a single, unique IP address is required to represent an entire group of\ncomputers.\n\nNAT translation table\n\nWAN side LAN side\n138.76.29.7, 5001 10.0.0.1, 3345\n\n5 = 10.0.0.1, 3345\n\nD = 128.119.40.186, 80 | 10.0.0.1\n——\na @ ee 5001 ]\n25 D=128.119.40.186, 80\na_i 10.0.0.4 | FI) 10002\n\n~~)\n\nS\ney ae —\n\n><\ns (4)\nS$ = 128.119.40.186, 80 3) $= 128.119.40.186, 80\nD = 138.76.29.7, 5001 ~ D = 10.0.0.1, 3345\nre 10.0.0.3\n\nFig. 11 Network address translation\n\nICMP: Internet Control Message Protocol\n\ne When something unexpected occurs, the event is reported by the ICMP (Internet Control Message\nProtocol), which is also used to test the Internet.\n\ne About a dozen types of ICMP messages are defined. The most important ones are listed below. Each\nICMP message type is encapsulated in an IP packet.\n\nMessage Type Description\n\nDestination unreachable Packet could not be delivered\n\nTime exceeded Time to live field hit 0\n\nParameter problem Invalid header field\n\nSource quench Choke packet\n\nRedirect Teach a router about geography\n\nEcho Ask a machine if it is alive\n\nEcho reply Yes, | am alive\n\nTimestamp request Same as Echo request, but with timestamp\n\nTimestamp reply Same as Echo reply, but with timestamp\n\ne The DESTINATION UNREACHABLE message is used when the subnet or a router cannot locate the\ndestination or when a packet with the DF bit cannot be delivered because a \"small-packet\" network\nstands in the way.\n\ne The TIME EXCEEDED message is sent when a packet is dropped because its counter has reached\nzero.\n\ne The PARAMETER PROBLEM message indicates that an illegal value has been detected in a header\nfield.\n\nProf. Maulik Trivedi, CE Department | 2140709 — Computer Networks (CN) 14\n"
  },
  {
    "page_number": 84,
    "content": "Darshan\n\nInstitute of Engineering & Technology 4- Network Layer\n\ne This problem indicates a bug in the sending host's IP software or possibly in the software of a router\ntransited.\n\ne The SOURCE QUENCH message was formerly used to throttle hosts that were sending too many\npackets. When a host received this message, it was expected to slow down.\n\ne The REDIRECT message is used when a router notices that a packet seems to be routed wrong. It is\nused by the router to tell the sending host about the probable error.\n\ne The ECHO and ECHO REPLY messages are used to see if a given destination is reachable and alive.\n\ne Upon receiving the ECHO message, the destination is expected to send an ECHO REPLY message\nback.\n\ne The TIMESTAMP REQUEST and TIMESTAMP REPLY messages are similar, except that the arrival time\nof the message and the departure time of the reply are recorded in the reply.\n\nIPv6 Datagram Format\n32 ine\n\nVersion Traffic class Flow label\n\nPayload length Next hdr Hop limit\n\nSource address\n(128 bits)\n\nDestination address\n(128 bits)\n\nData\n\nFig. 12 IPv6 datagram format\n\ne Version: The size of the Version field is 4 bits. The Version field shows the version of IP and is set to\n6.\n\ne Traffic Class: The size of Traffic Class field is 8 bits. Traffic Class field is similar to the IPv4 Type of\nService (ToS) field. The Traffic Class field indicates the IPv6 packet’s class or priority.\n\ne Flow Label: The size of Flow Label field is 20 bits. The Flow Label field provide additional support for\nreal-time datagram delivery and quality of service features. The purpose of Flow Label field is to\nindicate that this packet belongs to a specific sequence of packets between a source and destination\nand can be used to prioritized delivery of packets for services like voice.\n\ne Payload Length: The size of the Payload Length field is 16 bits. The Payload Length field shows the\nlength of the IPv6 payload, including the extension headers and the upper layer protocol data\n\ne Next Header: The size of the Next Header field is 8 bits. The Next Header field shows either the type\nof the first extension (if any extension header is available) or the protocol in the upper layer such as\nTCP, UDP, or ICMPv6.\n\ne Hop Limit: The size of the Hop Limit field is 8 bits The Hop Limit field shows the maximum number of\nrouters the IPv6 packet can travel. This Hop Limit field is similar to IPv4 Time to Live (TTL) field.\n\ne Source Address: The size of the Source Address field is 128 bits. The Source Address field shows the\nIPv6 address of the source of the packet.\n\nProf. Maulik Trivedi, CE Department | 2140709 — Computer Networks (CN) 15\n"
  },
  {
    "page_number": 85,
    "content": "Difference between IPv4 and IPv6\n\nDarshan\n\nInstitute of Engineering & Technology\n\nB\n\n4 —- Network Layer\n\nDestination Address: The size of the Destination Address field is 128 bits. The Destination Address\nfield shows the IPv6 address of the destination of the packet.\nData: The data to be transmitted in the datagram, either an entire higher-layer message or a\n\nfragment of one.\n\nIPv4\n\nIPv6é\n\nIPv4 addresses are 32 bit length.\n\nIPv6 addresses are 128 bit length.\n\nFragmentation is done by sender and\n\nforwarding routers.\n\nFragmentation is done only by sender.\n\nNo packet flow identification.\n\nPacket flow identification is available within\nthe IPv6 header using the Flow Label field.\n\nChecksum field is available in header\n\nNo checksum field in header.\n\nOptions fields are available in header.\n\nNo option fields, but Extension headers are\navailable.\n\nAddress Resolution Protocol (ARP)is available\nto map IPv4 addresses to MAC addresses.\n\nAddress Resolution Protocol (ARP) is replaced\nwith Neighbour Discovery Protocol.\n\nBroadcast messages are available.\n\nBroadcast messages are not available.\n\nManual configuration (Static) of IP addresses\n\nAuto-configuration of addresses is available.\n\nor DHCP (Dynamic configuration) is required to\nconfigure IP addresses.\n\nThe Link-State (LS) Routing Algorithm (Dijkstra’s algorithm)\n\ne —Dijkstra’s algorithm computes the least-cost path from one node (the source, which we will refer to\nas u) to all other nodes in the network.\n\ne Dijkstra’s algorithm is iterative and has the property that after the k\" iteration of the algorithm, the\nleast-cost paths are known to k destination nodes, and among the least-cost paths to all destination\nnodes, these k paths will have the k smallest costs.\n\ne Let us define the following notation:\n\n> D(v): cost of the least-cost path from the source node to destination v as of this iteration of the\nalgorithm.\n\n> p(v): previous node (neighbor of v) along the current least-cost path from the source to v.\n\n> N’: subset of nodes; v is in N’ if the least-cost path from the source to v is definitively known.\n\ne The global routing algorithm consists of an initialization step followed by a loop.\n\ne The number of times the loop is executed is equal to the number of nodes in the network.\n\ne Upon termination, the algorithm will have calculated the shortest paths from the source node u to\nevery other node in the network.\n\ne Asan example, let’s consider the network in Figure 13 and compute the least-cost paths from u to\n\nall possible destinations.\n\nProf. Maulik Trivedi, CE Department | 2140709 — Computer Networks (CN) 16\n"
  },
  {
    "page_number": 86,
    "content": "Darshan\n\nInstitute of Engineering & Technology 4 — Network Layer\n\nFig. 13 Abstract graph model of a computer network\n\n1 Initialization:\n\n2 N’ = {u}\n\n3 for all nodes v\n\n4 if v is a neighbor of u\n\n5 then D(v) = c(u,v)\n\n6 else D(v) = =\n\n7\n\n8 Loop\n\n9 find w not in N’ such that D(w) is a minimum\n\n10 add w to N’\n\n11 update D(v) for each neighbor v of w and not in N’:\n12 D(v) = min( D(v), D(w) + c(w,v) )\n\n13 /* new cost to v is either old cost to v or known\n14 least path cost to w plus cost from w to v */\n\n15 until N'= N\nLet’s consider the few first steps in detail.\nIn the initialization step, the currently known least-cost paths from u to its directly attached\nneighbours, v, x, and w, are initialized to 2, 1, and 5, respectively. Note in particular that the cost to\nw is set to 5 (even though we will soon see that a lesser-cost path does indeed exist) since this is the\ncost of the direct (one hop) link from u to w. The costs to y and z are set to infinity because they are\nnot directly connected to u.\nIn the first iteration, we look among those nodes not yet added to the set N’ and find that node with\nthe least cost as of the end of the previous iteration. That node is x, with a cost of 1, and thus x is\nadded to the set N’. Line 12 of the LS algorithm is then performed to update D(v) for all nodes v,\nyielding the results shown in the second line (Step 1) in below table. The cost of the path to v is\nunchanged. The cost of the path to w (which was 5 at the end of the initialization) through node x is\nfound to have a cost of 4. Hence this lower-cost path is selected and w’s predecessor along the\nshortest path from u is set to x. Similarly, the cost to y (through x) is computed to be 2, and the table\nis updated accordingly.\nIn the second iteration, nodes v and y are found to have the least-cost paths (2), and we break the\ntie arbitrarily and add y to the set N’ so that N’ now contains u, x, and y. The cost to the remaining\n\nProf. Maulik Trivedi, CE Department | 2140709 — Computer Networks (CN) 17\n"
  },
  {
    "page_number": 87,
    "content": "D Darshan 4 —- Network Layer\n\nInstitute of Engineering & Technology\n\nnodes not yet in N’, that is, nodes v, w, and z are updated via line 12 of the LS algorithm, yielding the\nresults shown in the third row in the below table.\n\nAndsoon....\n\nWhen the LS algorithm terminates, we have, for each node, its predecessor along the least-cost path\nfrom the source node.\n\nFor each predecessor, we also have its predecessor, and so in this manner we can construct the\nentire path from the source to all destinations.\n\nThe forwarding table in a node, say node u, can then be constructed from this information by\nstoring, for each destination, the next-hop node on the least-cost path from u to the destination.\nFigure 14. Shows the resulting least-cost paths for u for the network in Figure 13.\n\nstep N’ Div) plv) D(w),p(w) D(x), p(x) Diy), ply) D(z),p(z)\n0 u 2u 5u lu co eo\n] UX 2u 4x 2x eo\n2 uxy Qu 3y 4y\n3 uxy 3y 4y\n4 uxyww 4y\n5 UXywwz\n\nTable: Running the link-state algorithm on the network in Figure 13\np ww\n\nCE. a)\n\nFig. 14 Least cost path for nodule u\n\nThe Distance-Vector (DV) Routing Algorithm\n\nDistance-vector (DV) algorithm is iterative, asynchronous, and distributed.\nIt is distributed in that each node receives some information from one or more of its directly\nattached neighbours, performs a calculation, and then distributes the results of its calculation back\nto its neighbours.\nIt is iterative in that this process continues on until no more information is exchanged between\nneighbours.\nThe algorithm is asynchronous in that it does not require all of the nodes to operate in lockstep with\neach other.\nLet dx(y) be the cost of the least-cost path from node x to node y. Then the least costs are related by\nthe celebrated Bellman-Ford equation:\n\ndaly) = ming{c(x,v) + du{y)}\nwhere the miny in the equation is taken over all of x’s neighbours. Indeed, after traveling from x to v,\nif we then take the least-cost path from v to y, the path cost will be c(x,v) + dv(y).\n\nProf. Maulik Trivedi, CE Department | 2140709 — Computer Networks (CN) 18\n"
  },
  {
    "page_number": 88,
    "content": "Darshan\n\nInstitute of Engineering & Technology 4 — Network Layer\n\ne Since we must begin by traveling to some neighbour v, the least cost from x to y is the minimum of\nc(x,v) + dv(y) taken over all neighbours v.\n\n1 Initialization:\n\n2 for all destinations y in N:\n\n3 Diy) = ¢(x,y) /* if y is not a neighbor then c(x,y) = = */\n4 for each neighbor w\n\n5 D,(y) = ? for all destinations y in N\n\n6 for each neighbor w\n\n7 send distance vector D, = [D,(y): y in N] tow\n\n8\n\n9 loop\n\n10 wait (until I see a link cost change to some neighbor w or\n\n11 until I receive a distance vector from some neighbor w)\n12\n\n13 for each y in N:\n\n14 D.(y) = min,{c(x,v) + D,(y)}\n\n15\n\n16 if D.(y) changed for any destination y\n\n17 send distance vector D, = [D,(y): y in N] to all neighbors\n18\n\n19 forever\n\ne Figure 15 illustrates the operation of the DV algorithm for the simple three node network shown at\nthe top of the figure.\n\ne The operation of the algorithm is illustrated in a synchronous manner, where all nodes\nsimultaneously receive distance vectors from their neighbours, compute their new distance vectors,\nand inform their neighbours if their distance vectors have changed.\n\ne The leftmost column of the figure displays three initial routing tables for each of the three nodes.\n\ne For example, the table in the upper-left corner is node x’s initial routing table.\n\ne Within a specific routing table, each row is a distance vector - specifically, each node’s routing table\nincludes its own distance vector and that of each of its neighbours.\n\ne Thus, the first row in node y’s initial routing table is Dx = [D(x), Dx(y), Dx(z)] = [0, 2, 7].\n\ne The second and third rows in this table are the most recently received distance vectors from nodes y\nand z, respectively.\n\ne Because at initialization node x has not received anything from node y or z, the entries in the second\nand third rows are initialized to infinity.\n\ne After initialization, each node sends its distance vector to each of its two neighbours.\n\ne = This is illustrated in Figure 15 by the arrows from the first column of tables to the second column of\ntables.\n\ne For example, node x sends its distance vector D, = [0, 2, 7] to both nodes y and z. After receiving the\nupdates, each node recomputes its own distance vector.\n\ne For example, node x computes\n\nD,(x) = 0\nDx(y) = min{c(x,y) + Dy(y), ¢(x,z) + D-(y)} = min{2 + 0, 7+ 1}=2\nD,(z) = min{c(x,y) + Dy(z), c(x,z) + D,(z)} = min{2 + 1, 7+ O} =3\n\nProf. Maulik Trivedi, CE Department | 2140709 — Computer Networks (CN) 19\n"
  },
  {
    "page_number": 89,
    "content": "D Darshan\n\nInstitute of Engineering & Technology 4- Network Layer\n\nNode x table\n\nfrom\n\nNode y table\n\ncost to\n\nTime\n\nFig. 15 Distance-vector (DV) algorithm\n\ne The second column therefore displays, for each node, the node’s new distance vector along with\ndistance vectors just received from its neighbours.\n\ne Note, that node x’s estimate for the least cost to node z, Dx(z), has changed from 7 to 3.\n\ne Also note that for node x, neighbouring node y achieves the minimum in line 14 of the DV algorithm;\nthus at this stage of the algorithm, we have at node x that v*(y) =y and v*(z) =y.\n\ne After the nodes recomputes their distance vectors, they again send their updated distance vectors\nto their neighbours (if there has been a change).\n\ne = This is illustrated in Figure 15 by the arrows from the second column of tables to the third column of\ntables.\n\ne Note that only nodes x and z send updates: node y’s distance vector didn’t change so node y doesn’t\nsend an update.\n\nProf. Maulik Trivedi, CE Department | 2140709 — Computer Networks (CN) 20\n"
  },
  {
    "page_number": 90,
    "content": "Darshan\n\nIniaheved of Engineering a ibehiolisy 4 — Network Layer\n\ne After receiving the updates, the nodes then recomputes their distance vectors and update their\nrouting tables, which are shown in the third column.\n\ne The process of receiving updated distance vectors from neighbours, recomputing routing table\nentries, and informing neighbours of changed costs of the least-cost path to a destination continues\nuntil no update messages are sent.\n\ne At this point, since no update messages are sent, no further routing table calculations will occur and\nthe algorithm will enter a quiescent state; that is, all nodes will be performing the wait in Lines 10—\n11 of the DV algorithm.\n\ne The algorithm remains in the quiescent state until a link cost changes.\n\nComparison of (Difference between) LS and DV Routing\n\nAlgorithms\nDistance Vector Protocol Link state protocol\nEntire routing table is sent as an update Updates are incremental & entire routing table is\n\nnot sent as update\nDistance vector protocol send periodic update at | Updates are triggered not periodic\nevery 30 or 90 second\n\nUpdate are broadcasted Updates are multicasted\n\nUpdates are sent to directly connected neighbour | Update are sent to entire network & to just\nonly directly connected neighbour\n\nRouters don't have end to end visibility of entire | Routers have visibility of entire network of that\nnetwork. area only.\n\nIt is prone to routing loops No routing loops\n\nThe Count to Infinity problem\n\ne Distance vector routing works in theory but has a serious drawback in practice.\n\ne Consider a router whose best route to destination X is large.\n\ne If on the next exchange neighbour A suddenly reports a short delay to X, the router just switches\nover to using line to A to send traffic to X.\n\ne Suppose A is down initially and all the other routers know this. In other words, they have all\nrecorded the delay to A as infinity.\n\ne When Acomes up, the other routers learn about it via the vector exchanges.\n\ne Atthe time of the first exchange, B learns that its left neighbour has zero delay to A.\n\ne Bnow makes an entry in its routing table that A is one hop away to the left.\n\ne All the other routers still think that A is down. At this point, the routing table entries for A are as\nshown in the second row of Figure 16 (a).\n\ne On the next exchange, C learns that B has a path of length 1 to A, so it updates its routing table to\nindicate a path of length 2, but D and E do not hear the good news until later.\n\ne Clearly, the good news is spreading at the rate of one hop per exchange.\n\nProf. Maulik Trivedi, CE Department | 2140709 — Computer Networks (CN) 21\n"
  },
  {
    "page_number": 91,
    "content": "D Darshan 4 —- Network Layer\n\nInstitute of Engineering & Technology\n\nA B Cc D E A B Cc D E\no—__e__e__e\ne e ° e Initially 1 2 3 4 Initially\n1 e ° e After 1 exchange 3 2 3 4 After 1 exchange\n1 2 . e After 2 exchanges 3 4 3 4 After 2 exchanges\n1 2 3 e After 3 exchanges 5 4 5 4 After 3 exchanges\n1 2 3 4 After 4 exchanges 5 6 5 6 After 4 exchanges\n7 6 7 6 After 5 exchanges\n(a) 7 8 7 8 After 6 exchanges\ne e e e\n\n(b)\n\nFig. 16: The Count to infinity problem\nNow let us consider the situation of Figure 16 (b), in which all the lines and routers are initially up.\nRouters B, C, D, and E have distances to A of 1, 2, 3, and 4, respectively.\nSuddenly A goes down, or alternatively, the line between A and B is cut, which is effectively the\nsame thing from B's point of view.\nAt the first packet exchange, B does not hear anything from A.\nFortunately, C says: Do not worry; | have a path to A of length 2.\nLittle does B know that C's path runs through B itself. For all B knows, C might have ten lines all with\nseparate paths to A of length 2.\nAs a result, B thinks it can reach A via C, with a path length of 3. D and E do not update their entries\nfor A on the first exchange.\nOn the second exchange, C notices that each of its neighbours claims to have a path to A of length 3.\nIt picks one of them at random and makes its new distance to A 4, as shown in third row of Figure\n16(b).\nSubsequent exchanges produce the history shown in the rest of Figure 16(b).\nFrom this figure, it should be clear why bad news travels slowly: no router ever has a value more\nthan one higher than the minimum of all its neighbours.\nGradually, all routers work their way up to infinity, but the number of exchanges required depends\non the numerical value used for infinity.\nFor this reason, it is wise to set infinity to the longest path plus 1.\nNot entirely surprisingly, this problem is known as the count-to-infinity problem.\n\nHierarchical Routing\n\nAs networks grow in size, the router routing tables grow proportionally.\n\nNot only is router memory consumed by ever-increasing tables, but more CPU time is needed to\nscan them and more bandwidth is needed to send status reports about them.\n\nAt a certain point the network may grow to the point where it is no longer feasible for every router\nto have an entry for every other router, so the routing will have to be done hierarchically, as it is in\nthe telephone network.\n\nWhen hierarchical routing is used, the routers are divided into what called regions, with each router\nknowing all the details about how to route packets to destinations within its own region, but\nknowing nothing about the internal structure of other regions.\n\nProf. Maulik Trivedi, CE Department | 2140709 — Computer Networks (CN) 22\n"
  },
  {
    "page_number": 92,
    "content": "Darshan\n\n[niahevtd of Engineering @ioehiclésy 4—- Network Layer\n\nFull table for 1A Hierarchical table for 1A\nDest. Line Hops Dest. Line Hops\nRegion 1 Region 2 iA| - - 4A| - - |\nie “On 2B. 1B] 1B | 4 iB] 1B | 1 |\n: 1c{ ic | 4 ic[ ic [ 1 |\n2a| 1B 2 2| 1B 2 |\n2B/ 1B 3 3| 1C 2 |\n2c} 1B 3 4| 1c 3 |\n2D| 1B 4 5| 1C¢ 4 |\n3A| 1 3\n3B} 1C 2\n4A|_ 1C 3\nRegion3 Region4 Region 5 ae Te =\n4c| 1c 4\n5A} 1C 4\n5B|_1C 5\n6C| 1B 5\n5D| 1C 6\n5E|_1C 5\n\n(a) (b) (©)\nFig. 2: Hierarchical Routing\n\nFigure 17 gives a quantitative example of routing in a two-level hierarchy with five regions. The full\nrouting table for router 1A has 17 entries, as shown in Figure 17 (b).\n\nWhen routing is done hierarchically, as in Figure 17 (c), there are entries for all the local routers as\nbefore, but all other regions have been condensed into a single router, so all traffic for region 2 goes\nvia the 1B -2A line, but the rest of the remote traffic goes via the 1C -3B line. Hierarchical routing has\nreduced the table from 17 to 7 entries.\n\nAs the ratio of the number of regions to the number of routers per region grows, the savings in table\nspace increase.\n\nUnfortunately, these gains in space are not free. There is a penalty to be paid, and this penalty is in\nthe form of increased path length.\n\nFor example, the best route from 1A to 5C is via region 2, but with hierarchical routing all traffic to\nregion 5 goes via region 3, because that is better for most destinations in region 5.\n\nWhen a single network becomes very large, an interesting question is: How many levels should the\nhierarchy have? For example, consider a subnet with 720 routers.\n\nIf there is no hierarchy, each router needs 720 routing table entries. If the subnet is partitioned into\n24 regions of 30 routers each, each router needs 30 local entries plus 23 remote entries for a total of\n53 entries.\n\nBroadcast Routing\n\nIn some applications, hosts need to send messages to many or all other hosts.\n\nFor example, a service distributing weather reports, stock market updates, or live radio programs\nmight work best by broadcasting to all machines and letting those that are interested read the data.\nSending a packet to all destinations simultaneously is called broadcasting.\n\nFirst broadcasting method that requires no special features from the subnet is for the source to\nsimply send a distinct packet to each destination.\n\nProf. Maulik Trivedi, CE Department | 2140709 — Computer Networks (CN) 23\n"
  },
  {
    "page_number": 93,
    "content": "Darshan\n\nInstitute of Engineering & Technology 4- Network Layer\n\nNot only is the method wasteful of bandwidth, but it also requires the source to have a complete list\nof all destinations. In practice this may be the only possibility, but it is the least desirable of the\nmethods.\n\nB c\n\nA =i\n\n¢ Trt,\n\n(a) (b) (c)\n\nFig. 3: (a) A subnet. (b) A sink tree. (c) The tree built by reverse path forwarding\nFlooding is another Second method. Although flooding is ill-suited for ordinary point-to-point\ncommunication, for broadcasting it might rate serious consideration, especially if none of the\nmethods described below are applicable.\n\nThe problem with flooding as a broadcast technique is the same problem it has as a point-to-point\nrouting algorithm: it generates too many packets and consumes too much bandwidth.\n\nA third algorithm is multi destination routing.\n\nIf this method is used, each packet contains either a list of destinations or a bit map indicating the\ndesired destinations.\n\nWhen a packet arrives at a router, the router checks all the destinations to determine the set of\noutput lines that will be needed.\n\nThe router generates a new copy of the packet for each output line to be used and includes in each\npacket only those destinations that are to use the line.\n\nA fourth broadcast algorithm makes explicit use of the sink tree for the router initiating the\nbroadcast-or any other convenient spanning tree for that matter.\n\nA spanning tree is a subset of the subnet that includes all the routers but contains no loops.\n\nIf each router knows which of its lines belong to the spanning tree, it can copy an incoming\nbroadcast packet onto all the spanning tree lines except the one it arrived on.\n\nFifth broadcast algorithm is reverse path forwarding, is remarkably simple once it has been pointed\nout.\n\nWhen a broadcast packet arrives at a router, the router checks to see if the packet arrived on the\nline that is normally used for sending packets to the source of the broadcast.\n\nIf so, there is an excellent chance that the broadcast packet itself followed the best route from the\nrouter and is therefore the first copy to arrive at the router.\n\nThis being the case, the router forwards copies of it onto all lines except the one it arrived on.\n\nMulticast Routing\n\nSending a message to a group is called multicasting, and its routing algorithm is called multicast\nrouting.\n\nMulticasting requires group management. Some way is needed to create and destroy groups, and to\nallow processes to join and leave groups.\n\nProf. Maulik Trivedi, CE Department | 2140709 — Computer Networks (CN) 24\n"
  },
  {
    "page_number": 94,
    "content": "D Darshan 4 —- Network Layer\n\nInstitute of Engineering & Technology\n\nTo do multicast routing, each router computes a spanning tree covering all other routers.\n\nFor example, in Figure (a) we have two groups, 1 and 2.\n\nSome routers are attached to hosts that belong to one or both of these groups, as indicated in the\nfigure.\n\nA spanning tree for the leftmost router is shown in Figure (b).\n\nWhen a process sends a multicast packet to a group, the first router examines its spanning tree and\nprunes it, removing all lines that do not lead to hosts that are members of the group.\n\nIn our example, Figure (c) shows the pruned spanning tree for group 1.\n\n1 2\n1 « s 2 See. 2\n——— @\n1 ———* e @\n1 e\n(c) (a)\n\nFig. 49: (a) Anetwork. (b) A spanning tree for the leftmost router\ne Similarly, Figure (d) shows the pruned spanning tree for group 2. Multicast packets are\nforwarded only along the appropriate spanning tree.\n\nIntra-AS Routing\n\nIt is also known as interior gateway protocols (IGP)\nMost common intra-AS routing protocols:\n\n1. RIP: Routing Information Protocol\n\n2. OSPF: Open Shortest Path First\n\n3. IGRP: Interior Gateway Routing Protocol\n\nRIP (Routing Information Protocol)\n\nThe Routing Information Protocol (RIP) defines a way for routers, which connect networks using the\nInternet Protocol (IP), to share information about how to route traffic among networks.\n\nEach RIP router maintains a routing table, which is a list of all the destinations (networks) it knows\nhow to reach, along with the distance to that destination.\n\nRIP uses a distance vector algorithm to decide which path to put a packet on to get to its\ndestination.\n\nIt stores in its routing table the distance for each network it knows how to reach, along with the\naddress of the \"next hop\" router - another router that is on one of the same networks - through\nwhich a packet has to travel to get to that destination.\n\nProf. Maulik Trivedi, CE Department | 2140709 — Computer Networks (CN) 25\n"
  },
  {
    "page_number": 95,
    "content": "Darshan\n\n[niahevtd of Engineering @ioehiclésy 4—- Network Layer\n\nIf it receives an update on a route and the new path is shorter, it will update its table entry with the\nlength and next-hop address of the shorter path; if the new path is longer, it will wait through a\n\"hold-down\" period to see if later updates reflect the higher value as well, and only update the table\nentry if the new, longer path is stable.\n\nUsing RIP, each router sends its entire routing table to its closest neighbours every 30 seconds. (The\nneighbours are the other routers to which this router is connected directly - that is, the other\nrouters on the same network segments this router is on.)\n\nThe neighbours in turn will pass the information on to their nearest neighbours, and so on, until all\nRIP hosts within the network have the same knowledge of routing paths, a state known as\nconvergence.\n\nOSPF (Open Shortest Path First)\n\nThe Internet is made up of a large number of Autonomous Systems (AS).\n\nA routing algorithm within an AS is called an interior gateway protocol; an algorithm for routing\nbetween AS is called an exterior gateway protocol.\n\nMany of the ASes in the Internet are themselves large and nontrivial to manage.\n\nOSPF allows them to be divided into numbered areas, where an area is a network or a set of\ncontiguous networks.\n\nAreas do not overlap but need not be exhaustive, that is, some routers may belong to no area. An\narea is a generalization of a subnet.\n\nEvery AS has a backbone area, called area 0.\n\nAll areas are connected to the backbone, possibly by tunnels, so it is possible to go from any area in\nthe AS to any other area in the AS via the backbone.\n\nEach router that is connected to two or more areas is part of the backbone. As with other areas, the\ntopology of the backbone is not visible outside the backbone.\n\nBackbone\n\no\nFy\n8\nQ\ns\ns\nE\n\nBGP protocol\n\n| ae connects the ASes\n\nAS3 AS4 Area\n_—+ border\n\nrouter\n\n‘\nInternal router\n\ni\n'\nt\nt\n'\ni\nt\n'\n'\n'\n'\n'\n'\n'\nt\nt\nt\nt\nt\nt\nt\n\nAS tou tidary router\nFig. 5: The relation between ASes, backbones, and areas in OSPF\n\nProf. Maulik Trivedi, CE Department | 2140709 — Computer Networks (CN) 26\n"
  },
  {
    "page_number": 27,
    "content": "Darshan\n\nInstitute of Engineering & Technology\n\nB\n\n4 —- Network Layer\n\ne Within an area, each router has the same link state database and runs the same shortest path\nalgorithm.\ne Its main job is to calculate the shortest path from itself to every other router in the area, including\nthe router that is connected to the backbone, of which there must be at least one.\ne A router that connects to two areas needs the databases for both areas and must run the shortest\npath algorithm for each one separately.\ne This algorithm forces a star configuration on OSPF with the backbone being the hub and the other\nareas being spokes. Packets are routed from source to destination \"as is.\"\ne They are not encapsulated or tunneled, unless going to an area whose only connection to the\nbackbone is a tunnel. Figure shows part of the Internet with ASes and areas.\nOSPF distinguishes four classes of routers:\n1. Internal routers are wholly within one area.\n2. Area border routers connect two or more areas.\n3. Backbone routers are on the backbone.\n4. AS boundary routers talk to routers in other ASes.\nArea border router (ABR)\ne An area border router (ABR) is a router that connects one or more areas to the main backbone\nnetwork.\ne It is considered a member of all areas it is connected to.\ne An ABR keeps multiple copies of the link-state database in memory, one for each area to which\nthat router is connected.\nAutonomous system boundary router (ASBR)\ne An autonomous system boundary router (ASBR) is a router that is connected to more than one\nRouting protocol and that exchanges routing information with routers in other protocols.\ne ASBRs typically also run an exterior routing protocol (e.g., BGP), or use static routes, or both.\ne An ASBR is used to distribute routes received from other, external ASs throughout its own\nautonomous system.\nInternal router (IR)\ne An internal router is a router that has OSPF neighbour relationships with interfaces in the same\narea. An internal router has all its interfaces in a single area.\nBackbone router (BR)\ne The backbone routers accept information from the area border routers in order to compute the\nbest route from each backbone router to every other router.\ne = This information is propagated back to the area border routers, which advertise it within their\nareas.\n\nComparison between RIP OSPF and BGP\n\nRIP OSPF BGP\n\nRIP is intra domain routing\nprotocol used with in the\nautonomous system\n\nOSPF is also intra domain routing\nprotocol used with in the\nautonomous system\n\nIt is inter domain routing\nprotocol used between the\nautonomous system\n\nRIP is used for Small networks\nwith maximum number of hops\n16\n\nOSPF is used in large\nautonomous system with no\nlimitation\n\nThe BGP protocol is used for very\nlarge-scale networks\n\nRIP uses Distance Vector\n\nOSPF uses Link State\n\nBGP uses Path Vector\n\nProf. Maulik Trivedi, CE Department\n\n| 2140709 — Computer Networks (CN)\n\n27\n\n"
  },
  {
    "page_number": 97,
    "content": "D Darshan 4 —- Network Layer\n\nInstitute of Engineering & Technology\n\nRIP send entire routing update to | OSPF send multicast Hello packet | BGP send Open packet to the\n\nall directly connected interface to the neighbours, to create neighbours to create session\nsession\n\nRIP use Bellman ford Algorithm OSPF use Dijikstra Algorithm BGP use Path-Vector Routing\n\nConsider a router that interconnects three subnets: Subnet 1,\nSubnet 2, and Subnet 3. Suppose all of the interfaces in each of\nthese three subnets are required to have the prefix 23.1.17/24.\nAlso suppose that Subnet 1 is required to support at least 60\ninterfaces, Subnet 2 is to support at least 90 interfaces, and\nSubnet 3 is to support at least 12 interfaces. Provide three\nnetwork addresses (of the form a.b.c.d/x) that satisfy these\n\nconstraints.\ne For Subnet1 we have to support at least 60 interfaces and 26 >= 60 so the prefix for subnet1 is\n32-6 = 26 for subnet1 = 23.1.17.x/26\ne For Subnet2 we have to support at least 90 interfaces and 27 >= 90 so the prefix for subnet2 is\n32-7 = 25, and so subnet2 = 23.1.17.y/25\ne For Subnet3 we have to support at least 12 interfaces and 2%4 >= 12 so the prefix for subnet3 is\n32-4 = 28 , and so subnet3 = 23.1.17.z/28\ne Now find the values for x,y and z.\n> subnet 1 23.1.17.0/26\n> subnet 2 23.1.17.128/25\n> subnet 3 23.1.17.64/28\n\nSuppose datagrams are limited to 1,500 bytes (including\nheader) between source Host A and destination Host B.\nAssuming a 20-byte IP header, how many datagrams would be\nrequired to send an MP3 consisting of 5 million bytes? Explain\nhow you computed your answer.\n\nGiven: IP Header size = 20 bytes\nDatagram Size = 1500 bytes\nWe know: TCP Header size = 20 bytes\n\nSo to find the data contain in each datagram we need to deduct IP and TCP Header that is\n1500 - 20 - 20 = 1460 bytes\n\nEach datagram can carry maximum 1460 bytes.\n\nSo we number of datagrams required to send 5 million bytes =5000000 / 1460 = 3424.66\nSo we need 3425 datagrams to carry 5 million bytes.\n\nProf. Maulik Trivedi, CE Department | 2140709 — Computer Networks (CN) 28\n\n"
  },
  {
    "page_number": 98,
    "content": "Darshan\n\nasad of Engtueuctag a Teckoolsgy 5 — The Link layer and Local area networks\n\nThe Services Provided by the Link Layer\n\ne Framing: Almost all link-layer protocols encapsulate each network-layer datagram within a\nlink-layer frame before transmission over the link. The structure of the frame is specified by\nthe link-layer protocol.\n\ne Link access: A medium access control (MAC) protocol specifies the rules by which a frame is\ntransmitted onto the link. For point-to-point links that have a single sender at one end of the\nlink and a single receiver at the other end of the link, the MAC protocol is simple the sender\ncan send a frame whenever the link is idle. The more interesting case is when multiple nodes\nshare a single broadcast link - the so-called multiple access problem.\n\ne Reliable delivery: When a link-layer protocol provides reliable delivery service, it guarantees\nto move each network-layer datagram across the link without error. A link-layer reliable\ndelivery service can be achieved with acknowledgments and retransmissions.\n\ne Error detection and correction: The link-layer hardware in a receiving node can incorrectly\ndecide that a bit in a frame is zero when it was transmitted as a one, and vice versa. Such bit\nerrors are introduced by signal attenuation and electromagnetic noise. Because there is no\nneed to forward a datagram that has an error, many link-layer protocols provide a\nmechanism to detect such bit errors. This is done by having the transmitting node include\nerror-detection bits in the frame, and having the receiving node perform an error check.\n\nWhere is the link layer implemented?\ne It is implemented in each and every host.\ne = The link layer is implemented in a network adapter, also sometimes known as a network\ninterface card (NIC).\n\nHost\nApplication\nTransport\nNetwork\n| Link\n: : ~ Host bus\n(e.g., PCI)\n\nController\n\n— Network adapter\nPhysical\nPhysical\ntransmission\n\nFig. 1: Network adapter: its relationship to other host components and to protocol stack\nfunctionality\ne Figure 1 shows a network adapter attaching to a host’s bus (e.g., a PCI or PCI-X bus), where it\nlooks much like any other I/O device to the other host components.\ne Figure 1 also shows that while most of the link layer is implemented in hardware, part of the\nlink layer is implemented in software that runs on the host’s CPU.\n\nProf. Maulik Trivedi, CE Department | 2140709 — Computer Networks (CN) 1\n"
  },
  {
    "page_number": 99,
    "content": "@\nDar. sh qn 5 — The Link layer and Local area networks\n\nInstitute of Engineering & Technology\n\ne The software components of the link layer implement higher-level link layer functionality\nsuch as assembling link-layer addressing information and activating the controller hardware.\n\ne On the receiving side, link-layer software responds to controller interrupts (e.g., due to the\nreceipt of one or more frames), handling error conditions and passing a datagram up to the\nnetwork layer.\n\ne Thus, the link layer is a combination of hardware and software-the place in the protocol\nstack where software meets hardware.\n\nError Detection and Correction Techniques\n\ne Techniques for error detection\n1. parity checks\n2. checksum methods\n3. cyclic redundancy checks\nParity checks\ne Inthis technique, a redundant bit called parity bit, is appended to every data unit so that the\nnumber of 1s in the unit including the parity becomes even.\ne Blocks of data from the source are subjected to a check bit or Parity bit generator form,\nwhere a parity of 1 is added to the block if it contains an odd number of 1’s and 0 is added if\nit contains an even number of 1’s.\ne At the receiving end the parity bit is computed from the received data bits and compared\nwith the received parity bit.\ne This scheme makes the total number of 1’s even, that is why it is called even parity checking.\n\nSender Receiver\nAccept Data\nData Y\n101101\nReject Data\n| N\nCompute\nparity bit Compute\nparity bit\n101101 | 1 101101 | 1\nTransmission\nMedia\nFig. 2: Even parity checking scheme\nPerformance\n\ne Areceiver can detect all single bit errors in each code word.\ne Errors in more than one bit cannot be detected.\nTwo-dimension Parity Check\ne Performance can be improved by using two-dimensional parity check, which organizes the\nblock of bits in the form of a table.\n\nProf. Maulik Trivedi, CE Department | 2140709 — Computer Networks (CN) 2\n"
  },
  {
    "page_number": 100,
    "content": "Darshan\n\nasad of Engtueuctag a Teckoolsgy 5 — The Link layer and Local area networks\n\ne Parity check bits are calculated for each row, which is equivalent to a simple parity check bit.\ne Parity check bits are also calculated for all columns then both are sent along with the data.\ne Atthe receiving end these are compared with the parity bits calculated on the received data.\n\nOriginal 10110011 [10101011 [01011010 |11010101\n\n10110011 | 1\n\n10101011 | 1 Row parities\n\n01011010 | O\n11010101 | 1\n\nData to be sent 101100111] 101010111]010110100] 110101011 | 100101111\n\nColumn parities\n\nFig. 3: Two-dimensional parity check\n\nPerformance\n\ne Two- Dimension Parity Checking increases the likelihood of detecting burst errors.\n\ne 2-D Parity check of n bits can detect a burst error of n bits.\n\ne A burst error of more than n bits is also detected by 2-D Parity check with a high-probability.\n\ne If two bits in one data unit are damaged and two bits in exactly same position in another\ndata unit are also damaged, the 2-D Parity check checker will not detect an error.\n\nChecksum\n\ne Here, the data is divided into k segments each of m bits.\n\ne Inthe sender’s end the segments are added using 1’s complement arithmetic to get the sum.\n\ne The sum is complemented to get the checksum.\n\ne The checksum segment is sent along with the data segments.\n\ne At the receiver’s end, all received segments are added using 1’s complement arithmetic to\nget the sum. The sum is complemented.\n\ne Ifthe result is zero, the received data is accepted; otherwise discarded.\n\nProf. Maulik Trivedi, CE Department | 2140709 — Computer Networks (CN) 3\n"
  },
  {
    "page_number": 101,
    "content": "Darshan\n\nIaieieaed of Engineering a Tachactogy 5 — The Link layer and Local area networks\n\nReceived data\n\nk=4, m=8 10110011\n10110011 10101011\n10101011 01011110\n01011110 —e 1\n\nane 1 01011111\n01011111 01011010\n01011010 10111001\n10111001 11010101\n11010101 10001110\n\n<, 10001110 <=, 1\n1 10001111\n\nSum: 10001111 01110000\nComplement: | 01110000 Sum: 11111111\nComplement: 00000000\n\nFig. 4: Checksum\n\nPerformance\n\nThe checksum detects all errors involving an odd number of bits.\nIt also detects most errors involving even number of bits.\n\nCyclic Redundancy Checks (CRC)\n\nCRC is the most powerful and easy to implement technique.\n\nCRC is based on binary division.\n\nIn CRC, a sequence of redundant bits, are appended to the end of data unit so that the\nresulting data unit becomes exactly divisible by a second, predetermined binary number.\n\nAt the destination, the incoming data unit is divided by the same number.\n\nIf at this step there is no remainder, the data unit is assumed to be correct and is therefore\naccepted.\n\nA remainder indicates that the data unit has been damaged in transit and therefore must be\nrejected.\n\nThe binary number, which is (r+1) bit in length, can also be considered as the coefficients of\na polynomial, called Generator Polynomial.\n\nPerformance\n\nCRC is a very effective error detection technique.\n\nIf the divisor is chosen according to the previously mentioned rules, its performance can be\nsummarized as follows\n\nCRC can detect all single-bit errors\n\nCRC can detect all double-bit errors (three 1’s)\n\nCRC can detect any odd number of errors (X+1)\n\nCRC can detect all burst errors of less than the degree of the polynomial.\n\nProf. Maulik Trivedi, CE Department | 2140709 — Computer Networks (CN) 4\n"
  },
  {
    "page_number": 102,
    "content": "@\nDar. sh an 5 — The Link layer and Local area networks\n\nInstitute of Engineering & Technology\n\nSender a Receiver\n: Vv\nm n bits Data CRC\nData 00...0\n~ 7 n+1 bits\n{| n+1 bits _.\nDivisor\nDivisor\nbi \\Z\nn bits Remainder\nCRC\noe Y N\nAccept Reject\n—> Data CRC\n\nFig. 5: Basic scheme for Cyclic Redundancy Check\n\nFrame : 1101011011\nGenerator: 10011\nMessage after appending 4 zero bits: 11010110000\n\n1100001010\n10011/11010110110000\n10011\n\n10011\n10011\n\n00001\n00000\n\nProf. Maulik Trivedi, CE Department | 2140709 — Computer Networks (CN) 5\n"
  },
  {
    "page_number": 103,
    "content": "Darshan\n\nasad of Engtueuctag a Teckoolsgy 5 — The Link layer and Local area networks\n\nFrame >: 1101011011\nGenerator; 10011\nMessage after appending 4 zero bits: 11010110000\n\n1100001010\n10011]11010110110000\n\n10100\n1oo1t\n\n01110\n0 4 ; a ae Remainder\n\nTransmitted frame: 11010110111110\n\nMultiple access links and protocols\ne There are two types of network links:\n\n1. A point-to-point link consists of a single sender at one end of the link and a single\nreceiver at the other end of the link.\n\n2. A broadcast link, can have multiple sending and receiving nodes all connected to the\nsame, single, shared broadcast channel. The term broadcast is used here because\nwhen any one node transmits a frame, the channel broadcasts the frame and each\nof the other nodes receives a copy.\n\ne Multiple access problem: How to coordinate the access of multiple sending and receiving to\na shared broadcast channel.\n\ne In broadcast link all nodes are capable of transmitting frames, more than two nodes can\ntransmit frames at the same time.\n\ne When this happens, all of the nodes receive multiple frames at the same time; that is, the\ntransmitted frames collide at all of the receivers.\n\ne When there is a collision, none of the receiving nodes can make any sense of any of the\nframes that were transmitted; in a sense, the signals of the colliding frames become\ninextricably tangled together.\n\ne Thus, all the frames involved in the collision are lost, and the broadcast channel is wasted\nduring the collision interval.\n\ne If many nodes want to transmit frames frequently, many transmissions will result in\ncollisions, and much of the bandwidth of the broadcast channel will be wasted.\n\ne In order to ensure that the broadcast channel performs useful work when multiple nodes\nare active, it is necessary to somehow coordinate the transmissions of the active nodes.\n\ne This coordination job is the responsibility of the multiple access protocol.\n\nMultiple Access Protocols\ne Categories of Multiple Access Protocol:\n1. channel partitioning protocols\n> divide channel into smaller “pieces” (time slots, frequency, code)\n> allocate piece to node for exclusive use\n> Examples of channel partitioning protocols\n1. TDMA: Time Division Multiple Access\n2. FDMA: Frequency Division Multiple Access\n\nProf. Maulik Trivedi, CE Department | 2140709 — Computer Networks (CN) 6\n"
  },
  {
    "page_number": 104,
    "content": "Darshan\n\nasad of Engtueuctag a Teckoolsgy 5 — The Link layer and Local area networks\n\n3. CDMA: Code Division Multiple Access\n2. random access protocols\n> channel not divided and allow collisions\n> “recover” from collisions\n> examples of random access MAC (Medium Access Control) protocols\n1. ALOHA\n2. slotted ALOHA\n3. CSMA, CSMA/CD, CSMA/CA\n3. taking-turns protocols\n> nodes take turns but nodes with more to send can take longer turns\n> examples of taking-turns protocols\n1. polling\n2. token passing\n\nTDMA: Time Division Multiple Access\n\nSuppose the channel supports N nodes and that the transmission rate of the channel is R\nbps.\n\nTDM divides time into time frames and further divides each time frame into N time slots.\nEach time slot is then assigned to one of the N nodes. Whenever a node has a packet to\nsend, it transmits the packet’s bits during its assigned time slot in the revolving TDM frame.\nTypically, slot sizes are chosen so that a single packet can be transmitted during a slot time.\n\nTOM\na\n\nSlot Frame\n\nKey.\n\n[| slots labeled \"2\" are dedicated\n\nspecific sondersocaiver pair\n\nTDM is attractive because it eliminates collisions and is perfectly fair: Each node gets a\ndedicated transmission rate of R/N bps during each frame time.\n\nHowever, it has two major drawbacks. First, a node is limited to an average rate of R/N bps\neven when it is the only node with packets to send.\n\nA second drawback is that a node must always wait for its turn in the transmission sequence\nagain, even when it is the only node with a frame to send.\n\nFDMA: Frequency Division Multiple Access\n\nFDM divides the R bps channel into different frequencies (each with a bandwidth of R/N)\nand assigns each frequency to one of the N nodes.\n\nFDM thus creates N smaller channels of R/N bps out of the single, larger R bps channel.\n\nFDM shares both the advantages and disadvantages of TDM.\n\nIt avoids collisions and divides the bandwidth fairly among the N nodes.\n\nFDM also shares a principal disadvantage with TDM - a node is limited to a bandwidth of\nR/N, even when it is the only node with packets to send.\n\na\n\n2 E Link\naxie{\n\nProf. Maulik Trivedi, CE Department | 2140709 — Computer Networks (CN) 7\n"
  },
  {
    "page_number": 105,
    "content": "Darshan\n\nasad of Engtueuctag a Teckoolsgy 5 — The Link layer and Local area networks\n\nCDMA: Code Division Multiple Access\n\ne While TDM and FDM assign time slots and frequencies, respectively to the nodes, CDMA\nassigns a different code to each node.\n\ne Each node then uses its unique code to encode the data bits it sends.\n\ne If the codes are chosen carefully, CDMA networks have the wonderful property that\ndifferent nodes can transmit simultaneously and yet have their respective receivers correctly\nreceive a sender’s encoded data bits in spite of interfering transmissions by other nodes.\n\ne CDMA has been used in military systems for some time and now has widespread civilian use,\nparticularly in cellular telephony.\n\ne Because CDMA’s use is so tightly tied to wireless channels.\n\ne = It will suffice to know that CDMA codes, like time slots in TDM and frequencies in FDM, can\nbe allocated to the multiple access channel users.\n\nPure ALOHA and Slotted ALOHA Protocol\nPure ALOHA\n\ne Pure ALOHA allows users to transmit whenever they have data to be sent.\n\ne Senders wait to see if a collision occurred (after whole message has been sent).\n\ne = If collision occurs, each station involved waits a random amount of time then tries again.\n\ne Systems in which multiple users share a common channel in a way that can lead to conflicts\nare widely known as contention systems.\n\nStation 1\n\nStation 2\n\nrr\nsaons GM mm  —ei(i‘iU [Famesz]\n\nStation4 as... ----------- ra\n(ee Time\nCollision Collision\nduration duration\n\nFig. 6: In pure ALOHA, frames are transmitted at completely arbitrary times\n\ne Whenever two frames try to occupy the channel at the same time, there will be a collision\nand both will be garbled.\n\ne = If the first bit of a new frame overlaps with just the last bit of a frame almost finished, both\nframes will be totally destroyed and both will have to be retransmitted later.\n\nWhat is the efficiency of an ALOHA channel?\n\ne Let the \"frame time\" denote the amount of time needed to transmit the standard, fixed-\nlength frame.\n\ne Also assume that the infinite population of users generates new frames with mean N frames\nper frame time.\n\nProf. Maulik Trivedi, CE Department | 2140709 — Computer Networks (CN) 8\n"
  },
  {
    "page_number": 106,
    "content": "Darshan\n\nIaieieaed of Engineering a Tachactogy 5 — The Link layer and Local area networks\n\nIf N > 1, the user community is generating frames at a higher rate than the channel can\nhandle, and nearly every frame will suffer a collision. For reasonable throughput we would\nexpectO<N<1.\nLet us further assume that the probability of k transmission attempts per frame time, old\nand new combined, is also Poisson, with mean G per frame time.\nUnder all loads, the throughput, S, is just the offered load, G, times the probability, Po, of a\ntransmission succeeding-that is, S = GPo, where Po is the probability that a frame does not\nsuffer a collision.\nThe probability that k frames are generated during a given frame time is given by the\nGke-G\n\nk!\nThe maximum throughput occurs at G = 0.5, with S = 1/2e, which is about 0.184.\n\nPoisson distribution: Pr[k] =\n\nSlotted ALOHA\n\nStation 1 |\nStation 2 |\nStation 3 |\nStation 4 a |\n\nSlotted ALOHA was invented to improve the efficiency of pure ALOHA as chances of collision\nin pure ALOHA are very high.\n\nIn slotted ALOHA, the time of the shared channel is divided into discrete intervals called\nslots.\n\nThe stations can send a frame only at the beginning of the slot and only one frame is sent in\neach slot.\n\nIn slotted ALOHA, if any station is not able to place the frame onto the channel at the\nbeginning of the sloti.e. it misses the time slot then the station has to wait until the\n\nbeginning of the next time slot.\nCollision Collision\n\nduration — duration\n\nF=___[Fremett | _____e\n>\n\nae el\n\n= |---| —____ _ Bee\nEe\n\na\n\nSlot 1 Slot2 Slot 3 Slot 4 Slot 5 Slot 6\nFig. 7: Frames transmitted in Slotted ALOHA\n\nWhat is the efficiency of an ALOHA channel?\n\nPure ALOHA > S = Ge?\n\nSlotted ALOHA > S=Ge®\n\nProf. Maulik Trivedi, CE Department | 2140709 — Computer Networks (CN) 9\n"
  },
  {
    "page_number": 107,
    "content": "Darshan\n\nasad of Engtueuctag a Teckoolsgy 5 — The Link layer and Local area networks\n\nnee Slotted ALOHA: S = Ge-S\n\n0.30\n\n0.20\n0.10 Pure ALOHA: S$ = Ge-#4\n\nS (throughput per frame time)\n\n[°) 0.5 1.0 1.5 2.0 3.0\nG (attempts per packet time)\nFig. 8: Throughput versus offered traffic for ALOHA systems\n\ne As seen in figure both graphs have the same shape. If G is small so is S, which means that if\nfew frames are generated few frames will be transmitted successfully.\n\ne As G increases so does S but up to a certain point. As G continues to increase S approaches\nto 0 which means that if more frames are generated there will be more collisions and the\nsuccess rate will fall to 0.\n\ne Similarly for pure ALOHA the maximum occurs at G=0.5 for which S = 1/2e = 0.184 which\nmeans the rate of successful transmissions is approximately 18.4%.\n\ne As seen from the graph the maximum for slotted ALOHA occurs at G=1 for which\nS=1/e=0.368. In other words the rate of successful transmissions is approximately 0.368\nframes per slot time or 37% of the time will be spent on successful transmissions.\n\nAdvantages of Slotted Aloha\n\ne Asingle active node can continuously transmit at full rate of channel.\n\ne Slotted ALOHA is also highly decentralized, because each node detects collisions and\nindependently decides when to retransmit.\n\ne Slotted ALOHA is also an extremely simple protocol.\n\nDisadvantages of Slotted Aloha\n\ne When there are multiple active nodes, a certain fraction of the slots will have collisions and\nwill therefore be wasted.\n\ne idle slots\n\ne nodes may be able to detect collision in less than time to transmit packet\n\ne clock synchronization\n\nCSMA (Carrier Sense Multiple Access) Protocols\n\ne Protocols in which stations listen for a carrier (i.e., a transmission) and act accordingly are\ncalled carrier sense protocols.\n\ne There are various CSMA protocol:\n\nProf. Maulik Trivedi, CE Department | 2140709 — Computer Networks (CN) 10\n"
  },
  {
    "page_number": 108,
    "content": "Darshan\n\nnea of Encinmestag & Teahsalog) 5 — The Link layer and Local area networks\n\n1. 1-persistent CSMA 3. p-persistent CSMA\n2. Non persistent COMA 4. CSMA/CD (CSMA with Collision Detection)\n\n1-persistent CSMA\n\nWhen a station has data to send, it first listens to the channel to see if anyone else is\ntransmitting at that moment.\n\nIf the channel is busy, the station waits until it becomes idle.\n\nWhen the station detects an idle channel, it transmits a frame. If a collision occurs, the station\nwaits a random amount of time and starts all over again.\n\nThe protocol is called 1-persistent because the station transmits with a probability of 1 when it\nfinds the channel idle.\n\nThe propagation delay has an important effect on the performance of the protocol.\n\nThere is a small chance that just after a station begins sending, another station will become\nready to send and sense the channel.\n\nIf the first station's signal has not yet reached the second one, the latter will sense an idle\nchannel and will also begin sending, resulting in a collision.\n\nThe longer the propagation delay, the more important this effect becomes, and the worse the\nperformance of the protocol.\n\nEven if the propagation delay is zero, there will still be collisions.\n\nIf two stations become ready in the middle of a third station's transmission, both will wait\npolitely until the transmission ends and then both will begin transmitting exactly simultaneously,\nresulting in a collision.\n\nIf they were not so impatient, there would be fewer collisions.\n\nNon persistent COMA\n\nIn this protocol, a conscious attempt is made to be less greedy than in the previous one.\n\nBefore sending, a station senses the channel. If no one else is sending, the station begins doing\nso itself.\n\nHowever, if the channel is already in use, the station does not continually sense it for the\npurpose of seizing it immediately upon detecting the end of the previous transmission.\n\nInstead, it waits a random period of time and then repeats the algorithm. Consequently, this\nalgorithm leads to better channel utilization but longer delays than 1-persistent COMA\n\nP-persistent CSMA\n\nIt applies to slotted channels.\n\nWhen a station becomes ready to send, it senses the channel.\n\nIf it is idle, it transmits with a probability p.\n\nWith a probability q=1-p, it defers until the next slot.\n\nIf that slot is also idle, it either transmits or defers again, with probabilities p and q.\n\nThis process is repeated until either the frame has been transmitted or another station has\nbegun transmitting.\n\nIn the latter case, the unlucky station acts as if there had been a collision (i.e., it waits a random\ntime and starts again).\n\nIf the station initially senses the channel busy, it waits until the next slot and applies the above\nalgorithm.\n\nFigure shows the computed throughput versus offered traffic for all three protocols.\n\nProf. Maulik Trivedi, CE Department | 2140709 — Computer Networks (CN) 11\n"
  },
  {
    "page_number": 109,
    "content": "@\nDarshan 5 — The Link layer and Local area networks\n\nInstitute of Engineering & Technology\n\n0.01-persistent CSMA\n\nNonpersistent CSMA\n\no-=\nao)\n.\n\n0.1-persistent CSMA\n\n0.5-persistent\n\nper packet time)\nooo\noa nN @\nT\n\n0.5\n0.4\n\n°\n&\n\n0.2\n\nS (throughput\n\n°\n\n% 1 2 3 4 5 6 7 8 9\n\nG (attempts per packet time)\nFig. 9: Comparison of the channel utilization versus load for various random access protocols\n\nCSMA/CD (CSMA with Collision Detection)\ne If two stations sense the channel to be idle and begin transmitting simultaneously, they will both\ndetect the collision almost immediately.\ne Rather than finish transmitting their frames, which are irretrievably garbled anyway, they should\nabruptly stop transmitting as soon as the collision is detected.\ne Quickly terminating damaged frames saves time and bandwidth.\ne This protocol, known as CSMA/CD (CSMA with Collision Detection) is widely used on LANs in the\n\nMAC sublayer.\nContention\nb slots\n\n| A |\nrome 0} 0) (r= J [1 [tere =\n\nee,\" —_ a.\nTransmission Contention Idle\nperiod period period\n\nTime ——>\nFig. 10: CSMA/CD can be in one of three states: contention, transmission, or idle\n\ne CSMA/CD, as well as many other LAN protocols, uses the conceptual model of Figure.\n\ne Atthe point marked to, a station has finished transmitting its frame.\n\ne Any other station having a frame to send may now attempt to do so. If two or more stations\ndecide to transmit simultaneously, there will be a collision.\n\ne Collisions can be detected by looking at the power or pulse width of the received signal and\ncomparing it to the transmitted signal.\n\ne After a station detects a collision, it aborts its transmission, waits a random period of time, and\nthen tries again, assuming that no other station has started transmitting in the meantime.\n\ne Therefore, model for CSMA/CD will consist of alternating contention and transmission periods,\nwith idle periods occurring when all stations are quiet.\n\nTaking turns MAC protocols\nPolling\n\ne The polling protocol requires one of the nodes to be designated as a master node.\ne The master node polls each of the nodes in a round-robin fashion.\n\nProf. Maulik Trivedi, CE Department | 2140709 — Computer Networks (CN) 12\n"
  },
  {
    "page_number": 110,
    "content": "Darshan\n\n[nistbR of Engineering & tockaotony 5 — The Link layer and Local area networks\n\nIn particular, the master node first sends a message to node 1, saying that it (node 1) can\ntransmit up to some maximum number of frames.\n\nAfter node 1 transmits some frames, the master node tells node 2 it (node 2) can transmit up to\nthe maximum number of frames.\n\nThe master node can determine when a node has finished sending its frames by observing the\nlack of a signal on the channel.\n\nThe procedure continues in this manner, with the master node polling each of the nodes in a\ncyclic manner.\n\nThe polling protocol eliminates the collisions and empty slots that plague random access\nprotocols.\n\nThis allows polling to achieve a much higher efficiency.\n\nThe first drawback is that the protocol introduces a polling delay—the amount of time required\nto notify a node that it can transmit.\n\nThe second drawback, which is potentially more serious, is that if the master node fails, the\n\nentire channel becomes inoperative.\n\n(nothing\nto send)\n\nslaves\nFig. 11: Polling Fig. 12: Token Passing\n\nToken Passing\n\nIn taking-turns protocol there is no master node.\n\nA small, special-purpose frame known as a token is exchanged among the nodes in some fixed\norder.\n\nFor example, node 1 might always send the token to node 2, node 2 might always send the\ntoken to node 3, and node N might always send the token to node 1.\n\nWhen a node receives a token, it holds onto the token only if it has some frames to transmit;\notherwise, it immediately forwards the token to the next node.\n\nIf a node does have frames to transmit when it receives the token, it sends up to a maximum\nnumber of frames and then forwards the token to the next node.\n\nToken passing is decentralized and highly efficient. But it has its problems as well. For example,\nthe failure of one node can crash the entire channel. Or if a node accidentally neglects to release\nthe token, then some recovery procedure must be invoked to get the token back in circulation.\n\nProf. Maulik Trivedi, CE Department | 2140709 — Computer Networks (CN) 13\n"
  },
  {
    "page_number": 111,
    "content": "Darshan\n\nnea of Encinmestag & Teahsalog) 5 — The Link layer and Local area networks\n\nEthernet\n\nEthernet is one of the widely used local area network (LAN) technology.\n1. Switched Ethernet\n2. Fast Ethernet\n3. Gigabit Ethernet\n\nSwitched Ethernet\nSwitch\nConnector To hosts\nEtiemet b To hosts\nTo hosts\n10Base-T\nconnection\n\nTo the host computers\n\nFig. 1: A simple example of switched Ethernet\nSwitched Ethernet gives dedicated 10 Mbps bandwidth on each of its ports.\nOn each of the ports one can connect either a thick/thin segment or a computer.\nIn Switched Ethernet, the collision domain is separated.\nThe hub is replaced by a switch, which functions as a fast bridge.\nIt can recognize the destination address of the received frame and can forward the frame to the\nport to which the destination station is connected.\nThe other ports are not involved in the transmission process.\nThe switch can receive another frame from another station at the same time and can route this\nframe to its own final destination.\nIn this case, both the physical and logical topologies are star.\nThe throughput can be further increased on switched Ethernet by using full-duplex technique,\nwhich uses separate wire pairs for transmitting and receiving.\nThus a station can transmit and receive simultaneously, effectively doubling the throughput to\n20 Mbps on each port.\n\nFast Ethernet\n\nThe 802.u or the fast Ethernet, as it is commonly known, was approved by the IEEE 802\nCommittee.\n\nThe fast Ethernet uses the same frame format, same CSMA/CD protocol and same interface as\nthe 802.3, but uses a data transfer rate of 100 Mbps instead of 10 Mbps.\n\nHowever, fast Ethernet is based entirely on 10-Base-T, because of its advantages (Although\ntechnically 10-BASE-5 or 10-BASE-2 can be used with shorter segment length).\n\nIEEE has designed two categories of Fast Ethernet: 100Base-X and 100Base-T4.\n\n100Base-X uses two-wire interface between a hub and a station while 100Base-T4 uses four-\nwire interface.\n\n100-Base-x itself is divided into two: 100Base-TX and 100base-FX\n\nProf. Maulik Trivedi, CE Department | 2140709 — Computer Networks (CN) 14\n"
  },
  {
    "page_number": 112,
    "content": "Darshan\n\n[nistbR of Engineering & tockaotony 5 — The Link layer and Local area networks\n\n100Base-T4 | Twistedpair | 100m | Uses category 3 UTP\n100Base-TX Full duplex at 100 Mbps\n\n100Base-FX | Fiber optics 2000 m Full duplex at 100 Mbps; long runs\n\nUpgrade the data rate to 100 Mbps.\n\nMake it compatible with Standard Ethernet.\n\nKeep the same 48-bit address.\n\nKeep the same frame format.\n\nKeep the same minimum and maximum frame lengths.\n\nGigabyte Ethernet\n\nThe technology is based on fiber optic cable. Multi-mode fiber is able to transmit at gigabit rate\nto at least 580 meters and with single-mode runs exceeding 3 km.\n\nFiber optic cabling is costly. In order to reduce the cost of cabling, the 802.3z working group also\nproposed the use of twisted pair or cable or coaxial cable for distances up to 30 meters.\n\nAt gigabit speed, two stations 200 meters apart will not detect a collision, when both\nsimultaneously send 64-byte frames.\n\nThis inability to detect collision leads to network instability.\n\nA mechanism known as carrier extension has been proposed for frames shorter than 512 bytes.\nThe number of repeater hops is also restricted to only one in place of two for 100 Base-T.\n\nName Cable Max. segment Advantages\n1000Base-SX | Fiber optics 550m | Multimode fiber (50, 62.5 microns)\n1000Base-LX | Fiber optics 5000 m | Single (10 i) or multimode (50, 62.5 11)\n1000Base-CX | 2 Pairs of STP 25m | Shielded twisted pair\n1000Base-T 4 Pairs of UTP 100m | Standard category 5 UTP\n\nUpgrade the data rate to 1 gbps.\n\nMake it compatible with Standard or Fast Ethernet.\n\nUse the same 48-bit address.\n\nUse the same frame format.\n\nKeep the same minimum and maximum frame lengths.\nTo support auto-negotiation as defined in Fast Ethernet.\n\nVirtual LANs\n\nA VLAN is a switched network that is logically segmented by functions, project teams, or\napplications without regard to the physical location of users.\n\nFor example, several end stations might be grouped as a department, such as engineering or\naccounting.\n\nWhen the end stations are physically located close to one another, you can group them into a\nLAN segment.\n\nIf any of the end stations are in different buildings (not the same physical LAN segment), you can\nthen group them into a VLAN.\n\nProf. Maulik Trivedi, CE Department | 2140709 — Computer Networks (CN) 15\n"
  },
  {
    "page_number": 113,
    "content": "Darshan\n\nInitieaea of Enginesring  Techaotogy 5 — The Link layer and Local area networks\n\nTwisted pair” Office\nto a hub\n\nFig. 14: VLAN\n\ne VLANs provide the following features:\n\nSimplification of end-station moves, adds and changes\n\ne When an end station is physically moved to a new location, its attributes can be reassigned from\na network management station through Simple Network Management Protocol (SNMP) or\nthrough the user interface menus.\n\ne When an end station is moved within the same VLAN, it retains its previously assigned attributes\nin its new location. When an end station is moved to a different VLAN, the attributes of the new\nVLAN are applied to the end station.\n\nControlled traffic activity\n\ne VLANs allow ports on the same or different switches to be grouped so that traffic is confined to\nmembers of only that group.\n\ne This feature restricts broadcast, unicast, and multicast traffic (flooding) only to ports included in\na certain VLAN.\n\ne The management domain is a group of VLANs that are managed by a single administrative\nauthority.\n\nWorkgroup and network security\n\ne You can increase security by segmenting the network into distinct broadcast domains.\n\ne To this end, VLANs can restrict the number of users in a broadcast domain.\n\ne You can also control the size and composition of the broadcast domain by controlling the size\nand composition of a VLAN.\n\nComponents\n\ne Networks that have VLANs contain one or more of the following components:\n\n> Switches that logically segment connected end stations\n\n> Routers that provide VLAN communications between workgroups\n\n> Transport protocols that carry VLAN traffic across shared LAN and ATM backbones\n> — Interoperability with previously installed LAN systems\n\nEthernet frame structure\n\nPreamble. Deta cac\n\nvi\n\nProf. Maulik Trivedi, CE Department | 2140709 — Computer Networks (CN) 16\n"
  },
  {
    "page_number": 114,
    "content": "Darshan\n\nnea of Encinmestag & Teahsalog) 5 — The Link layer and Local area networks\n\nData field (46 to 1,500 bytes): This field carries the IP datagram. The maximum transmission\nunit (MTU) of Ethernet is 1,500 bytes. This means that if the IP datagram exceeds 1,500 bytes,\nthen the host has to fragment the datagram. The minimum size of the data field is 46 bytes. This\nmeans that if the IP datagram is less than 46 bytes, the data field has to be “stuffed” to fill it out\nto 46 bytes. When stuffing is used, the data passed to the network layer contains the stuffing as\nwell as an IP datagram.\n\nDestination address (6 bytes): This field contains the MAC address of the destination adapter,\nBB-BB-BB-BB-BB-BB. When adapter B receives an Ethernet frame whose destination address is\neither BB-BB-BB-BB-BB-BB or the MAC broadcast address, it passes the contents of the frame’s\ndata field to the network layer; if it receives a frame with any other MAC address, it discards the\nframe.\n\nSources address (6 bytes): This field contains the MAC address of the adapter that transmits the\nframe onto the LAN, in this example, AA-AA-AA-AA-AA-AA.\n\nType field (2 bytes): The type field permits Ethernet to multiplex network-layer protocols. To\nunderstand this, we need to keep in mind that hosts can use other network-layer protocols\nbesides IP. In fact, a given host may support multiple network-layer protocols using different\nprotocols for different applications. For this reason, when the Ethernet frame arrives at adapter\nB, adapter B needs to know to which network-layer protocol it should pass (that is, demultiplex)\nthe contents of the data field.\n\nCyclic redundancy checks (CRC) (4 bytes): The purpose of the CRC field is to allow the receiving\nadapter, adapter B, to detect bit errors in the frame.\n\nPreamble (8 bytes): The Ethernet frame begins with an 8-byte preamble field. Each of the first 7\nbytes of the preamble has a value of 10101010; the last byte is 10101011. The first 7 bytes of\nthe preamble serve to “wake up” the receiving adapters and to synchronize their clocks to that\nof the sender’s clock. Why should the clocks be out of synchronization? Keep in mind that\nadapter A aims to transmit the frame at 10 Mbps, 100 Mbps, or 1 Gbps, depending on the type\nof Ethernet LAN. However, because nothing is absolutely perfect, adapter A will not transmit the\nframe at exactly the target rate; there will always be some drift from the target rate, a drift\nwhich is not known a priori by the other adapters on the LAN. A receiving adapter can lock onto\nadapter A’s clock simply by locking onto the bits in the first 7 bytes of the preamble. The last 2\nbits of the eighth byte of the preamble (the first two consecutive 1s) alert adapter B that the\n“important stuff” is about to come.\n\nBit and Byte Stuffing\nBit Stuffing\n\nIn a bit-oriented protocol, the data to send is a series of bits.\n\nIn order to distinguish frames, most protocols use a bit pattern of 8-bit length (01111110) as flag\nat the beginning and end of each frame.\n\nHere also cause the problem of appearance of flag in the data part to deal with this an extra bit\nadded.\n\nThis method is called bit stuffing. In bit stuffing, if a O and five successive 1 bits are encountered,\nan extra 0 is added.\n\nThe receiver node removes the extra-added zero.\n\nThis process is illustrate below,\n\nProf. Maulik Trivedi, CE Department | 2140709 — Computer Networks (CN) 17\n"
  },
  {
    "page_number": 115,
    "content": "Darshan\n\nInitieaea of Enginesring  Techaotogy 5 — The Link layer and Local area networks\n\nData to send\n(from upper\nlayer)\n\n0001111111110000101010111110010\n\nFrame to send }\nono | Header | 0001111011111000\n\n110101111100010 | Tite | vate |\n\nFrame received\nO10 | Header 900111191111100001010101111190010 | Seite\n\no1liiiie |\n\nBit unstuffed\n\nData to upper\n\nlayer\n\n9001111111110000101010111110010 |\n\nByte Stuffing\n\ne The second framing solves the problem of resynchronization by having each frame start and end\nwith special bytes.\n\ne A flag byte is used to separate the frame as both the starting and ending delimiter, as shown in\nfigure.\n\ne In this way, if the receiver ever loses synchronization, it can just search for the flag byte to find\nthe end of the current frame.\n\ne Two consecutive flag bytes indicate the end of one frame and start of the next one.\n\ne It may easily happen that the flag byte's bit pattern occurs in the data.\n\ne To solve this problem is to have the sender's data link layer insert a special escape byte (ESC)\njust before each \"accidental\" flag byte in the data.\n\ne The data link layer on the receiving end removes the escape byte before the data are given to\nthe network layer.\n\ne This technique is called byte stuffing or character stuffing.\n\nDisadvantage of using this framing method is that it is closely tied to the use of 8-bit characters.\n\ne Not all character codes use 8-bit characters.\n\ne  E.g., UNICODE uses 16-bit characters\n\nProf. Maulik Trivedi, CE Department | 2140709 — Computer Networks (CN) 18\n"
  },
  {
    "page_number": 116,
    "content": "Institute of Engineering & Technology\n\n@\nDarshan 5 — The Link layer and Local area networks\n\n|FLAG} Header Payload field Trailer |rvac|\n\n(a)\nOriginal characters After stuffing\n\n| A Fvac| B a | esc |\n\nnue] =\n\n| A [ese | |ruac| | B | A [esc | [esc | [esc lFuacl | 8 |\nA | [ese] esc] | 8 | A | [esc] [esc] [esc] | esc | 8 |\n\n{b)\n\nSelf-Learning Properties of Link Layer Switches\ne A switch has the wonderful property that its table is built automatically, dynamically, and\nautonomously, without any intervention from a network administrator or from a configuration\nprotocol. In other words, switches are self-learning.\ne = This capability is accomplished as follows:\n1. The switch table is initially empty.\n2. For each incoming frame received on an interface, the switch stores in its table\n> the MAC address in the frame’s source address field,\n> the interface from which the frame arrived\n> the current time.\nIn this manner the switch records in its table the LAN segment on which the sender\nresides. If every host in the LAN eventually sends a frame, then every host will\neventually get recorded in the table.\n3. The switch deletes an address in the table if no frames are received with that address as\nthe source address after some period of time (the aging time).\ne  Inthis manner, if a PC is replaced by another PC (with a different adapter), the MAC address of\nthe original PC will eventually be purged from the switch table.\ne —Let’s walk through the self-learning property for the uppermost switch in Figure 15.\ne Suppose at time 9:39 a frame with source address 01-12-23-34-45-56 arrives from interface 2.\ne Suppose that this address is not in the switch table. Then the switch adds a new entry to the\ntable.\ne Continuing with this same example, suppose that the aging time for this switch is 60 minutes,\nand no frames with source address 62-FE-F7-11-89-A3 arrive to the switch between 9:32 and\n10:32. Then at time 10:32, the switch removes this address from its table.\n\nProf. Maulik Trivedi, CE Department | 2140709 — Computer Networks (CN) 19\n"
  },
  {
    "page_number": 117,
    "content": "Darshan\n\nInitieaea of Enginesring  Techaotogy 5 — The Link layer and Local area networks\n\nTo external ———____=-( > F\ninternet &\nS 100 Mbps\n(fiber)\n\n100 Mbps al\n\n(fiber)\n\nMixture of 10 Mbps,\n100 Mbps, 1 Gbps,\n\nCat 5 cable\n== =\n\nElectrical Engineering Computer Science Computer Engineering\nFig. 15: An institutional network connected together by four switches\n\nAddkess bnterface Time\n62-FEFT-11-89:43 ] 9:32\n7CBA82-B4-91-10 3 9:36\n\nARP (Address Resolution Protocol)\n\nAddress Resolution Protocol (ARP) is a protocol for mapping an Internet Protocol address (IP\naddress) to a physical machine address that is recognized in the local network.\n\nFor example, in IP Version 4, the most common level of IP in use today, an address is 32 bits\nlong.\n\nIn an Ethernet local area network, however, addresses for attached devices are 48 bits long.\n(The physical machine address is also known as a Media Access Control or MAC address.)\n\nA table, usually called the ARP cache, is used to maintain a correlation between each MAC\naddress and its corresponding IP address.\n\nARP provides the protocol rules for making this correlation and providing address conversion in\nboth directions.\n\nHow ARP works\n\nWhen an incoming packet destined for a host machine on a particular local area network arrives\nat a gateway, the gateway asks the ARP program to find a physical host or MAC address that\nmatches the IP address.\n\nThe ARP program looks in the ARP cache and, if it finds the address, provides it so that the\npacket can be converted to the right packet length and format and sent to the machine.\n\nIf no entry is found for the IP address, ARP broadcasts a request packet in a special format to all\nthe machines on the LAN to see if one machine knows that it has that IP address associated with\nit.\n\nA machine that recognizes the IP address as its own returns a reply so indicating.\n\nProf. Maulik Trivedi, CE Department | 2140709 — Computer Networks (CN) 20\n"
  },
  {
    "page_number": 118,
    "content": "Darshan\n\nInitieaea of Enginesring  Techaotogy 5 — The Link layer and Local area networks\n\ne ARP updates the ARP cache for future reference and then sends the packet to the MAC address\nthat replied.\ne A possible ARP table in any node is as per below\n\nIP Address WAC Address Tl\n222.272.222.221 88-82-2F-54-1A0F 13:45:00\n222.272.722.223 SCOGAB907581 13:52:00\n\ne Since protocol details differ for each type of local area network, there are separate ARP\nRequests for Comments (RFC) for Ethernet, ATM, Fiber Distributed-Data Interface, HIPPI, and\nother protocols.\n\nProf. Maulik Trivedi, CE Department | 2140709 — Computer Networks (CN) 21\n"
  }
]